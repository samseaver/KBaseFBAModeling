package Bio::KBase::fbaModelServices::Impl;
use strict;
use Bio::KBase::Exceptions;
# Use Semantic Versioning (2.0.0-rc.1)
# http://semver.org 
our $VERSION = "0.1.0";

=head1 NAME

fbaModelServices

=head1 DESCRIPTION

=head1 fbaModelServices

=head2 SYNOPSIS

The FBA Model Services include support related to the reconstruction, curation,
reconciliation, and analysis of metabolic models. This includes commands to:

1.) Load genome typed objects into a workspace

2.) Build a model from a genome typed object and curate the model

3.) Analyze a model with flux balance analysis

4.) Simulate and reconcile a model to an imported set of growth phenotype data

=head2 EXAMPLE OF API USE IN PERL

To use the API, first you need to instantiate a fbaModelServices client object:

my $client = Bio::KBase::fbaModelServices::Client->new;
   
Next, you can run API commands on the client object:
   
my $objmeta = $client->genome_to_workspace({
        genome => "kb|g.0",
        workspace => "myWorkspace"
});
my $objmeta = $client->genome_to_fbamodel({
        model => "myModel"
        workspace => "myWorkspace"
});

=head2 AUTHENTICATION

Each and every function in this service takes a hash reference as
its single argument. This hash reference may contain a key
C<auth> whose value is a bearer token for the user making
the request. If this is not provided a default user "public" is assumed.

=head2 WORKSPACE

A workspace is a named collection of objects owned by a specific
user, that may be viewable or editable by other users.Functions that operate
on workspaces take a C<workspace_id>, which is an alphanumeric string that
uniquely identifies a workspace among all workspaces.

=cut

#BEGIN_HEADER
use URI;
use ModelSEED::Client::SAP;
use Bio::KBase::IDServer::Client;
use Bio::KBase::workspaceService::Client;
use Bio::KBase::CDMI::CDMIClient;
use Bio::KBase::AuthToken;
use Bio::KBase::probabilistic_annotation::Client;
use Bio::KBase::GenomeAnnotation::Client;
use Bio::KBase::ObjectAPI::KBaseStore;
use Data::UUID;
use Bio::KBase::ObjectAPI::KBaseExpression::ExpressionSample;
use Bio::KBase::ObjectAPI::KBaseFBA::ClassifierTrainingSet;
use Bio::KBase::ObjectAPI::KBaseGenomes::GenomeComparison;
use Bio::KBase::ObjectAPI::KBaseExpression::ExpressionSeries;
use Bio::KBase::ObjectAPI::KBaseRegulation::Regulome;
use Bio::KBase::ObjectAPI::KBaseRegulation::Regulon;
use Bio::KBase::ObjectAPI::KBaseRegulation::Gene;
use Bio::KBase::ObjectAPI::KBaseRegulation::RGenome;
use Bio::KBase::ObjectAPI::KBaseRegulation::RegulatedOperon;
use Bio::KBase::ObjectAPI::KBaseRegulation::TranscriptionFactor;
use Bio::KBase::ObjectAPI::ProbabilisticAnnotation::ProbAnno;
use Bio::KBase::ObjectAPI::ProbabilisticAnnotation::RxnProbs;
use Bio::KBase::ObjectAPI::KBaseBiochem::Biochemistry;
use Bio::KBase::ObjectAPI::KBaseBiochem::Media;
use Bio::KBase::ObjectAPI::KBaseOntology::Mapping;
use Bio::KBase::ObjectAPI::KBaseGenomes::Genome;
use Bio::KBase::ObjectAPI::KBaseGenomes::GenomeDomainData;
use Bio::KBase::ObjectAPI::KBaseGenomes::ContigSet;
use Bio::KBase::ObjectAPI::KBaseGenomes::ProteinSet;
use Bio::KBase::ObjectAPI::KBaseGenomes::Pangenome;
use Bio::KBase::ObjectAPI::KBaseFBA::FBAModel;
use Bio::KBase::ObjectAPI::KBaseFBA::Gapfilling;
use Bio::KBase::ObjectAPI::KBaseFBA::PromConstraint;
use Bio::KBase::ObjectAPI::KBaseFBA::Gapgeneration;
use Bio::KBase::ObjectAPI::KBaseFBA::FBA;
use Bio::KBase::ObjectAPI::KBaseFBA::ModelTemplate;
use Bio::KBase::ObjectAPI::KBaseFBA::ReactionSensitivityAnalysis;
use Bio::KBase::workspace::Client;
use Bio::KBase::ObjectAPI::KBaseGenomes::MetagenomeAnnotation;
use Bio::KBase::ObjectAPI::GenomeComparison::ProteomeComparison;
use Bio::KBase::ObjectAPI::utilities qw( args verbose set_verbose translateArrayOptions);
use POSIX;
use File::Basename;
use Try::Tiny;
use Data::Dumper;
use Config::Simple;
use Digest::MD5;
use LWP::Simple "getstore";

sub _authentication {
	my($self) = @_;
	if (defined($self->_getContext->{_override}->{_authentication})) {
		return $self->_getContext->{_override}->{_authentication};
	} elsif (defined($self->_getContext()->{token})) {
		return $self->_getContext()->{token};
	}
	return undef;
}

sub _getUsername {
	my ($self) = @_;
	if (!defined($self->_getContext->{_override}->{_currentUser})) {
		if (defined($self->{_testuser})) {
			$self->_getContext->{_override}->{_currentUser} = $self->{_testuser};
		} else {
			$self->_getContext->{_override}->{_currentUser} = "public";
		}
		
	}
	return $self->_getContext->{_override}->{_currentUser};
}

sub _cachedBiochemistry {
	my ($self,$biochemistry) = @_;
	if (defined($biochemistry)) {
		$self->{_cachedbiochemistry} = $biochemistry;
	}
	return $self->{_cachedbiochemistry};
}

sub _resetKBaseStore {
	my ($self,$params) = @_;
	if (!defined($self->_cachedBiochemistry())) {
		if (defined($self->{_kbasestore})) {
			if (defined($self->{_kbasestore}->cache()->{"kbase/default"})) {
				$self->_cachedBiochemistry($self->{_kbasestore}->cache()->{"kbase/default"});
			} elsif (defined($self->{_kbasestore}->cache()->{"489/6"})) {
				$self->_cachedBiochemistry($self->{_kbasestore}->cache()->{"489/6"});
			}
		}
	}
	delete $self->{_kbasestore};
	my @calldata = caller(2);
	my $temp = [split(/:/,$calldata[3])];
	$temp = pop(@{$temp});
	my $newparams = {};
	foreach my $param (keys(%{$params})) {
		if ($param ne "fasta" && $param ne "annotations" && $param ne "genomeobj" && $param ne "gtf_file") {
			$newparams->{$param} = $params->{$param};
		}
	}
	if (defined($self->_authentication())) {	
		$self->{_kbasestore} = Bio::KBase::ObjectAPI::KBaseStore->new({
			provenance => [{
				"time" => DateTime->now()->datetime()."+0000",
				service_ver => $VERSION,
				service => "KBaseFBAModeling",
				method => $temp,
				method_params => [$newparams],
				input_ws_objects => [],
				resolved_ws_objects => [],
				intermediate_incoming => [],
				intermediate_outgoing => []
			}],
			workspace => $self->_workspaceServices()
		});
	} else {
		$self->{_kbasestore} = Bio::KBase::ObjectAPI::KBaseStore->new({
			provenance => [{
				"time" => DateTime->now()->datetime()."+0000",
				service_ver => $VERSION,
				service => "KBaseFBAModeling",
				method => $temp,
				method_params => [$newparams],
				input_ws_objects => [],
				resolved_ws_objects => [],
				intermediate_incoming => [],
				intermediate_outgoing => []
			}],
			workspace => $self->_workspaceServices()
		});
	}
	if (defined($self->_cachedBiochemistry())) {
		$self->{_kbasestore}->cache()->{"kbase/default"} = $self->_cachedBiochemistry();
		$self->{_kbasestore}->cache()->{"489/6"} = $self->_cachedBiochemistry();
	}
}

sub _KBaseStore {
	my ($self) = @_;
	return $self->{_kbasestore};
}

sub _accountType {
	my ($self) = @_;
	if (!defined($self->{_accounttype})) {
		$self->{_accounttype} = "kbase";
	}
	return $self->{_accounttype};	
}

sub _authenticate {
	my ($self,$auth) = @_;
	if ($self->{_accounttype} eq "kbase") {
		if ($auth =~ m/^IRIS-/) {
			return {
				authentication => $auth,
				user => $auth
			};
		} else {
			my $token = Bio::KBase::AuthToken->new(
				token => $auth,
			);
			if ($token->validate()) {
				return {
					authentication => $auth,
					user => $token->user_id
				};
			} else {
				$self->_error("Invalid authorization token:".$auth,'_setContext');
			}
		}
	} elsif ($self->{_accounttype} eq "seed") {
		$auth =~ s/\s/\t/;
		my $split = [split(/\t/,$auth)];
		my $svr = $self->_mssServer();
		my $token = $svr->authenticate({
			username => $split->[0],
			password => $split->[1]
		});
		if (!defined($token) || $token =~ m/ERROR:/) {
			$self->_error($token,'_setContext');
		}
		$token =~ s/\s/\t/;
		$split = [split(/\t/,$token)];
		return {
			authentication => $token,
			user => $split->[0]
		};
	} elsif ($self->{_accounttype} eq "modelseed") {
		require "ModelSEED/utilities.pm";
		my $config = ModelSEED::utilities::config();
		my $username = $config->authenticate({
			token => $auth
		});
		return {
			authentication => $auth,
			user => $username
		};
	} elsif ($self->{_accounttype} eq "simple") {
		if ($auth !~ m/^[a-zA-Z0-9_]*$/) {
			$self->_error("Simple accounts must be alphanumeric!",'_setContext');
		}
		return {
			authentication => $auth,
			user => $auth
		};
	}
}

sub _setContext {
	my ($self,$context,$params,$objects,$essential,$optional) = @_;
	if (defined($params->{wsurl})) {
		$self->_getContext()->{_override}->{_wsurl} = $params->{wsurl};
	}
	if (defined($params->{probanno_url})) {
		$self->_getContext()->{_override}->{_probanno_url} = $params->{probanno_url};
	}
    if (defined($params->{auth}) && length($params->{auth}) > 0) {
		if (!defined($self->_getContext()->{_override}) || $self->_getContext()->{_override}->{_authentication} ne $params->{auth}) {
			my $output = $self->_authenticate($params->{auth});
			$self->_getContext()->{_override}->{_authentication} = $output->{authentication};
			$self->_getContext()->{_override}->{_currentUser} = $output->{user};
		}
    }
    delete $self->{_workspaceServices};
	$self->_resetKBaseStore($params);
	if (defined($objects)) {
		$params = $self->_validateargs($params,$essential,$optional);
		foreach my $object (keys(%{$objects})) {
			my ($lastobj,$obj,$lastkey) = $self->_string_to_object($object,$params);
			if (defined($obj)) {
				my $typearray = [split(/\./,$objects->{$object}->{type})];
				if (ref($obj) eq 'HASH') {
					$lastobj->{$lastkey} = $self->_get_msobject($typearray->[-1],undef,$obj);
				} else {
					my ($lastws,$ws,$lastwskey) = $self->_string_to_object($objects->{$object}->{ws},$params);
					$lastobj->{$lastkey} = $self->_get_msobject($typearray->[-1],$ws,$obj);
				}
			}
		}
	}
	return $params;
}

sub _string_to_object {
	my ($self,$string,$objects) = @_;
	my $array = [split(/:/,$string)];
	my $obj = $objects->{$array->[0]};
	my $lastobj = $objects;
	for (my $i=1; $i < @{$array}; $i++) {
		$lastobj = $obj;
		$obj = $obj->{$array->[$i]};
	}
	return ($lastobj,$obj,$array->[-1]);
}

sub _getContext {
	my ($self) = @_;
	if (!defined($Bio::KBase::fbaModelServices::Server::CallContext)) {
		$Bio::KBase::fbaModelServices::Server::CallContext = {};
	}
	return $Bio::KBase::fbaModelServices::Server::CallContext;
}

sub _clearContext {
	my ($self) = @_;
}

sub _modify_annotation_from_probanno {
	my ($self,$input) = @_;
    $input = $self->_validateargs($input,["probanno","annotation"],{
		threshold => 0,
		probannoonly => 0,
	});
    my $probanno = $input->{probanno};
    my $annotation = $input->{annotation};
    my $mapping = $annotation->mapping();
    if (defined($probanno->{featureAlternativeFunctions})) {
		if ($input->{probannoonly} == 1) {
			my $ftrs = $annotation->features();
			for (my $i=0; $i < @{$ftrs}; $i++) {
				my $ftr = $ftrs->[$i];
				my $roles = $ftr->featureroles();
				for (my $j=0; $j < @{$roles}; $j++) {
					$ftr->remove($roles->[$j]);
				}
			}	
		}
		for (my $i=0; $i < @{$probanno->{featureAlternativeFunctions}}; $i++) {
			my $feature = $probanno->{featureAlternativeFunctions}->[$i];
			my $ftrObj = $annotation->query_object("features",{id => $feature->{id}});
			if (defined($ftrObj) && defined($feature->{alternative_functions})) {
				for (my $j=0; $j < @{$feature->{alternative_functions}}; $j++) {
					my $anno = $feature->{alternative_functions}->[$j];
					if ($anno->[1] >= $input->{threshold}) {
						my $role = $mapping->queryObject( "roles",{
							name => $anno->[0]
						});
						if ( !defined($role) ) {
							$role = $mapping->add( "roles",{
								name => $anno->[0]
							});
						}
						my $roles = $feature->featureroles();
						my $found = 0;
						for (my $k=0; $k < @{$roles}; $k++) {
							if ($roles->[$k]->role()->uuid() eq $role->uuid()) {
								$found = 1;
							}
						}
						if ($found == 0) {
							$ftrObj->add("featureroles",{
								 role_uuid   => $role->uuid(),
								 compartment => "u",
								 delimiter   => ";",
								 comment     => "Added from probabilistic annotation with probability ".$anno->[1]
							});
						}
					} 
				}
			}
		}
	}
    return ($annotation,$mapping);
}

sub _cdmi {
	my $self = shift;
	if (!defined($self->{_cdmi})) {
		$self->{_cdmi} = Bio::KBase::CDMI::CDMIClient->new_for_script();
	}
    return $self->{_cdmi};
}

sub _mssServer {
	my $self = shift;
	if (!defined($self->{_mssServer})) {
		require "Bio/ModelSEED/MSSeedSupportServer/Client.pm";
		$self->{_mssServer} = Bio::ModelSEED::MSSeedSupportServer::Client->new($self->{'_mssserver-url'});
	}
    return $self->{_mssServer};
}

sub _idServer {
	my $self = shift;
    return Bio::KBase::ObjectAPI::utilities::idServer();
}

sub _gaserv {
	my $self = shift;
    if (!defined($self->{_gaserver})) {
    	if ($self->{'_gaserver-url'} eq "impl") {
			require "Bio/KBase/GenomeAnnotation/GenomeAnnotationImpl.pm";
			$self->{_gaserver} = Bio::KBase::GenomeAnnotation::GenomeAnnotationImpl->new();
		} else {
			$self->{_gaserver} = Bio::KBase::GenomeAnnotation::Client->new($self->{'_gaserver-url'});
		}
    }
    return $self->{_gaserver};
}

sub _jobserv {
	my $self = shift;
    return $self->{_jobserver};
}

sub _jobqueue {
	my $self = shift;
    return $self->{_jobqueue};
}

sub _workspaceServices {
	my $self = shift;
	if (defined($self->{_workspaceServiceOveride})) {
		return $self->{_workspaceServiceOveride};
	}
	if (!defined($self->{_workspaceServices}->{$self->_workspaceURL()})) {
		my $url = $self->_workspaceURL();
		$url =~ s/https/http/;
		$self->{_workspaceServices}->{$self->_workspaceURL()} = Bio::KBase::workspace::Client->new($url);
		$self->{_workspaceServices}->{$self->_workspaceURL()}->{token} = $self->_authentication();
		$self->{_workspaceServices}->{$self->_workspaceURL()}->{client}->{token} = $self->_authentication();
	}
    return $self->{_workspaceServices}->{$self->_workspaceURL()};
}

sub _workspace_list {
	my $self = shift;
	if (!defined($self->_getContext()->{_workspace_list})) {
		$self->_getContext()->{_workspace_list} = $self->_workspaceServices()->list_workspace_info({});
	}
	return $self->_getContext()->{_workspace_list};
}

sub _workspaceURL {
	my $self = shift;
	if (defined($self->_getContext()->{_override}->{_wsurl})) {
		return $self->_getContext()->{_override}->{_wsurl};
	}
	return $self->{"_workspace-url"};
}

sub _shockurl {
	my $self = shift;
	if (defined($self->_getContext()->{_override}->{_shockurl})) {
		return $self->_getContext()->{_override}->{_shockurl};
	}
	return $self->{_shockurl};
}

sub _aweurl {
	my $self = shift;
	if (defined($self->_getContext()->{_override}->{_aweurl})) {
		return $self->_getContext()->{_override}->{_aweurl};
	}
	return $self->{_aweurl};
}

sub _probanno {
	my $self = shift;
	my $url = $self->{"_probanno-url"};
	if (defined($self->_getContext()->{_override}->{_probanno_url})) {
		$url = $self->_getContext()->{_override}->{_probanno_url};
	}
	if (!defined($self->{_probannoServices}->{$url})) {
		$self->{_probannoServices}->{$url} = Bio::KBase::probabilistic_annotation::Client->new($url);
	}
	return $self->{_probannoServices}->{$url};
}

sub _myURL {
	my $self = shift;
	return $self->{"_fba-url"};
}

sub _save_msobject {
	my($self,$obj,$type,$ws,$id,$params) = @_;
	my $data;
	if (ref($obj) =~ m/Bio::KBase::ObjectAPI::/) {
		return $self->_KBaseStore()->save_object($obj,$ws."/".$id,$params);
	} else {
		$data = $obj;
		my $input = {
			objects => [{
				data => $data,
				type => "Unspecified",
				provenance => $self->_KBaseStore()->provenance()
			}],
		};
		if ($ws  =~ m/^\d+$/) {
    		$input->{id} = $ws;
    	} else {
    		$input->{workspace} = $ws;
    	}
		if ($id =~ m/^\d+$/) {
			$input->{objects}->[0]->{objid} = $id;
		} else {
			$input->{objects}->[0]->{name} = $id;
		}
		my $listout = $self->_KBaseStore()->workspace()->save_objects($input);
    	return $listout->[0];
	}
}

sub _get_msobject {
	my($self,$type,$ws,$id,$options) = @_;
	my $obj;
	if (ref($id) eq 'HASH') {
		$obj = $self->_KBaseStore()->get_object_by_handle($id,$options);
		if ($obj->_class() ne $type) {
			$self->_error($obj->_class()." input, but should be ".$type);
		}
	} elsif (defined($ws)) {
		my $ref = $ws."/".$id;
		if ($ws eq "kbase" && $id eq "default" && $type eq "Mapping") {
			$id = "default-mapping";
		}
		$obj = $self->_KBaseStore()->get_object($ref,$options);
		if ($obj->_class() ne $type) {
			$self->_error($obj->_class()." input, but should be ".$type);
		}
		if (!defined($self->_cachedBiochemistry()) && $type eq "Biochemistry" && $id eq "default" && $ws eq "kbase") {
			$self->_cachedBiochemistry($obj);
		}
	}
	return $obj;
}

sub _get_CDD_data_from_CDM {
	my($self,$genome,$reference) = @_;
	my $cdm = $self->_cdmi();
	print "Getting genome data\n";
	my $data = $cdm->genomes_to_genome_data([$genome]);
	print "Getting fids\n";
	my $genomeFtrs = $cdm->genomes_to_fids([$genome],[]);
	print "Getting proteins\n";
	my $output = $cdm->get_relationship_Produces(
		$genomeFtrs->{$genome},
		["function","source_id","sequence_length"],
		[],
		["id"]
	);
	print "Done\n";
	my $object = {
		id => $genome.".dom.0",
		genome_id => $genome,
		scientific_name => $data->{$genome}->{scientific_name},
		num_domains => 0,
		num_features => 0,
		domains => [],
		featuredomains => []
	};
	if (defined($reference)) {
		$object->{genome_ref} = $reference;
	}
	my $geneList = [];
	my $geneHash = {};
	my $proteinHash = {};
	for (my $j=0; $j < @{$output};$j++) {
		$geneHash->{$output->[$j]->[1]->{from_link}} = {
			id => $genome.".dom.0".".fdoms.".$j,
			feature_id => $output->[$j]->[0]->{"source_id"},
			function => $output->[$j]->[0]->{function},
			feature_length => $output->[$j]->[0]->{"sequence_length"},
			domains => []
		};
		if (defined($reference)) {
			$geneHash->{$output->[$j]->[1]->{from_link}}->{feature_ref} = $reference."/features/id/".$output->[$j]->[1]->{from_link};
		}
		$object->{num_features}++;
		push(@{$object->{featuredomains}},$geneHash->{$output->[$j]->[1]->{from_link}});
		$proteinHash->{$output->[$j]->[2]->{id}}->{$output->[$j]->[1]->{from_link}} = 1;
	}
	my $proteinList = [keys(%{$proteinHash})];
	print "Getting genome cdds\n";
	my $cdds = $cdm->get_relationship_HasConservedDomainModel(
		$proteinList,
		[],
		["mismatches","gap_openings","percent_identity","alignment_length","protein_start","protein_end","domain_start","domain_end","e_value"],
		["id","short_name"]
	);
	print "Done\n";
	my $cddhash = {};
	for (my $j=0; $j < @{$cdds};$j++) {
		my $cdd = $cdds->[$j];
		my $protein = $cdd->[1]->{from_link};
		foreach my $gene (keys(%{$proteinHash->{$protein}})) {
			$cddhash->{$cdd->[2]->{id}} = 1;
			push(@{$geneHash->{$gene}->{domains}},[
				"~/domains/id/".$cdd->[2]->{id},
				$cdd->[1]->{percent_identity},
				$cdd->[1]->{alignment_length},
				$cdd->[1]->{mismatches},
				$cdd->[1]->{gap_openings},
				$cdd->[1]->{protein_start},
				$cdd->[1]->{protein_end},
				$cdd->[1]->{domain_start},
				$cdd->[1]->{domain_end},
				$cdd->[1]->{e_value},
				$cdd->[1]->{bit_score}
			]);
		}
	}
	my $cddlist = [keys(%{$cddhash})];
	print "Getting CDDs\n";
	$cdds = $cdm->get_entity_ConservedDomainModel(
		$cddlist,
		["accession","short_name","description"]
	);
	print "Done\n";
	foreach my $cdd (keys(%{$cdds})) {
		my $type = "Unknown";
		if ($cdds->{$cdd}->{accession} =~ m/([a-zA-Z]+)(\d+)/) {
			$type = $1;
		}
		push(@{$object->{domains}},{
			id => $cdd,
			source_id => $cdds->{$cdd}->{accession},
			type => $type,
			name => $cdds->{$cdd}->{short_name},
			description => $cdds->{$cdd}->{description}
		});
	}
	$object = Bio::KBase::ObjectAPI::KBaseGenomes::GenomeDomainData->new($object);
	return $object;
}

sub _get_genomeObj_from_CDM {
	my($self,$id,$asNew) = @_;
	my $cdmi = $self->_cdmi();
    my $data = $cdmi->genomes_to_genome_data([$id]);
    if (!defined($data->{$id})) {
    	$self->_error("Genome ".$id." not found!",'get_genomeobject');
    }
    my $genomeObj = {
		id => $id,
		scientific_name => $data->{$id}->{scientific_name},
		domain => "Bacteria",
		genetic_code => $data->{$id}->{genetic_code},
		dna_size => $data->{$id}->{dna_size},
		num_contigs => $data->{$id}->{contigs},
		contig_lengths => [],
		contig_ids => [],
		source => "KBase",
		source_id => $id,
		md5 => $data->{$id}->{genome_md5},
		taxonomy => $data->{$id}->{taxonomy},
		gc_content => $data->{$id}->{gc_content},
		complete => $data->{$id}->{complete},
		publications => [],
		features => [],
    };
    $data = $self->_cdmi()->get_relationship_IsComposedOf([$id],["domain","source_id"], [], ["id"]);
    if (defined($data->[0])) {
    	if (defined($data->[0]->[0]->{domain})) {
    		$genomeObj->{domain} = $data->[0]->[0]->{domain};
    	}
    	if (defined($data->[0]->[0]->{source_id})) {
    		$genomeObj->{source_id} = $data->[0]->[0]->{source_id};
    	}
    }
    $data = $cdmi->genomes_to_contigs([$id]);
    my $contigset = {
    	id => $self->_register_kb_id("kb|contigset",$genomeObj->{md5},"md5hash"),
		name => $genomeObj->{scientific_name},
		md5 => $genomeObj->{md5},
		source_id => $genomeObj->{source_id},
		source => $genomeObj->{source},
		type => "Organism",
		contigs => []
    };
    for (my $i=0; $i < @{$data->{$id}}; $i++) {
    	my $seqData = $cdmi->contigs_to_sequences([$data->{$id}->[$i]]);
    	push(@{$contigset->{contigs}},{
    		id => $data->{$id}->[$i],
			"length" => length($seqData->{$data->{$id}->[$i]}),
			md5 => Digest::MD5::md5_hex($seqData->{$data->{$id}->[$i]}),
			sequence => $seqData->{$data->{$id}->[$i]},
			name => $data->{$id}->[$i]
    	});
   	}
    my $ContigObj = Bio::KBase::ObjectAPI::KBaseGenomes::ContigSet->new($contigset);
    my $genomeFtrs = $cdmi->genomes_to_fids([$id],[]);
	my $features = $genomeFtrs->{$id};
  	my $fidAnnotationHash = $cdmi->fids_to_annotations($features);
  	my $fidProteinSequences = $cdmi->fids_to_protein_sequences($features);
  	my $fidDataHash = $cdmi->fids_to_feature_data($features);
  	for (my $i=0; $i < @{$features};$i++) {
  		my $ftr = $features->[$i];
  		my $ftrdata = $fidDataHash->{$ftr};
  		my $feature = {
  			id => $ftr,
			location => $ftrdata->{feature_location},
			function => $ftrdata->{feature_function},
			publications => [],
			subsystems => [],
			protein_families => [],
			aliases => [],
			annotations => [],
			subsystem_data => [],
			regulon_data => [],
			atomic_regulons => [],
			coexpressed_fids => [],
			co_occurring_fids => []
  		};
  		for (my $j=0; $j < @{$ftrdata->{feature_location}}; $j++) {
  			$feature->{location}->[$j]->[1] = $feature->{location}->[$j]->[1]+0;
			$feature->{location}->[$j]->[3] = $feature->{location}->[$j]->[3]+0;
  		}
  		if (defined($fidAnnotationHash->{$ftr})) {
  			$feature->{annotations} = $fidAnnotationHash->{$ftr};
  			for (my $j=0; $j < @{$feature->{annotations}}; $j++) {
  				$feature->{annotations}->[$j]->[2] = $feature->{annotations}->[$j]->[2]+0;
  			}
  		}	
  		if (defined($fidProteinSequences->{$ftr})) {
  			$feature->{protein_translation} = $fidProteinSequences->{$ftr};
  			$feature->{protein_translation_length} = length($feature->{protein_translation});
  			$feature->{dna_sequence_length} = 3*$feature->{protein_translation_length};
  			$feature->{md5} = Digest::MD5::md5_hex($feature->{protein_translation});
  		}	
  		if ($ftr =~ m/(\w+)\.\d+$/) {
			$feature->{type} = $1;
		}	
  		push(@{$genomeObj->{features}},$feature);
  	}
  	if (!defined($genomeObj->{md5})) {
    	$genomeObj->{md5} = "";
    }
    $genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new($genomeObj);
	return [$genomeObj,$ContigObj];
}

sub _get_genomeObj_from_SEED {
	my($self,$id) = @_;
	my $sapsvr = ModelSEED::Client::SAP->new();
	my $data = $sapsvr->genome_data({
		-ids => [$id],
		-data => [qw(gc-content dna-size name taxonomy domain genetic-code)]
	});
	if (!defined($data->{$id})) {
    	$self->_error("PubSEED genome ".$id." not found!",'get_genomeobject');
    }
    my $genomeObj = {
		id => $self->_register_kb_id("kb|g",$id,"SEED"),
		scientific_name => $data->{$id}->[2],
		domain => $data->{$id}->[4],
		genetic_code => $data->{$id}->[5],
		dna_size => $data->{$id}->[1],
		num_contigs => 0,
		contig_lengths => [],
		contig_ids => [],
		source => "PubSEED",
		source_id => $id,
		taxonomy => $data->{$id}->[3],
		gc_content => $data->{$id}->[0]/100,
		complete => 1,
		publications => [],
		features => [],
    };
    my $contigset = {
		name => $genomeObj->{scientific_name},
		source_id => $genomeObj->{source_id},
		source => $genomeObj->{source},
		type => "Organism",
		contigs => []
    };
	my $featureHash = $sapsvr->all_features({-ids => $id});
	my $genomeHash = $sapsvr->genome_contigs({
		-ids => [$id]
	});
	my $featureList = $featureHash->{$id};
	my $contigList = $genomeHash->{$id};
	my $functions = $sapsvr->ids_to_functions({-ids => $featureList});
	my $locations = $sapsvr->fid_locations({-ids => $featureList});
	my $sequences = $sapsvr->fids_to_proteins({-ids => $featureList,-sequence => 1});
	my $contigHash = $sapsvr->contig_sequences({
		-ids => $contigList
	});
	foreach my $key (keys(%{$contigHash})) {
		$genomeObj->{num_contigs}++;
		push(@{$genomeObj->{contig_ids}},$key);
		push(@{$genomeObj->{contig_lengths}},length($contigHash->{$key}));
		push(@{$contigset->{contigs}},{
			id => $key,
			"length" => length($contigHash->{$key}),
			md5 => Digest::MD5::md5_hex($contigHash->{$key}),
			sequence => $contigHash->{$key},
			name => $key
		});
	}
	my $sortedcontigs = [sort { $a->{sequence} cmp $b->{sequence} } @{$contigset->{contigs}}];
	my $str = "";
	for (my $i=0; $i < @{$sortedcontigs}; $i++) {
		if (length($str) > 0) {
			$str .= ";";
		}
		$str .= $sortedcontigs->[$i]->{sequence};	
	}
	$genomeObj->{md5} = Digest::MD5::md5_hex($str);
	$contigset->{md5} = $genomeObj->{md5};
	$contigset->{id} = $self->_register_kb_id("kb|contigset",$contigset->{md5},"md5hash");
	for (my $i=0; $i < @{$featureList}; $i++) {
		my $feature = {
  			id => $featureList->[$i],
			type => "peg",
			publications => [],
			subsystems => [],
			protein_families => [],
			aliases => [],
			annotations => [],
			subsystem_data => [],
			regulon_data => [],
			atomic_regulons => [],
			coexpressed_fids => [],
			co_occurring_fids => []
  		};
  		if ($featureList->[$i] =~ m/\.([^\.]+)\.\d+$/) {
  			$feature->{type} = $1;
  		}
		if (defined($functions->{$featureList->[$i]})) {
			$feature->{function} = $functions->{$featureList->[$i]};
		}
		if (defined($sequences->{$featureList->[$i]})) {
			$feature->{protein_translation} = $sequences->{$featureList->[$i]};
			$feature->{protein_translation_length} = length($feature->{protein_translation});
  			$feature->{dna_sequence_length} = 3*$feature->{protein_translation_length};
  			$feature->{md5} = Digest::MD5::md5_hex($feature->{protein_translation});
		}
  		if (defined($locations->{$featureList->[$i]}->[0])) {
			for (my $j=0; $j < @{$locations->{$featureList->[$i]}}; $j++) {
				my $loc = $locations->{$featureList->[$i]}->[$j];
				if ($loc =~ m/^(.+)_(\d+)([\+\-])(\d+)$/) {
					my $array = [split(/:/,$1)];
					if ($3 eq "-" || $3 eq "+") {
						$feature->{location}->[$j] = [$array->[1],$2,$3,$4];
					} elsif ($2 > $4) {
						$feature->{location}->[$j] = [$array->[1],$2,"-",($2-$4)];
					} else {
						$feature->{location}->[$j] = [$array->[1],$2,"+",($4-$2)];
					}
					$feature->{location}->[$j]->[1] = $feature->{location}->[$j]->[1]+0;
					$feature->{location}->[$j]->[3] = $feature->{location}->[$j]->[3]+0;
				}
			}
			
		}
  		push(@{$genomeObj->{features}},$feature);	
	}
	my $ContigObj = Bio::KBase::ObjectAPI::KBaseGenomes::ContigSet->new($contigset);
	$genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new($genomeObj);
	return [$genomeObj,$ContigObj];
}

sub _get_genomeObj_from_RAST {
	my($self,$id,$username,$password) = @_;
	my $mssvr = $self->_mssServer();
	my $data = $mssvr->getRastGenomeData({
		genome => $id,
		username => $username,
		password => $password,
		getSequences => 1,
		getDNASequence => 1
	});
    if (!defined($data->{owner})) {
    	$self->_error("RAST genome ".$id." not found!",'get_genomeobject');
    }
	my $genomeObj = {
		id => $self->_register_kb_id("kb|g",$id,"RAST"),
		scientific_name => $data->{name},
		domain => $data->{taxonomy},
		genetic_code => 11,
		dna_size => $data->{size},
		num_contigs => 0,
		contig_lengths => [],
		contig_ids => [],
		source => "RAST",
		source_id => $id,
		taxonomy => $data->{taxonomy},
		gc_content => 0.5,
		complete => 1,
		publications => [],
		features => [],
    };
    my $contigset = {
		name => $genomeObj->{scientific_name},
		source_id => $genomeObj->{source_id},
		source => $genomeObj->{source},
		type => "Organism",
		contigs => []
    };
    my $contighash = {};
	for (my $i=0; $i < @{$data->{features}}; $i++) {
		my $ftr = $data->{features}->[$i];
		my $feature = {
  			id => $ftr->{ID}->[0],
			type => "peg",
			publications => [],
			subsystems => [],
			protein_families => [],
			aliases => [],
			annotations => [],
			subsystem_data => [],
			regulon_data => [],
			atomic_regulons => [],
			coexpressed_fids => [],
			co_occurring_fids => [],
			protein_translation_length => 0,
			protein_translation => "",
			dna_sequence_length => 0,
			md5 => ""
  		};
  		if ($ftr->{ID}->[0] =~ m/\.([^\.]+)\.\d+$/) {
  			$feature->{type} = $1;
  		}
  		if (defined($ftr->{SEQUENCE})) {
			$feature->{protein_translation} = $ftr->{SEQUENCE}->[0];
			$feature->{protein_translation_length} = length($feature->{protein_translation});
  			$feature->{dna_sequence_length} = 3*$feature->{protein_translation_length};
  			$feature->{md5} = Digest::MD5::md5_hex($feature->{protein_translation});
		}
		if (defined($ftr->{ROLES})) {
			$feature->{function} = join(" / ",@{$ftr->{ROLES}});
		}
  		if (defined($ftr->{LOCATION}->[0]) && $ftr->{LOCATION}->[0] =~ m/^(.+)_(\d+)([\+\-_])(\d+)$/) {
			my $contigData = $1;
			if (!defined($contighash->{$contigData})) {
				$contighash->{$contigData} = $2;
			} elsif ($2 > $contighash->{$contigData}) {
				$contighash->{$contigData} = $2;
			}
			if ($3 eq "-" || $3 eq "+") {
				$feature->{location} = [[$contigData,$2,$3,$4]];
			} elsif ($2 > $4) {
				$feature->{location} = [[$contigData,$2,"-",($2-$4)]];
			} else {
				$feature->{location} = [[$contigData,$2,"+",($4-$2)]];
			}
			$feature->{location}->[0]->[1] = $feature->{location}->[0]->[1]+0;
			$feature->{location}->[0]->[3] = $feature->{location}->[0]->[3]+0;
		}
  		push(@{$genomeObj->{features}},$feature);
	}
	my $ContigObj;
	if (defined($data->{DNAsequence}->[0])) {
    	my $gccount = 0;
    	my $size = 0;
    	for (my $i=0; $i < @{$data->{DNAsequence}}; $i++) {
    		my $closest;
    		foreach my $key (keys(%{$contighash})) {
    			my $dist = abs(length($data->{DNAsequence}->[$i]) - $contighash->{$key});
    			my $closestdist = abs(length($data->{DNAsequence}->[$i]) - $contighash->{$closest});
    			if (!defined($closest) || $dist < $closestdist) {
    				$closest = $key;
    			}
    		}
    		push(@{$contigset->{contigs}},{
    			id => $closest,
				"length" => length($data->{DNAsequence}->[$i]),
				md5 => Digest::MD5::md5_hex($data->{DNAsequence}->[$i]),
				sequence => $data->{DNAsequence}->[$i],
				name => $closest
    		});
    		push(@{$genomeObj->{contig_lengths}},length($data->{DNAsequence}->[$i]));
    		$size += length($data->{DNAsequence}->[$i]);
    		push(@{$genomeObj->{contig_ids}},$closest);
			for ( my $j = 0 ; $j < length($data->{DNAsequence}->[$i]) ; $j++ ) {
				if ( substr( $data->{DNAsequence}->[$i], $j, 1 ) =~ m/[gcGC]/ ) {
					$gccount++;
				}
			}
    	}
    	if ($size > 0) {
			$genomeObj->{gc_content} = $$gccount/$size;
		}
		my $sortedcontigs = [sort { $a->{sequence} cmp $b->{sequence} } @{$contigset->{contigs}}];
		my $str = "";
		for (my $i=0; $i < @{$sortedcontigs}; $i++) {
			if (length($str) > 0) {
				$str .= ";";
			}
			$str .= $sortedcontigs->[$i]->{sequence};	
		}
		$genomeObj->{md5} = Digest::MD5::md5_hex($str);
		$contigset->{md5} = $genomeObj->{md5};
		$contigset->{id} = $self->_register_kb_id("kb|contigset",$contigset->{md5},"md5hash");
    	$ContigObj = Bio::KBase::ObjectAPI::KBaseGenomes::ContigSet->new($contigset);
	}
	$genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new($genomeObj);
	return [$genomeObj,$ContigObj];
}

sub _validateargs {
	my ($self,$args,$mandatoryArguments,$optionalArguments,$substitutions) = @_;
	if (!defined($args)) {
	    $args = {};
	}
	if (ref($args) ne "HASH") {
		$self->_error("Arguments not hash",'_validateargs');
	}
	if (defined($substitutions) && ref($substitutions) eq "HASH") {
		foreach my $original (keys(%{$substitutions})) {
			$args->{$original} = $args->{$substitutions->{$original}};
		}
	}
	if (defined($mandatoryArguments)) {
		for (my $i=0; $i < @{$mandatoryArguments}; $i++) {
			if (!defined($args->{$mandatoryArguments->[$i]})) {
				push(@{$args->{_error}},$mandatoryArguments->[$i]);
			}
		}
	}
	if (defined($args->{_error})) {
		$self->_error("Mandatory arguments ".join("; ",@{$args->{_error}})." missing.",'_validateargs');
	}
	if (defined($optionalArguments)) {
		foreach my $argument (keys(%{$optionalArguments})) {
			if (!defined($args->{$argument})) {
				$args->{$argument} = $optionalArguments->{$argument};
				
			}
		}
	}
	my $wshash = {};
	foreach my $argument (keys(%{$args})) {
		if (defined($args->{$argument}) && length($args->{$argument}) > 0) {
			if ($argument =~ m/_ws$/ || $argument =~ m/workspace$/) {
				$wshash->{$args->{$argument}} = 0;
			} elsif ($argument =~ m/workspaces/) {
				foreach my $ws (@{$args->{$argument}}) {
					$wshash->{$ws} = 0;
				}
			}
		}
	}
	if (keys(%{$wshash}) > 0) {
		my $output = $self->_workspace_list();
		foreach my $item (@{$output}) {
			if (defined($wshash->{$item->[0]})) {
				$wshash->{$item->[0]} = 1;
			} elsif (defined($wshash->{$item->[1]})) {
				$wshash->{$item->[1]} = 1;
			}
		}
		foreach my $ws (keys(%{$wshash})) {
			if ($wshash->{$ws} == 0) {
				#$self->_error("Job specifies a workspace that does not exist or that user (".$self->_getUsername().") has no access to:".$ws);
			}
		}
	}
	return $args;
}

sub _setDefaultFBAFormulation {
	my ($self,$fbaFormulation) = @_;
	if (!defined($fbaFormulation)) {
		$fbaFormulation = {};
	}
	$fbaFormulation = $self->_validateargs($fbaFormulation,[],{
		media => "Complete",
		media_workspace => "KBaseMedia",
		objfraction => 0.1,
		allreversible => 0,
		maximizeObjective => 1,
		objectiveTerms => [
			[1,"biomassflux","bio1"]
		],
		additionalcpds => [],
		geneko => [],
		rxnko => [],
		bounds => [],
		constraints => [],
		uptakelim => {},
		defaultmaxflux => 100,
		defaultminuptake => -100,
		defaultmaxuptake => 0,
		simplethermoconst => 0,
		thermoconst => 0,
		nothermoerror => 0,
		minthermoerror => 0,
		promconstraint => undef,
		prommconstraint_workspace => undef,
		eflux_sample => undef,
		eflux_series => undef,
		eflux_workspace => undef,
		regmodel => undef,
		regmodel_workspace => undef
	});
	return $fbaFormulation;
}

sub _buildFBAObject {
	my ($self,$fbaFormulation,$model) = @_;
	#Parsing media
	my $mediaobj = $self->_get_msobject("Media",$fbaFormulation->{media_workspace},$fbaFormulation->{media});
	#Building FBAFormulation object
	my $fbaobj = Bio::KBase::ObjectAPI::KBaseFBA::FBA->new({
		id => $self->_get_new_id($model->id().".fba."),
		fva => 0,
		fluxMinimization => 0,
		findMinimalMedia => 0,
		allReversible => $fbaFormulation->{allreversible},
		simpleThermoConstraints => $fbaFormulation->{simplethermoconst},
		thermodynamicConstraints => $fbaFormulation->{thermoconst},
		noErrorThermodynamicConstraints => $fbaFormulation->{nothermoerror},
		minimizeErrorThermodynamicConstraints => $fbaFormulation->{minthermoerror},
		maximizeObjective => $fbaFormulation->{maximizeObjective},
		compoundflux_objterms => {},
    	reactionflux_objterms => {},
		biomassflux_objterms => {},
		comboDeletions => 0,
		numberOfSolutions => 1,
		objectiveConstraintFraction => $fbaFormulation->{objfraction},
		defaultMaxFlux => $fbaFormulation->{defaultmaxflux},
		defaultMaxDrainFlux => $fbaFormulation->{defaultmaxuptake},
		defaultMinDrainFlux => $fbaFormulation->{defaultminuptake},
		decomposeReversibleFlux => 0,
		decomposeReversibleDrainFlux => 0,
		fluxUseVariables => 0,
		drainfluxUseVariables => 0,
		fbamodel_ref => $model->_reference(),
		media_ref => $mediaobj->_reference(),
		geneKO_refs => [],
		reactionKO_refs => [],
		additionalCpd_refs => [],
		uptakeLimits => {},
		parameters => {},
		inputfiles => {},
		FBAConstraints => [],
		FBAReactionBounds => [],
		FBACompoundBounds => [],
		outputfiles => {},
		FBACompoundVariables => [],
		FBAReactionVariables => [],
		FBABiomassVariables => [],
		FBAPromResults => [],
		FBADeletionResults => [],
		FBAMinimalMediaResults => [],
		FBAMetaboliteProductionResults => [],
	});
	$fbaobj->parent($self->_KBaseStore());
	if (defined($fbaFormulation->{promconstraint}) && defined($fbaFormulation->{promconstraint_workspace})) {
		my $promobj = $self->_get_msobject("PromConstraint",$fbaFormulation->{promconstraint_workspace},$fbaFormulation->{promconstraint});
		if (defined($promobj)) {
			$fbaobj->promconstraint_ref($promobj->_reference)
		}
		$fbaobj->PROMKappa(1);
	}
	if (defined($fbaFormulation->{regmodel}) && defined($fbaFormulation->{regmodel_workspace})) {
		my $regmodel = $self->_get_msobject("RegulatoryModel",$fbaFormulation->{regmodel_workspace},$fbaFormulation->{regmodel});
		if (defined($regmodel)) {
			$fbaobj->regmodel_ref($regmodel->_reference)
		}
	}
	if (defined($fbaFormulation->{tintle_sample}) && defined($fbaFormulation->{tintle_workspace})) {
	    my $sample = $self->_get_msobject("ExpressionSample", $fbaFormulation->{tintle_workspace}, $fbaFormulation->{tintle_sample});
	    $fbaobj->tintlesample_ref($sample->_reference);
	    $fbaobj->tintleW($fbaFormulation->{tintle_w});
	    $fbaobj->tintleKappa($fbaFormulation->{tintle_kappa});
	}
	#Parse objective equation
	foreach my $term (@{$fbaFormulation->{objectiveTerms}}) {
		if ($term->[1] eq "flux" || $term->[1] eq "reactionflux") {
			$term->[1] = "flux";
			my $obj = $model->searchForReaction($term->[2]);
			if (!defined($obj)) {
				$self->_error("Reaction ".$term->[2]." not found!");
			}
			$fbaobj->reactionflux_objterms()->{$obj->id()} = $term->[0];
		} elsif ($term->[1] eq "compoundflux" || $term->[1] eq "drainflux") {
			$term->[1] = "drainflux";
			my $obj = $model->searchForCompound($term->[2]);
			if (!defined($obj)) {
				$self->_error("Compound ".$term->[2]." not found!");
			}
			$fbaobj->compoundflux_objterms()->{$obj->id()} = $term->[0];
		} elsif ($term->[1] eq "biomassflux") {
			my $obj = $model->searchForBiomass($term->[2]);
			if (!defined($obj)) {
				$self->_error("Biomass ".$term->[2]." not found!");
			}
			$fbaobj->biomassflux_objterms()->{$obj->id()} = $term->[0];
		} else {
			$self->_error("Objective variable type ".$term->[1]." not recognized!");
		}
	}
	#Parse constraints
	foreach my $constraint (@{$fbaFormulation->{constraints}}) {
		my $const = $fbaobj->add("FBAConstraints",{
			name => $constraint->[3],
			rhs => $constraint->[0],
			sign => $constraint->[1],
			compound_terms => {},
			reaction_terms => {},
			biomass_terms => {}
		});
		foreach my $term (@{$constraint->[2]}) {
			if ($term->[1] eq "flux" || $term->[1] eq "reactionflux") {
				$term->[1] = "flux";
				my $obj = $model->searchForReaction($term->[2]);
				if (!defined($obj)) {
					$self->_error("Reaction ".$term->[2]." not found!");
				}
				$const->reaction_terms()->{$obj->id()} = $term->[0];
			} elsif ($term->[1] eq "compoundflux" || $term->[1] eq "drainflux") {
				$term->[1] = "drainflux";
				my $obj = $model->searchForCompound($term->[2]);
				if (!defined($obj)) {
					$self->_error("Compound ".$term->[2]." not found!");
				}
				$const->compound_terms()->{$obj->id()} = $term->[0];
			} elsif ($term->[1] eq "biomassflux") {
				my $obj = $model->searchForBiomass($term->[2]);
				if (!defined($obj)) {
					$self->_error("Biomass ".$term->[2]." not found!");
				}
				$const->biomass_terms()->{$obj->id()} = $term->[0];
			} else {
				$self->_error("Constraint variable type ".$term->[1]." not recognized!");
			}
		}
	}
	#Parse bounds
	foreach my $term (@{$fbaFormulation->{bounds}}) {
		if ($term->[2] eq "flux" || $term->[2] eq "reactionflux") {
			$term->[2] = "flux";
			my $obj = $model->searchForReaction($term->[3]);
			if (!defined($obj)) {
				$self->_error("Reaction ".$term->[3]." not found!");
			}
			$fbaobj->add("FBAReactionBounds",{modelreaction_ref => $obj->_reference(),variableType=> $term->[2],upperBound => $term->[1],lowerBound => $term->[0]});
		} elsif ($term->[2] eq "compoundflux" || $term->[2] eq "drainflux") {
			$term->[2] = "flux";
			my $obj = $model->searchForCompound($term->[3]);
			if (!defined($obj)) {
				$self->_error("Compound ".$term->[3]." not found!");
			}
			$fbaobj->add("FBACompoundBounds",{modelcompound_ref => $obj->_reference(),variableType=> $term->[2],upperBound => $term->[1],lowerBound => $term->[0]});
		} else {
			$self->_error("Objective variable type ".$term->[1]." not recognized!");
		}
	}
	#Parsing gene KO
	if (defined($model->genome_ref())) {
		my $genome = $model->genome();
		foreach my $gene (@{$fbaFormulation->{geneko}}) {
			my $geneObj = $genome->searchForFeature($gene);
			if (defined($geneObj)) {
				$fbaobj->addLinkArrayItem("geneKOs",$geneObj);
			}
		}
	}
	#Parsing reaction KO and blacklisted reactions
	foreach my $reaction (@{$fbaFormulation->{rxnko}}) {
		my $rxnObj = $model->searchForReaction($reaction);
		if (defined($rxnObj)) {
			$fbaobj->addLinkArrayItem("reactionKOs",$rxnObj);
		}
	}
	#Parsing additional Cpds
	foreach my $compound (@{$fbaFormulation->{additionalcpds}}) {
		my $cpdObj = $model->searchForCompound($compound);
		if (defined($cpdObj)) {
			$fbaobj->addLinkArrayItem("additionalCpds",$cpdObj);
		}
	}
	return $fbaobj;
}

sub _setDefaultGapfillFormulation {
	my ($self,$formulation) = @_;
	if (!defined($formulation)) {
		$formulation = {};
	}
	$formulation = $self->_validateargs($formulation,[],{
		target_reactions => [],
		timePerSolution => 3600,
		totalTimeLimit => 18000,
		formulation => undef,
		num_solutions => 1,
		nomediahyp => 0,
		nobiomasshyp => 0,
		nogprhyp => 0,
		nopathwayhyp => 0,
		allowunbalanced => 0,
		activitybonus => 0,
		drainpen => 1,
		directionpen => 1,
		nostructpen => 1,
		unfavorablepen => 1,
		nodeltagpen => 1,
		biomasstranspen => 1,
		singletranspen => 1,
		transpen => 1,
		blacklistedrxns => [qw(
			rxn12985 rxn00238 rxn07058 rxn05305 rxn00154 rxn09037 rxn10643
			rxn11317 rxn05254 rxn05257 rxn05258 rxn05259 rxn05264 rxn05268
			rxn05269 rxn05270 rxn05271 rxn05272 rxn05273 rxn05274 rxn05275
			rxn05276 rxn05277 rxn05278 rxn05279 rxn05280 rxn05281 rxn05282
			rxn05283 rxn05284 rxn05285 rxn05286 rxn05963 rxn05964 rxn05971
			rxn05989 rxn05990 rxn06041 rxn06042 rxn06043 rxn06044 rxn06045
			rxn06046 rxn06079 rxn06080 rxn06081 rxn06086 rxn06087 rxn06088
			rxn06089 rxn06090 rxn06091 rxn06092 rxn06138 rxn06139 rxn06140
			rxn06141 rxn06145 rxn06217 rxn06218 rxn06219 rxn06220 rxn06221
			rxn06222 rxn06223 rxn06235 rxn06362 rxn06368 rxn06378 rxn06474
			rxn06475 rxn06502 rxn06562 rxn06569 rxn06604 rxn06702 rxn06706
			rxn06715 rxn06803 rxn06811 rxn06812 rxn06850 rxn06901 rxn06971
			rxn06999 rxn07123 rxn07172 rxn07254 rxn07255 rxn07269 rxn07451
			rxn09037 rxn10018 rxn10077 rxn10096 rxn10097 rxn10098 rxn10099
			rxn10101 rxn10102 rxn10103 rxn10104 rxn10105 rxn10106 rxn10107
			rxn10109 rxn10111 rxn10403 rxn10410 rxn10416 rxn11313 rxn11316
			rxn11318 rxn11353 rxn05224 rxn05795 rxn05796 rxn05797 rxn05798
			rxn05799 rxn05801 rxn05802 rxn05803 rxn05804 rxn05805 rxn05806
			rxn05808 rxn05812 rxn05815 rxn05832 rxn05836 rxn05851 rxn05857
			rxn05869 rxn05870 rxn05884 rxn05888 rxn05896 rxn05898 rxn05900
			rxn05903 rxn05904 rxn05905 rxn05911 rxn05921 rxn05925 rxn05936
			rxn05947 rxn05956 rxn05959 rxn05960 rxn05980 rxn05991 rxn05992
			rxn05999 rxn06001 rxn06014 rxn06017 rxn06021 rxn06026 rxn06027
			rxn06034 rxn06048 rxn06052 rxn06053 rxn06054 rxn06057 rxn06059
			rxn06061 rxn06102 rxn06103 rxn06127 rxn06128 rxn06129 rxn06130
			rxn06131 rxn06132 rxn06137 rxn06146 rxn06161 rxn06167 rxn06172
			rxn06174 rxn06175 rxn06187 rxn06189 rxn06203 rxn06204 rxn06246
			rxn06261 rxn06265 rxn06266 rxn06286 rxn06291 rxn06294 rxn06310
			rxn06320 rxn06327 rxn06334 rxn06337 rxn06339 rxn06342 rxn06343
			rxn06350 rxn06352 rxn06358 rxn06361 rxn06369 rxn06380 rxn06395
			rxn06415 rxn06419 rxn06420 rxn06421 rxn06423 rxn06450 rxn06457
			rxn06463 rxn06464 rxn06466 rxn06471 rxn06482 rxn06483 rxn06486
			rxn06492 rxn06497 rxn06498 rxn06501 rxn06505 rxn06506 rxn06521
			rxn06534 rxn06580 rxn06585 rxn06593 rxn06609 rxn06613 rxn06654
			rxn06667 rxn06676 rxn06693 rxn06730 rxn06746 rxn06762 rxn06779
			rxn06790 rxn06791 rxn06792 rxn06793 rxn06794 rxn06795 rxn06796
			rxn06797 rxn06821 rxn06826 rxn06827 rxn06829 rxn06839 rxn06841
			rxn06842 rxn06851 rxn06866 rxn06867 rxn06873 rxn06885 rxn06891
			rxn06892 rxn06896 rxn06938 rxn06939 rxn06944 rxn06951 rxn06952
			rxn06955 rxn06957 rxn06960 rxn06964 rxn06965 rxn07086 rxn07097
			rxn07103 rxn07104 rxn07105 rxn07106 rxn07107 rxn07109 rxn07119
			rxn07179 rxn07186 rxn07187 rxn07188 rxn07195 rxn07196 rxn07197
			rxn07198 rxn07201 rxn07205 rxn07206 rxn07210 rxn07244 rxn07245
			rxn07253 rxn07275 rxn07299 rxn07302 rxn07651 rxn07723 rxn07736
			rxn07878 rxn11417 rxn11582 rxn11593 rxn11597 rxn11615 rxn11617
			rxn11619 rxn11620 rxn11624 rxn11626 rxn11638 rxn11648 rxn11651
			rxn11665 rxn11666 rxn11667 rxn11698 rxn11983 rxn11986 rxn11994
			rxn12006 rxn12007 rxn12014 rxn12017 rxn12022 rxn12160 rxn12161
			rxn01267 
		)],
		gauranteedrxns => [qw(
			rxn1 rxn2 rxn3 rxn4 rxn5 rxn6 rxn7 rxn8 rxn11572
			rxn07298 rxn24256 rxn04219 rxn17241 rxn19302 rxn25468 rxn23165
			rxn25469 rxn23171 rxn23067 rxn30830 rxn30910 rxn31440 rxn01659
			rxn13782 rxn13783 rxn13784 rxn05294 rxn05295 rxn05296 rxn10002
			rxn10088 rxn11921 rxn11922 rxn10200 rxn11923 rxn05029
		)],
		allowedcmps => []
	});
	$formulation->{formulation} = $self->_setDefaultFBAFormulation($formulation->{formulation});
	return $formulation;
}

sub _buildGapfillObject {
	my ($self,$formulation,$model,$gfid) = @_;
	if (!defined($gfid)) {
		$gfid = $self->_get_new_id($model->id().".gf.");
	}
	my $fba = $self->_buildFBAObject($formulation->{formulation},$model);
	my $gapform = Bio::KBase::ObjectAPI::KBaseFBA::Gapfilling->new({
		id => $gfid,
    	fba_ref => "",
    	media_ref => $fba->media()->_reference(),
    	fbamodel_ref => $model->_reference(),
    	guaranteedReaction_refs => [],
		blacklistedReaction_refs => [],
		allowableCompartment_refs => [],    
		mediaHypothesis => $self->_invert_boolean($formulation->{nomediahyp}),
		balancedReactionsOnly => $self->_invert_boolean($formulation->{allowunbalanced}),
		reactionAdditionHypothesis => $self->_invert_boolean($formulation->{nopathwayhyp}),
		gprHypothesis => $self->_invert_boolean($formulation->{nogprhyp}),
		#biomassHypothesis => $self->_invert_boolean($formulation->{nobiomasshyp}),
		biomassHypothesis => 0,
		completeGapfill => $formulation->{completeGapfill},
		reactionActivationBonus => $formulation->{activitybonus},
		drainFluxMultiplier => $formulation->{drainpen},
		directionalityMultiplier => $formulation->{directionpen},
		deltaGMultiplier => $formulation->{unfavorablepen},
		noStructureMultiplier => $formulation->{nostructpen},
		noDeltaGMultiplier => $formulation->{nodeltagpen},
		biomassTransporterMultiplier => $formulation->{biomasstranspen},
		singleTransporterMultiplier => $formulation->{singletranspen},
		transporterMultiplier => $formulation->{transpen},
		timePerSolution => $formulation->{timePerSolution},
		totalTimeLimit => $formulation->{totalTimeLimit},
		reactionMultipliers => {},
		gapfillingSolutions => []
	});
	$gapform->fba($fba);
	$gapform->parent($self->_KBaseStore());
	foreach my $reaction (@{$formulation->{targeted_reactions}}) {
		my $rxnObj = $model->template()->biochemistry()->searchForReaction($reaction);
		if (defined($rxnObj)) {
			$gapform->addLinkArrayItem("targetedreactions",$rxnObj);
		}
	}
	foreach my $reaction (@{$formulation->{gauranteedrxns}}) {
		my $rxnObj = $model->template()->biochemistry()->searchForReaction($reaction);
		if (defined($rxnObj)) {
			$gapform->addLinkArrayItem("guaranteedReactions",$rxnObj);
		}
	}
	foreach my $reaction (@{$formulation->{blacklistedrxns}}) {
		my $rxnObj = $model->template()->biochemistry()->searchForReaction($reaction);
		if (defined($rxnObj)) {
		    $gapform->addLinkArrayItem("blacklistedReactions",$rxnObj);
		}
	}
	my $mdlcmps = $model->modelcompartments();
	foreach my $mdlcmp (@{$mdlcmps}) {
		$gapform->addLinkArrayItem("allowableCompartments",$mdlcmp->compartment());
	}
	$gapform->prepareFBAFormulation();
	$gapform->fba()->numberOfSolutions($formulation->{num_solutions});
	#Handling the probabilistic annotation
	my $probRXNWS = $formulation->{probabilisticAnnotation_workspace};
	if (defined($formulation->{probabilisticAnnotation})) {
		my $probanno = $self->_get_msobject("ProbAnno",$formulation->{probabilisticAnnotation_workspace},$formulation->{probabilisticAnnotation});
		if (!defined($probanno)) {
			$self->_error("Invalid probabilistic annotation object!","_buildGapfillObject");
		}
		# Calculate the reaction probabilities from the probabilistic annotation.
		# The output RxnProbs object is saved by reference via the "NO_WORKSPACE" workspace.
		# TODO Do we need to specify a model template here?
		my $rpmeta = $self->_probanno()->calculate( { 
			probanno => $formulation->{probabilisticAnnotation},
			probanno_workspace => $formulation->{probabilisticAnnotation_workspace},
			rxnprobs => $formulation->{probabilisticAnnotation},
			rxnprobs_workspace => $formulation->{probabilisticAnnotation_workspace},
			auth => $self->_authentication()
		});
		$formulation->{probabilisticReactions} = $rpmeta->[8];
		$probRXNWS = $formulation->{probabilisticAnnotation_workspace};
		
	}
	$formulation->{probabilisticReaction_workspace} = $probRXNWS;
	if (defined($formulation->{probabilisticReactions})) {
		# Get the RxnProbs object from the workspace.
		my $rxnprobs = $self->_get_msobject("RxnProbs",$probRXNWS,$formulation->{probabilisticReactions});
		#Get coefficients of probmodel
		$gapform->fba()->parameters()->{"Objective coefficient file"} = "ProbModelReactionCoefficients.txt";
		$gapform->fba()->inputfiles()->{"ProbModelReactionCoefficients.txt"} = [];
		my $probrxns = $rxnprobs->reaction_probabilities();
		my $rxncosts = {};
		for (my $i=0; $i < @{$probrxns}; $i++) {
			my $rxn = $probrxns->[$i];
			$rxncosts->{$rxn->[0]} = (1-$rxn->[1]);
		}
		my $compindecies = {};
		my $comps = $model->modelcompartments();
		for (my $i=0; $i < @{$comps}; $i++) {
			$compindecies->{$comps->[$i]->compartmentIndex()}->{$comps->[$i]->compartment()->id()} = 1;
		}
		my $gfcpdhash;
		foreach my $compindex (keys(%{$compindecies})) {
			my $tmp = $model->template();
			my $tmprxns = $tmp->templateReactions();
			for (my $i=0; $i < @{$tmprxns}; $i++) {
				my $tmprxn = $tmprxns->[$i];
				my $tmpid = $tmprxn->reaction()->id()."_".$tmprxn->compartment()->id().$compindex;
				if (defined($rxncosts->{$tmprxn->reaction()->id()})) {
					push(@{$gapform->fba()->inputfiles()->{"ProbModelReactionCoefficients.txt"}},"forward\t".$tmpid."\t".$rxncosts->{$tmprxn->reaction()->id()});
					push(@{$gapform->fba()->inputfiles()->{"ProbModelReactionCoefficients.txt"}},"reverse\t".$tmpid."\t".$rxncosts->{$tmprxn->reaction()->id()});
				}
			}
		}	
	}
	return ($gapform,$fba);
}

# Build the three-level GPR array for all reactions in a RxnProbs object.

sub _buildRxnProbsGPRArray {
    my ($self, $rxnprobs) = @_;
    my($rxnprobsGPRArray);
    for(my $i=0; $i < @{$rxnprobs->reaction_probabilities()}; $i++) {
	my $rxnarray = $rxnprobs->reaction_probabilities()->[$i];
	my $rxnid = $rxnarray->[0];
	my $gpr = $rxnarray->[4];
	if ( $gpr ne "" ) {
#	    $rxnprobsGPRArray->{$rxnid} = Bio::KBase::ObjectAPI::utilities::translateGPRHash(Bio::KBase::ObjectAPI::utilities::parseGPR($gpr));
	    $rxnprobsGPRArray->{$rxnid} = $gpr;
	}
    }
    return $rxnprobsGPRArray;
}

sub _setDefaultGapGenFormulation {
	my ($self,$formulation) = @_;
	if (!defined($formulation)) {
		$formulation = {};
	}
	$formulation = $self->_validateargs($formulation,[],{
		formulation => undef,
		refmedia => "Carbon-D-Glucose",
		refmedia_workspace => "KBaseMedia",
		timePerSolution => 3600,
		totalTimeLimit => 18000,
		num_solutions => 1,
		nomediahyp => 0,
		nobiomasshyp => 0,
		nogprhyp => 0,
		nopathwayhyp => 0,
	});
	$formulation->{formulation} = $self->_setDefaultFBAFormulation($formulation->{formulation});
	return $formulation;
}

sub _buildGapGenObject {
	my ($self,$formulation,$model,$ggid) = @_;
	if (!defined($ggid)) {
		$ggid = $self->_get_new_id($model->id().".gg.");
	}
	my $fba = $self->_buildFBAObject($formulation->{formulation},$model);
	my $media = $self->_get_msobject("Media",$formulation->{refmedia_workspace},$formulation->{refmedia});
	my $gapform = Bio::KBase::ObjectAPI::KBaseFBA::Gapgeneration->new({
		id => $ggid,
    	fba_ref => "",
    	fbamodel_ref => $model->_reference(),
    	mediaHypothesis => $self->_invert_boolean($formulation->{nomediahyp}),
		biomassHypothesis => $self->_invert_boolean($formulation->{nobiomasshyp}),
		gprHypothesis => $self->_invert_boolean($formulation->{nogprhyp}),
		reactionRemovalHypothesis => $self->_invert_boolean($formulation->{nopathwayhyp}),
    	media_ref => $fba->media()->_reference(),
    	referenceMedia_ref => $media->_reference(),
    	timePerSolution => $formulation->{timePerSolution},
    	totalTimeLimit => $formulation->{totalTimeLimit},
    	gapgenSolutions => []
	});
	$gapform->fba($fba);
	$gapform->parent($self->_KBaseStore());
	$gapform->prepareFBAFormulation();
	$gapform->fbaFormulation()->numberOfSolutions($formulation->{num_solutions});
	return $gapform;
}

sub _get_new_id {
	my ($self,$prefix) = @_;
	my $id;
	eval {
		$id = $self->_idServer()->allocate_id_range( $prefix, 1 );
	};
	if (!defined($id) || $id eq "") {
    	$id = "0";
    }
    $id = $prefix.$id;
	$id =~ s/(kb\|[a-zA-Z]+)(\d+)$/$1.$2/;
	return $id;
};

sub _phenotypeSimulationSet_to_html {
	my ($self,$obj) = @_;
	my $htmlArray = [
		'<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">',
		'<html><head>',
		'<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>',
		'    <script type="text/javascript">',
		'        function UpdateTableHeaders() {',
		'            $("div.divTableWithFloatingHeader").each(function() {',
		'                var originalHeaderRow = $(".tableFloatingHeaderOriginal", this);',
		'                var floatingHeaderRow = $(".tableFloatingHeader", this);',
		'                var offset = $(this).offset();',
		'                var scrollTop = $(window).scrollTop();',
		'                if ((scrollTop > offset.top) && (scrollTop < offset.top + $(this).height())) {',
		'                    floatingHeaderRow.css("visibility", "visible");',
		'                    floatingHeaderRow.css("top", Math.min(scrollTop - offset.top, $(this).height() - floatingHeaderRow.height()) + "px");',
		'                    // Copy row width from whole table',
		'                    floatingHeaderRow.css(\'width\', "1200px");',
		'                    // Copy cell widths from original header',
		'                    $("th", floatingHeaderRow).each(function(index) {',
		'                        var cellWidth = $("th", originalHeaderRow).eq(index).css(\'width\');',
		'                        $(this).css(\'width\', cellWidth);',
		'                    });',
		'                }',
		'                else {',
		'                    floatingHeaderRow.css("visibility", "hidden");',
		'                    floatingHeaderRow.css("top", "0px");',
		'                }',
		'            });',
		'        }',
		'        $(document).ready(function() {',
		'            $("table.tableWithFloatingHeader").each(function() {',
		'                $(this).wrap("<div class=\"divTableWithFloatingHeader\" style=\"position:relative\"></div>");',
		'                var originalHeaderRow = $("tr:first", this)',
		'                originalHeaderRow.before(originalHeaderRow.clone());',
		'                var clonedHeaderRow = $("tr:first", this)',
		'                clonedHeaderRow.addClass("tableFloatingHeader");',
		'                clonedHeaderRow.css("position", "absolute");',
		'                clonedHeaderRow.css("top", "0px");',
		'                clonedHeaderRow.css("left", $(this).css("margin-left"));',
		'                clonedHeaderRow.css("visibility", "hidden");',
		'                originalHeaderRow.addClass("tableFloatingHeaderOriginal");',
		'            });',
		'            UpdateTableHeaders();',
		'            $(window).scroll(UpdateTableHeaders);',
		'            $(window).resize(UpdateTableHeaders);',
		'        });',
		'    </script>',
		'<style type="text/css">',
		'h1 {',
		'    font-size: 16px;',
		'}',
		'table.tableWithFloatingHeader {',
		'    font-size: 12px;',
		'    text-align: left;',
		'	 border: 0;',
		'	 width: 1200px;',
		'}',
		'th {',
		'    font-size: 14px;',
		'    background: #ddd;',
		'	 border: 1px solid black;',
		'    vertical-align: top;',
		'    padding: 5px 5px 5px 5px;',
		'}',
		'td {',
		'   font-size: 16px;',
		'	vertical-align: top;',
		'	border: 1px solid black;',
		'}',
		'</style></head>',
		'<h2>Phenotype simulation set attributes</h2>',
		'<table>',
		"<tr><th>ID</th><td style='font-size:16px;border: 1px solid black;'>".$obj->{id}."</td></tr>",
		"<tr><th>Model</th><td style='font-size:16px;border: 1px solid black;'>".$obj->{model_workspace}."/".$obj->{model}."</td></tr>",		
		'</table>',
		'<h2>Simulated phenotypes</h2>',
		'<table class="tableWithFloatingHeader">',
		'<tr><th>Base media</th><th>Additional compounds</th><th>Gene KO</th><th>Growth</th><th>Simulated growth</th><th>Simulated growth fraction</th><th>Class</th></tr>',
	];
	foreach my $phenotype (@{$obj->{phenotypeSimulations}}) {
		push(@{$htmlArray},
			'<tr><td>'.$phenotype->[0]->[2]."/".$phenotype->[0]->[1].'</td>'.
			'<td>'.join(", ",@{$phenotype->[0]->[3]}).'</td>'.
			'<td>'.join(", ",@{$phenotype->[0]->[0]}).'</td>'.
			'<td>'.$phenotype->[0]->[4].'</td>'.
			'<td>'.$phenotype->[1].'</td>'.
			'<td>'.$phenotype->[2].'</td>'.
			'<td>'.$phenotype->[3].'</td></tr>'
		);
	}
	push(@{$htmlArray},'</table>');
	push(@{$htmlArray},'</html>');
	return join("\n",@{$htmlArray});
};

sub _generate_fbameta {
	my ($self,$obj) = @_;
	my $objective;
	if (defined($obj->fbaResults()->[0])) {
		$objective = $obj->fbaResults()->[0]->objectiveValue();
	}
	my $idarray = [split(/\//,$obj->uuid())];
	(my $mediaid,my $mediaws);
	if ($obj->media_uuid() =~ m/(.+)\/(.+)/) {
		$mediaws = $1;
		$mediaid = $2;
	} else {
		$mediaws = "NO_WORKSPACE";
		$mediaid = $obj->media()->id();
	}
	my $kos = [];
	foreach my $gene ($obj->geneKOs()) {
		if (defined($gene) && ref($gene) eq "Bio::KBase::ObjectAPI::KBaseGenomes::Feature") {
			push(@{$kos},$gene->id());
		}
	}
	return [
		$idarray->[1],
		$idarray->[0],
		$mediaid,
		$mediaws,
		$objective,
		$kos
	];
}

=head3 _was_reaction_gapfilled

Definition:
    Bool = _was_reaction_gapfilled(ModelSEED::MS::ModelReaction)

Description:
    Returns 1 if the ModelReaction was a gapfilled reaction.
    Returns 0 for any reaction originally in the model (even if the reversibility was changed by gapfill)

=cut

sub _was_reaction_gapfilled {
    my ($self, $modelrxn) = @_;
    my $proteins = $modelrxn->modelReactionProteins();
    my $gapfilled = 0;
    if (@{$proteins} == 0) {
	$gapfilled = 1;
    } elsif ( @{$proteins} >= 1 ) {
	my $ok = 1;
	foreach ( my $j=0; $j<@{$proteins}; $j++ ) {
	    if ( $proteins->[$j]->complex_ref() ne "" || $proteins->[$j]->note() eq "spontaneous" || $proteins->[$j]->note() eq "universal" ) {
		$ok = 0;
		last;
	    }
	}
	if ( $ok == 1 ) {
	    $gapfilled = 1;
	}
    }
    return $gapfilled;
}

# Get an array if (rxnid, direction) pairs from the third element of a line in ProblemReport.txt
sub _parse_problem_report_solution {
    my ($self, $str) = @_;
    my $matches = [];
    @$matches = ( $str =~ /([+-]rxn\d+)/g );
    my $outarr = [];
    for( my $i=0; $i<@{$matches}; $i++ ) {
	my $subarr = [];
	if ( $matches->[$i] =~ /\+/ ) {
	    ( $subarr->[0] = $matches->[$i] ) =~ s/\+//;
	    $subarr->[1] = ">";
	} else {
	    ( $subarr->[0] = $matches->[$i] ) =~ s/-//;
	    $subarr->[1] = "<";
	}
	push(@$outarr, $subarr);
    }
    return $outarr;
}

# Parse a gapfill solution ID into (gapfill UUID, solution number)
sub _parse_gapfillsolution_id {
    my ($self, $solution_id) = @_;
    my($gfid, $solid);
    # Handle gapfill solution. Get all the reactions modified by the specified gapfill solution.
    if ($solution_id =~ m/(.+)\.gfsol\.(.+)/) {
	$gfid = $1;
	$solid = $2;
    } else { 
	$self->_error("Specified gapfill solution ID did not have expected format GAPFILLID.gfsol.NUMBER", "_get_gapfill_solution");
    }
    my $result = [];
    $result->[0] = $gfid;
    $result->[1] = $solid;
    return $result;
}

# Get a MS::GapfillSolution object given its ID
sub _get_gapfill_solution{
    my ($self, $solution_id, $gapfill_ws) = @_;
    my $parsedsolution = $self->_parse_gapfillsolution_id($solution_id);
    my $gfid = $parsedsolution->[0];
    my $solid = $parsedsolution->[1];
    my $gapfill = $self->_get_msobject("Gapfilling", $gapfill_ws, $gfid);
    my $gapfillSolutions = $gapfill->gapfillingSolutions();
    if ( ! defined($gapfillSolutions) ) { 
	$self->_error("Unable to find gapfill solution $solution_id", "_get_gapfill_solution");  
    }
    if ( @{$gapfillSolutions} < $solid ) { 
	$self->_error("Solution number $solid specified but there are fewer than that in the specified gapfill object (note that the solution numbers start at 1)", "_get_gapfill_solution"); 
    }
    my $desiredSolution = $gapfillSolutions->[$solid - 1];
    return $desiredSolution;
}

=head3 get_gapfill_solution_reactions

Definition:
    Array_ref = _get_gapfill_solution_reactions(Gapfill_solution_id, Gapfill_workspace, ModelSEED::MS::Model)

Description:
    Get a GapFill object associated with a solution ID.
    Returns an array ref contianing the ModelSEED IDs for each reaction.
    Ignores reations that are not in the model and only adds each reaction once...
    Also ignored reactions that were added as reversibility changes.

Example:

    Array_ref = _get_gapfill_solution_reactions(GAPFILL_REF.gfsol.0)

=cut

sub _get_gapfill_solution_reactions {
    my ( $self, $solution_id, $gapfill_ws, $model ) = @_;
    my($gfid, $solid);

    # Get a hash of the reactions in the model (was the reaction deleted after gapfill?)
    # Also get a hash of all reactions ADDED by the combination of integrated gapfill solutions.
    # This potentially is wrong if there are multiple integrated gapfill solutions that weren't done sequentially.
    # We could use a more robust way of storing whether or not a reaction was a reversibility change due to gapfill.
    my $model_rxnids = {};
    my $gapfilled_rxnids = {};
    my $modelrxns = $model->modelreactions();
    for ( my $i=0; $i < @{$modelrxns}; $i++ ) {
	my $dir = $modelrxns->[$i]->direction;
	if ( $dir eq "=" ) {
	    $model_rxnids->{ "+".$modelrxns->[$i]->reaction()->id } = 1;
	    $model_rxnids->{ "-".$modelrxns->[$i]->reaction()->id } = 1;
	} elsif ( $dir eq ">" ) {
	    $model_rxnids->{ "+".$modelrxns->[$i]->reaction()->id } = 1;
	} elsif ( $dir eq "<" ) {
	    $model_rxnids->{ "-".$modelrxns->[$i]->reaction()->id } = 1;
	}
    }

    my $desiredSolution = $self->_get_gapfill_solution($solution_id, $gapfill_ws);
    my $solutionReactions = $desiredSolution->gapfillingSolutionReactions();

    # Get the desired list of reactions.
    my $rxnids = [];
    my $directions = [];
    my $seenrxns = {};
    for ( my $i=0; $i < @{$solutionReactions}; $i++ ) {
	my $id = $solutionReactions->[$i]->reaction()->id;
	my $modelDirection = $solutionReactions->[$i]->direction;
	my ($dirstring);
	if ( $modelDirection eq ">" ) {
	    $dirstring = "+";
	} elsif ( $modelDirection eq "<" ) {
	    $dirstring = "-";
	} else {
	    self->_error("ERROR: Direction for gapfill solution reaction was not < or > (this should never happen)", "_get_gapfill_solution_reactions");
	}
	$id = $dirstring.$id;

	# Is this reaction in the original model?
	if ( ! defined($model_rxnids->{$id} ) ) {
	    next;
	}
	# Duplicates happen in the iterative gapfill solutions. We don't want them, and if it appeared both earlier and later then it is useful for a high-priority gapfill
	# so we want to test it later.
	if ( defined($seenrxns->{$id}) ) {
	    next;
	}
	$seenrxns->{$id} = 1;
	push(@{$rxnids}, $id);
    }
    # Reverse order - lower-priority gapfill solutions are tested for removal first.
    @{$rxnids} = reverse(@{$rxnids});

    return $rxnids;
    
}

=head3 _sort_gapfill_solution_reactions

Definition:
    Array_ref = _sort_gapfill_solution_reactions(Array_ref, RxnProbs_id, RxnProbs_ws)

Description:
    (Stably) sort the reaction list by probability.
    Returns the sorted list of reactions

=cut

sub _sort_gapfill_solution_reactions {
    my ($self, $rxnlist, $rxnprobs_id, $rxnprobs_workspace) = @_;
    my $rxnprobdict = {};
    # Build up the rxnprobs dictionary...
    my $RxnProbs = $self->_get_msobject("RxnProbs", $rxnprobs_workspace, $rxnprobs_id);
    for(my $i=0; $i<@{$RxnProbs->reaction_probabilities()}; $i++) {
		my $rxnarray = $RxnProbs->reaction_probabilities()->[$i];
        my $rxnid = $rxnarray->[0];
		my $likelihood = $rxnarray->[1];
		$rxnprobdict->{"+".$rxnid} = $likelihood;
		$rxnprobdict->{"-".$rxnid} = $likelihood;
    }

    # Build an array of (reaction, likelihood) sets
    my $unsorted = [];
    for(my $i=0; $i<@{$rxnlist}; $i++) {
	my $singlearray = [];
	if ( defined($rxnprobdict->{$rxnlist->[$i]}) ) {
	    $singlearray = [ $rxnlist->[$i], $rxnprobdict->{$rxnlist->[$i]} ];
	} else {
	    $singlearray = [ $rxnlist->[$i], 0 ];
	}
	push(@$unsorted, [ @$singlearray ]);
    }

    my $sorted = [];
    @$sorted = map { $_->[0] } sort { $a->[1] cmp $b->[1] } @$unsorted;

    return $sorted;
}


sub _generate_gapmeta {
	my ($self,$obj) = @_;
	my $idarray = [split(/\//,$obj->uuid())];
	my $done = 0;
	if ($obj->_type() eq "Gapfilling" && defined($obj->gapfillingSolutions())) {
		$done = 1;
	} elsif ($obj->_type() eq "Gapgeneration" && defined($obj->gapgenSolutions())) {
		$done = 1;
	}
	my $kos = [];
	foreach my $gene ($obj->fba()->geneKOs()) {
		if (defined($gene) && ref($gene) eq "Bio::KBase::ObjectAPI::KBaseGenomes::Feature") {
			push(@{$kos},$gene->id());
		}
	}
	return [
		$obj->id(),
		$obj->_reference(),
		$obj->fba()->media()->name(),
		$obj->fba()->media_ref(),
		$done,
		$kos
	];
}

sub _FBA_to_FBAFormulation {
	my ($self,$obj) = @_;
	my $media;
	my $media_workspace;
	if ($obj->media_ref() =~ m/^(.+)\/(.+)/) {
		$media_workspace = $1;
		$media = $2;
	}
	my $form = {
		media => $media,
		media_workspace => $media_workspace,
		objfraction => $obj->objectiveConstraintFraction(),
		allreversible => $obj->allReversible(),
		maximizeObjective => $obj->maximizeObjective(),
		objectiveTerms => [],
		geneko => [],
		rxnko => [],
		bounds => [],
		constraints => [],
		uptakelim => $obj->uptakeLimits(),
		defaultmaxflux => $obj->defaultMaxFlux(),
		defaultminuptake => $obj->defaultMinDrainFlux(),
		defaultmaxuptake => $obj->defaultMaxDrainFlux(),
		simplethermoconst => $obj->simpleThermoConstraints(),
		thermoconst => $obj->thermodynamicConstraints(),
		nothermoerror => $obj->noErrorThermodynamicConstraints(),
		minthermoerror => $obj->minimizeErrorThermodynamicConstraints()
	};
	foreach my $ko (@{$obj->geneKOs()}) {
		push(@{$form->{geneko}},$ko->id());
	}
	foreach my $ko (@{$obj->reactionKOs()}) {
		push(@{$form->{rxnko}},$ko->id());
	}
	foreach my $const (@{$obj->FBAConstraints()}) {
		my $terms = [];
		foreach my $term (@{$const->FBAConstraintVariables()}) {
			push(@{$terms},[$term->coefficient(),$term->variableType(),$term->entity()->id()]);
		}
		push(@{$form->{constraints}},[$const->rhs(),$const->sign(),$terms,$const->name()]);
	}
	foreach my $bound (@{$obj->FBAReactionBounds()}) {
		push(@{$form->{bounds}},[$bound->lowerBound(),$bound->upperBound(),$bound->variableType(),$bound->modelreaction()->id()]);
	}
	foreach my $bound (@{$obj->FBACompoundBounds()}) {
		push(@{$form->{bounds}},[$bound->lowerBound(),$bound->upperBound(),$bound->variableType(),$bound->modelcompound()->id()]);
	}
	foreach my $term (keys(%{$obj->compoundflux_objterms()})) {
		push(@{$form->{objectiveTerms}},[$obj->compoundflux_objterms()->{$term},"drainflux",$term]);
	}
	foreach my $term (keys(%{$obj->reactionflux_objterms()})) {
		push(@{$form->{objectiveTerms}},[$obj->reactionflux_objterms()->{$term},"flux",$term]);
	}
	foreach my $term (keys(%{$obj->biomassflux_objterms()})) {
		push(@{$form->{objectiveTerms}},[$obj->biomassflux_objterms()->{$term},"flux",$term]);
	}
	return $form;
}

sub _FBA_to_FBAdata {
	my ($self,$obj) = @_;
	my $array = [split(/\//,$obj->uuid())];
	my $mdlarray = [split(/\//,$obj->fbamodel()->uuid())];
	my $fbadata = {
    	id => $obj->id(),
    	fbaref => $obj->_reference(),
    	modelref => $obj->fbamodel_ref(),
    	isComplete => 0,
    	objective => undef,
    	formulation => $self->_FBA_to_FBAFormulation($obj),
    	minimalMediaPredictions => [],
		metaboliteProductions => [],
		reactionFluxes => [],
		compoundFluxes => [],
		geneAssertions => []
	};
    if (defined($obj->objectiveValue())) {
		$fbadata->{isComplete} = 1;
		$fbadata->{objective} = $obj->objectiveValue();
		foreach my $var (@{$obj->FBACompoundVariables()}) {
			push(@{$fbadata->{compoundFluxes}},[
				$var->modelcompound()->id(),
				$var->value(),
				$var->upperBound(),
				$var->lowerBound(),
				$var->max(),
				$var->min(),
				$var->variableType(),
				$var->modelcompound()->name()
			]);
		}
		foreach my $var (@{$obj->FBAReactionVariables()}) {
			push(@{$fbadata->{reactionFluxes}},[
				$var->modelreaction()->id(),
				$var->value(),
				$var->upperBound(),
				$var->lowerBound(),
				$var->max(),
				$var->min(),
				$var->variableType(),
				$var->modelreaction()->definition()
			]);
		}
		foreach my $var (@{$obj->FBABiomassVariables()}) {
			push(@{$fbadata->{reactionFluxes}},[
				$var->biomass()->id(),
				$var->value(),
				$var->upperBound(),
				$var->lowerBound(),
				$var->max(),
				$var->min(),
				$var->variableType()
			]);
		}
		foreach my $var (@{$obj->FBADeletionResults()}) {
			my $essential = 1;
			if ($var->growthFraction() > 0.05) {
				$essential = 0;
			}
			push(@{$fbadata->{geneAssertions}},[
				$var->genekos()->[0]->id(),
				$var->growthFraction(),
				($var->growthFraction()*$fbadata->{objective}),
				$essential
			]);
		}
		foreach my $var (@{$obj->FBAMetaboliteProductionResults()}) {
			push(@{$fbadata->{metaboliteProductions}},[
				$var->maximumProduction(),
				$var->modelcompound()->id(),
				$var->modelcompound()->name()
			]);
		}
		foreach my $minmedia (@{$obj->FBAMinimalMediaResults()}) {
			my $data = {
				optionalNutrients => [],
				essentialNutrients => []
			};
			foreach my $cpd (@{$minmedia->essentialNutrients()}) {
				push(@{$data->{essentialNutrients}},$cpd->id())
			}
			foreach my $cpd (@{$minmedia->optionalNutrients()}) {
				push(@{$data->{optionalNutrients}},$cpd->id())
			}
			push(@{$fbadata->{minimalMediaPredictions}},$data);	
		}
    }
    return $fbadata;
}

sub _invert_boolean {
	my ($self,$input) = @_;
	if ($input == 1) {
		return 0;
	}
	return 1;
}

sub _GapFill_to_GapFillFormulation {
	my ($self,$obj) = @_;
	my $form = {
		formulation => $self->_FBA_to_FBAFormulation($obj->fba()),
		nomediahyp => $self->_invert_boolean($obj->mediaHypothesis()),
		nobiomasshyp => $self->_invert_boolean($obj->biomassHypothesis()),
		nogprhyp => $self->_invert_boolean($obj->gprHypothesis()),
		nopathwayhyp => $self->_invert_boolean($obj->reactionAdditionHypothesis()),
		allowunbalanced => $self->_invert_boolean($obj->balancedReactionsOnly()),
		activitybonus => $obj->reactionActivationBonus(),
		drainpen => $obj->drainFluxMultiplier(),
		directionpen => $obj->directionalityMultiplier(),
		nostructpen => $obj->noStructureMultiplier(),
		unfavorablepen => $obj->deltaGMultiplier(),
		nodeltagpen => $obj->noDeltaGMultiplier(),
		biomasstranspen => $obj->biomassTransporterMultiplier(),
		singletranspen => $obj->singleTransporterMultiplier(),
		transpen => $obj->transporterMultiplier(),
		blacklistedrxns => [],
		gauranteedrxns => [],
		allowedcmps => [],
		probabilisticAnnotation => undef,
		probabilisticReactions => undef
	};
	foreach my $rxn (@{$obj->blacklistedReactions()}) {
		push(@{$form->{blacklistedrxns}},$rxn->id());
	}
	foreach my $rxn (@{$obj->guaranteedReactions()}) {
		push(@{$form->{gauranteedrxns}},$rxn->id());
	}
	foreach my $comp (@{$obj->allowableCompartments()}) {
		push(@{$form->{allowedcmps}},$comp->id());
	}
	return $form;
}

sub _GapFill_to_GapFillData {
	my ($self,$obj) = @_;
	my $array = [split(/\//,$obj->_reference())];
	my $mdlarray = [split(/\//,$obj->fbamodel()->_reference())];
	my $data = {
    	id => $obj->_wsname(),
    	workspace => $obj->_wsworkspace(),
    	model => $obj->fbamodel()->_wsname(),
    	model_workspace => $obj->fbamodel()->_wsworkspace(),
    	isComplete => 0,
    	formulation => $self->_GapFill_to_GapFillFormulation($obj),
    	solutions => []
	};
	my $solutions = $obj->gapfillingSolutions();
    if (defined($solutions->[0])) {
		$data->{isComplete} = 1;
		for (my $i=0; $i < @{$solutions}; $i++) {
			my $solution = $solutions->[$i];
			my $solData = {
				id => $solutions->[$i]->id(),
				objective => $solution->solutionCost(),
				biomassRemovals => [],
				mediaAdditions => [],
				reactionAdditions => [],
			};
			for (my $j=0; $j < @{$solution->biomassRemovals()}; $j++) {
				push(@{$solData->{biomassRemovals}},[
					$solution->biomassRemovals()->[$j]->id(),
					$solution->biomassRemovals()->[$j]->name()
				]);
			}
			for (my $j=0; $j < @{$solution->mediaSupplements()}; $j++) {
				push(@{$solData->{mediaAdditions}},[
					$solution->mediaSupplements()->[$j]->id(),
					$solution->mediaSupplements()->[$j]->name()
				]);
			}
			for (my $j=0; $j < @{$solution->gapfillingSolutionReactions()}; $j++) {
				push(@{$solData->{reactionAdditions}},[
					$solution->gapfillingSolutionReactions()->[$j]->reaction()->id(),
					$solution->gapfillingSolutionReactions()->[$j]->reaction()->direction(),
					"c",
					$solution->gapfillingSolutionReactions()->[$j]->reaction()->equation(),
					$solution->gapfillingSolutionReactions()->[$j]->reaction()->definition()
				]);
			}
			$data->{solutions}->[$i] = $solData;
		}
	}
    return $data;
}

sub _GapGen_to_GapGenData {
	my ($self,$obj) = @_;
	my $data = {
    	id => $obj->_wsname(),
    	workspace => $obj->_wsworkspace(),
    	model => $obj->fbamodel()->_wsname(),
    	model_workspace => $obj->fbamodel()->_wsworkspace(),
    	isComplete => 0,
    	formulation => {
    		formulation => $self->_FBA_to_FBAFormulation($obj->fbaFormulation()),
    		nomediahyp => $self->_invert_boolean($obj->mediaHypothesis()),
			nobiomasshyp => $self->_invert_boolean($obj->biomassHypothesis()),
			nogprhyp => $self->_invert_boolean($obj->gprHypothesis()),
			nopathwayhyp => $self->_invert_boolean($obj->reactionRemovalHypothesis())
    	},
    	solutions => []
	};
    my $solutions = $obj->gapgenSolutions();
    if (defined($solutions->[0])) {
		$data->{isComplete} = 1;
		for (my $i=0; $i < @{$solutions}; $i++) {
			my $solution = $solutions->[$i];
			my $solData = {
				id => $solution->id(),
				objective => $solution->solutionCost(),
				biomassAdditions => [],
				mediaRemovals => [],
				reactionRemovals => []
			};
			for (my $j=0; $j < @{$solutions->biomassSupplements()}; $j++) {
				push(@{$solData->{biomassAdditions}},[
					$solutions->biomassSupplements()->[$j]->id(),
					$solutions->biomassSupplements()->[$j]->name()
				]);
			}
			for (my $j=0; $j < @{$solutions->mediaRemovals()}; $j++) {
				push(@{$solData->{mediaRemovals}},[
					$solutions->mediaRemovals()->[$j]->id(),
					$solutions->mediaRemovals()->[$j]->name()
				]);
			}
			for (my $j=0; $j < @{$solutions->gapgenSolutionReactions()}; $j++) {
				push(@{$solData->{reactionRemovals}},[
					$solutions->gapgenSolutionReactions()->[$j]->modelreaction()->reaction()->id(),
					$solutions->gapgenSolutionReactions()->[$j]->modelreaction()->reaction()->direction(),
					"c",
					$solutions->gapgenSolutionReactions()->[$j]->modelreaction()->reaction()->equation(),
					$solutions->gapgenSolutionReactions()->[$j]->modelreaction()->reaction()->definition()
				]);
			}
			$data->{solutions}->[$i] = $solData;
		}
	}
    return $data;
}



=head3 _queueJob

Definition:
	{} JobObject = $self->_queueJob({
	 	type => string,
	 	jobdata => {},
	 	queuecommand => string,
	 	state => state
	 });
Description:
	Queues job in workspace
		
=cut

sub _queueJob {
	my($self,$args) = @_;
	if ($self->_jobqueue() eq "awe") {
		#Loading job parameters to shock
		my $json = Bio::KBase::ObjectAPI::utilities::TOJSON($args->{jobdata});
		my $uuid = Data::UUID->new()->create_str();
		File::Path::mkpath Bio::KBase::ObjectAPI::utilities::MFATOOLKIT_JOB_DIRECTORY();
		Bio::KBase::ObjectAPI::utilities::PRINTFILE(Bio::KBase::ObjectAPI::utilities::MFATOOLKIT_JOB_DIRECTORY().$uuid,[$json]);
		my $output = Bio::KBase::ObjectAPI::utilities::runexecutable("curl -H \"Authorization: OAuth ".$self->_authentication()."\" -X POST -F upload=\@".Bio::KBase::ObjectAPI::utilities::MFATOOLKIT_JOB_DIRECTORY().$uuid."' ".$self->_shockurl()."/node");
		my $output = Bio::KBase::ObjectAPI::utilities::FROMJSON($output);
		my $nodeid = $output->{id};
		my $filename = Bio::KBase::ObjectAPI::utilities::MFATOOLKIT_JOB_DIRECTORY().$nodeid;
		my $job ={
			info => {
				pipeline => "KBaseFBAModeling",
				name => "KBaseFBAModeling_job",
				project => "KBase",
				user => $self->_getUsername(),
				clientgroups => "",
			},
			tasks => [
				{
					taskid => 0,
					partinfo => {
						input => "JobParameters",
						output => "JobOutput"
					},
					cmd => {
	                    args => $args->{queuecommand}." JobParameters JobOutput", 
	                    description => "Running a specific job submitted to the awe cluster", 
	                    name => "fba-run-awe-job",
	                    environ => {
	                        private => {
	                        	KB_AUTH_TOKEN => $self->_authentication()
	                        }
	                    }
	                },
	                inputs => {
	                	JobParameters => {
	                		host => $self->_shockurl(),
	                		node => $nodeid
	                	}
	                },
	                outputs => {
	                	JobOutput => {
	                		host => $self->_shockurl()
	                	}
	                }
				}
			]
		};
		$json = Bio::KBase::ObjectAPI::utilities::TOJSON($job);
		Bio::KBase::ObjectAPI::utilities::PRINTFILE($filename,[$json]);
		my $data = Bio::KBase::ObjectAPI::utilities::runexecutable("curl [-H \"Datatoken: ".$self->_authentication()."\"] -X POST -F upload=\@".$filename." ".$self->_aweurl()."/job");
		return {
			id => $data->{id},
			type => "KBaseFBAModeling",
			status => $data->{"state"},
			jobdata => $args->{jobdata},
			queuetime => $data->{createddate},
			owner => $self->_getUsername(),
			queuecommand => $args->{queuecommand}
		};
	} else {
		my $input = {
			type => $args->{type},
			jobdata => $args->{jobdata},
			queuecommand => $args->{queuecommand},
			"state" => $args->{"state"},
			auth => $self->_authentication(),
		};
		if (!defined($args->{jobdata}->{wsurl})) {
			$args->{jobdata}->{wsurl} = $self->_workspaceURL();
		}
		return $self->_jobserv()->queue_job($input);
	}
}

=head3 _defaultJobState

Definition:
	 = $self->_defaultJobState();
Description:
	Returns the default job state for this service
		
=cut

sub _defaultJobState {
	my($self) = @_;
	return $self->{_defaultJobState};
}

=head3 _getJob

Definition:
	{} JobObject = $self->_getJob(string id);
Description:
	Returns the specified job object
		
=cut

sub _getJob {
	my($self,$id) = @_;
	my $jobs = $self->_jobserv()->get_jobs({
		jobids => [$id],
		auth => $self->_authentication()
	});
	return $jobs->[0];
}

=head3 _error

Definition:
	$self->_error(string message,string method);
Description:
	Throws an exception
		
=cut

sub _error {
	my($self,$msg) = @_;
	$msg = "_ERROR_".$msg."_ERROR_";
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,method_name => $self->_KBaseStore()->provenance()->[0]->{method});
}

=head3 _build_sequence_object

Definition:
	{} object meta = $self->_build_sequence_object(string type,{} params);
Description:
	Builds a sequence type object and loads it into the workspace
		
=cut
sub _build_sequence_object {
	my($self,$type,$params) = @_;
	my $subprefix = "prot";
	my $prefix = "kb|protset";
	my $fieldname = "proteins";
	if ($type eq "ContigSet") {
		$subprefix = "contig";
		$fieldname = "contigs";
		$prefix = "kb|contigset";
	}
	my $object = {
		id => undef,
		name => $params->{name},
		source_id => $params->{sourceid},
		source => $params->{source},
		type => $params->{type},
		$fieldname => []
	};
	if ($params->{fasta} =~ m/[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}/) {
		my $shockurl = $self->_shockurl();
		if (defined($params->{shockurl})) {
			$shockurl = $params->{shockurl};
		}
		my $output = Bio::KBase::ObjectAPI::utilities::runexecutable("curl -X GET ".$shockurl."/node/".$params->{fasta}."?download");
		$params->{fasta} = join("\n",@{$output});
	}
	$params->{fasta} =~ s/\>(.+)\n/>$1\|\|\|/g;
	$params->{fasta} =~ s/\n//g;
	my $array = [split(/\>/,$params->{fasta})];
	for (my $i=0; $i < @{$array}; $i++) {
		if (length($array->[$i]) > 0) {
			my $subarray = [split(/\|\|\|/,$array->[$i])];
			if (@{$subarray} == 2) {
			    # This isn't strictly a standard but it gets it right when you download from RAST or the SEED at least (and probably genbank too)).
			    my $description = "unknown";
			    if( $subarray->[0] =~ /.*?\s(.+)/ ) {
					$description = $1;
			    }
			    my $contigobject = {
					id => $subarray->[0],
					name => $subarray->[0],
					"length" => length($subarray->[1]),
					md5 => Digest::MD5::md5_hex($subarray->[1]),
					sequence => $subarray->[1],
					description => $description
				};
				if ($fieldname eq "proteins") {
					$contigobject->{protein_families} = [];
					$contigobject->{aliases} = [];
					$contigobject->{annotations} = [];
					$contigobject->{function} = $description;
				} else {
					$contigobject->{name} = $subarray->[0];
					$contigobject->{description} = $description;
				}
				push(@{$object->{$fieldname}},$contigobject);
 			}
		}
	}
	$object->{$fieldname} = [sort { $a->{sequence} <=> $b->{sequence} } @{$object->{$fieldname}}];
	my $str = "";
	for (my $i=0; $i < @{$object->{$fieldname}}; $i++) {
		if (length($str) > 0) {
			$str .= ";";
		}
		$str .= $object->{$fieldname}->[$i]->{sequence};
	}
	$object->{md5} = Digest::MD5::md5_hex($str);
	$object->{id} = $self->_register_kb_id($prefix,$object->{md5},"md5hash");
	if (!defined($object->{source_id})) {
		$object->{source_id} = $object->{id};
		$object->{source} = "KBase";
	}
	if (!defined($params->{uid})) {
		$params->{uid} = $object->{id};
	}
	if (!defined($object->{name})) {
		$object->{name} = $object->{id};
	}
	my $class = "Bio::KBase::ObjectAPI::KBaseGenomes::".$type;
	$object = $class->new($object);
	$object->parent($self->_KBaseStore());
	return $self->_save_msobject($object,$type,$params->{workspace},$params->{uid});	
}

=head3 _register_kb_id

Definition:
	string kbid = $self->_register_kb_id(string prefix,string extid,string extidtype);
Description:
	Registers and returns a kbase ID
		
=cut
sub _register_kb_id {
	my($self,$prefix,$extid,$extidtype) = @_;
	my $output = $self->_idServer()->register_ids($prefix,$extidtype,[$extid]);
	return $output->{$extid};
}

=head3 _assess_confidence

Definition:
	0/1 = $self->_assess_confidence(string type,float threshold,float confidence);
Description:
	Returns 1 if the confidence is sufficient, 0 otherwise
		
=cut
sub _assess_confidence {
	my($self,$type,$thresh,$conf) = @_;
	if ($thresh == 0) {
		return 1;	
	}
	if ($type eq "blast" || $type eq "blat") {
		if ($conf < $thresh) {
			return 1;
		}
		return 0;
	}
	if ($conf > $thresh) {
		return 1;
	}
	return 0;
}

=head3 _buildGenomeFromFunctions

Definition:
	Bio::KBase::ObjectAPI::KBaseGenomes::Genome = $self->_buildGenomeFromFunctions();
Description:
	Returns 1 if the confidence is sufficient, 0 otherwise
		
=cut
sub _buildGenomeFromFunctions {
	my($self,$id,$functions,$name) = @_;
	my $genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new({
		id => $id,
		scientific_name => $name,
		domain => "Bacteria",
		genetic_code => 11,
		dna_size => 0,
		num_contigs => 0,
		contig_lengths => [],
		contig_ids => [],
		source => "KBase",
		source_id => $id,
		md5 => "",
		taxonomy => "Bacteria",
		gc_content => 0,
		complete => 0,
		publications => [],
		features => [],
    });
    my $count = 0;
    foreach my $function (keys(%{$functions})) {
    	$count++;
    	$genomeObj->add("features",{
    		id => $id.".peg.".$count,
			function => $function,
			type => "peg",
			publications => [],
			subsystems => [],
			protein_families => [],
			aliases => [],
			annotations => [],
			subsystem_data => [],
			regulon_data => [],
			atomic_regulons => [],
			coexpressed_fids => [],
			co_occurring_fids => [],
			location => []
  		});
    }
	return $genomeObj;
}

=head3 _genome_to_model

Definition:
	Bio::KBase::ObjectAPI::KBaseFBA::FBAModel = $self->_genome_to_model(Bio::KBase::ObjectAPI::KBaseGenomes::Genome);
Description:
	Builds model from genome
		
=cut
sub _genome_to_model {
	my($self,$genome,$mdlid,$params) = @_;
    #Retrieving template model
    my $template;
    if (defined($params->{templatemodel})) {
    	$template = $self->_get_msobject("ModelTemplate",$params->{templatemodel_workspace},$params->{templatemodel});
    } elsif ($params->{coremodel} == 1) {
    	$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","CoreModelTemplate");
    } elsif ($genome->domain() eq "Plant") {
    	$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","PlantModelTemplate");
	} else {
		my $class = $self->_classify_genome($genome);
		if ($class eq "Gram positive") {
    		$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramPosModelTemplate");
    	} elsif ($class eq "Gram negative") {
    		$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramNegModelTemplate");
    	} elsif ($class eq "Plant") {
    		$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","PlantModelTemplate");
    	}
    }
    if (!defined($template)) {
    	$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramPosModelTemplate");
    }
    #Building the model
    my $mdl = $template->buildModel({
	    genome => $genome,
	    modelid => $mdlid,
	    fulldb => $params->{fulldb}
	});
	return $mdl;
}

=head3 _annotate_genome

Definition:
	Genome = $self->_annotate_genome(Genome genome,AnnotationParameters parameters);
Description:
	Returns genome with annotated genes
		
=cut
sub _annotate_genome {
	my($self,$genome,$parameters) = @_;
	$parameters = $self->_validateargs($parameters,[],{
		call_genes => 0,
		annotate_genes => 1,
	});
	my $gaserv = $self->_gaserv();
	my $genomeTO = $genome->genome_typed_object();
	if( $genomeTO->{domain} eq "Plant" ){
	    $genomeTO = $gaserv->annotate_proteins_kmer_v1($genomeTO,{dataset_name=>"Release70",kmer_size=>8});
	} elsif (($parameters->{call_genes} == 1 || @{$genomeTO->{features}} == 0) && @{$genomeTO->{contigs}} > 0) {
		$genomeTO = $gaserv->annotate_genome($genomeTO);
	} elsif ($parameters->{annotate_genes} == 1) {
		$genomeTO = $gaserv->annotate_proteins($genomeTO);
	}
	foreach my $gene (@{$genomeTO->{features}}) {
		my $feature = $genome->getObject("features",$gene->{id});
		if (!defined($feature)) {
			$genome->add("features",{
				id => $gene->{id},
				function => $gene->{function},
				type => $gene->{type},
				protein_translation => $gene->{protein_translation},
				protein_translation_length => length($gene->{protein_translation}),
  				dna_sequence_length => 3*$gene->{protein_translation_length},
  				md5 => Digest::MD5::md5_hex($gene->{protein_translation}),
				location => $gene->{location},
				publications => [],
				subsystems => [],
				protein_families => [],
				aliases => [],
				annotations => [],
				subsystem_data => [],
				regulon_data => [],
				atomic_regulons => [],
				coexpressed_fids => [],
				co_occurring_fids => [],
			});
		} else {
		    if($genomeTO->{domain} eq "Plant"){
			if (defined($gene->{function})) {
			    $feature->function($gene->{function});
			}
			next;
		    }
			$feature->id($gene->{id});
			if (defined($gene->{function})) {
				$feature->function($gene->{function});
			}
			if (defined($gene->{protein_translation})) {
				$feature->protein_translation($gene->{protein_translation});
				$feature->protein_translation_length(length($gene->{protein_translation}));
				$feature->dna_sequence_length(3*$gene->{protein_translation_length});
				$feature->md5(Digest::MD5::md5_hex($gene->{protein_translation}));
			}
			if (defined($gene->{type})) {
				$feature->type($gene->{type});
			}
			if (defined($gene->{location})) {
				$feature->location($gene->{location});
			}
		}
	}
	return $genome;
}

=head3 _classify_genome

Definition:
	Genome = $self->_classify_genome(Genome genome);
Description:
	Returns the cell wall classification for genome
		
=cut
sub _classify_genome {
	my($self,$genome) = @_;
	if (!defined($self->{_classifierdata})) {
	    my ($fh1, $classifierFile) = File::Temp::tempfile();
	    close($fh1);
	    my $status = LWP::Simple::getstore("http://bioseed.mcs.anl.gov/~chenry/ModelSEED/classifier.txt", $classifierFile);
	    $self->_error("Unable to fetch cell wall classifier data!") unless($status == 200);
		my $data = Bio::KBase::ObjectAPI::utilities::LOADFILE($classifierFile);
		my $headings = [split(/\t/,$data->[0])];
		my $popprob = [split(/\t/,$data->[1])];
		for (my $i=1; $i < @{$headings}; $i++) {
			$self->{_classifierdata}->{classifierClassifications}->{$headings->[$i]} = {
				name => $headings->[$i],
				populationProbability => $popprob->[$i]
			};
		}
		my $cfRoleHash = {};
		for (my $i=2;$i < @{$data}; $i++) {
			my $row = [split(/\t/,$data->[$i])];
			my $searchrole = Bio::KBase::ObjectAPI::utilities::convertRoleToSearchRole($row->[0]);
			$self->{_classifierdata}->{classifierRoles}->{$searchrole} = {
				classificationProbabilities => {},
				role => $row->[0]
			};
			for (my $j=1; $j < @{$headings}; $j++) {
				$self->{_classifierdata}->{classifierRoles}->{$searchrole}->{classificationProbabilities}->{$headings->[$j]} = $row->[$j];
			}
		}
	}
	my $scores = {};
	my $sum = 0;
	foreach my $class (keys(%{$self->{_classifierdata}->{classifierClassifications}})) {
		$scores->{$class} = 0;
		$sum += $self->{_classifierdata}->{classifierClassifications}->{$class}->{populationProbability};
	}
	my $features = $genome->features();
	for (my $i=0; $i < @{$features}; $i++) {
		my $feature = $features->[$i];
		my $roles = $feature->roles();
		foreach my $role (@{$roles}) {
			my $searchrole = Bio::KBase::ObjectAPI::utilities::convertRoleToSearchRole($role);
			if (defined($self->{_classifierdata}->{classifierRoles}->{$searchrole})) {
				foreach my $class (keys(%{$self->{_classifierdata}->{classifierClassifications}})) {
					$scores->{$class} += $self->{_classifierdata}->{classifierRoles}->{$searchrole}->{classificationProbabilities}->{$class};
				}
			}
		}
	}
	my $largest;
	my $largestClass;
	foreach my $class (keys(%{$self->{_classifierdata}->{classifierClassifications}})) {
		$scores->{$class} += log($self->{_classifierdata}->{classifierClassifications}->{$class}->{populationProbability}/$sum);
		if (!defined($largest)) {
			$largest = $scores->{$class};
			$largestClass = $class;
		} elsif ($largest > $scores->{$class}) {
			$largest = $scores->{$class};
			$largestClass = $class;
		}
	}
	return $largestClass;
}

=head3 _parse_SBML

Definition:
	? = $self->_parse_SBML(?);
Description:
	?
		
=cut
sub _parse_SBML {
	my($self,$genome,$bio,$sbml) = @_;
	#Parsing XML
	require "XML/DOM.pm";
	my $parser = new XML::DOM::Parser;
	my $doc = $parser->parse($sbml);
	#Parsing compartments
    my $cmpts = [$doc->getElementsByTagName("compartment")];
    my $cmptrans;
    my $nonexactcmptrans = {
    	xtra => "e",
    	wall => "w",
    	peri => "p",
    	cyto => "c",
    	retic => "r",
    	lys => "l",
    	nucl => "n",
    	cholor => "h",
    	mito => "m",
    	perox => "x",
    	vacu => "v",
    	plast => "d"
    };
    foreach my $cmpt (@$cmpts){
    	my $cmp_SEED_id;
    	my $cmpid;
    	my $cmpname;
    	foreach my $attr ($cmpt->getAttributes()->getValues()) {
    		my $name = $attr->getName();
    		my $value = $attr->getValue();
    		if ($name eq "id") {
    			$cmpid = $value;
    		} elsif ($name eq "name") {
    			$cmpname = $value;
    		}
    	}
    	my $cmp = $bio->searchForCompartment($cmpid);
    	if (defined($cmp)) {
    		$cmp_SEED_id = $cmp->id();
    	} else {
    		foreach my $term (keys(%{$nonexactcmptrans})) {
    			if ($cmpid =~ m/$term/i) {
    				$cmp_SEED_id = $nonexactcmptrans->{$term};
    			} elsif ($cmpname =~ m/$term/i) {
    				$cmp_SEED_id = $nonexactcmptrans->{$term};
    			}
    		} 
    	}
    	if (!defined($cmp_SEED_id)) {
    		Bio::KBase::ObjectAPI::utilities::ERROR("Unrecognized compartment '".$cmpid."' in SBML file!");
    	} else {
    		$cmptrans->{$cmpid} = $cmp_SEED_id;
    	}
    }
	#Parsing compounds
	my $compounds;
    my $cpds = [$doc->getElementsByTagName("species")];
    my $cpdhash = {};
    my $cpdidhash = {};
    foreach my $cpd (@$cpds){
    	my $formula = "Unknown";
    	my $charge = "0";
    	my $sbmlid = "0";
    	my $compartment = "c";
    	my $name;
    	my $id;
    	my $boundary = 0;
    	foreach my $attr ($cpd->getAttributes()->getValues()) {
    		my $nm = $attr->getName();
    		my $value = $attr->getValue();
    		if ($nm eq "id") {
    			$sbmlid = $value;
    			$id = $value;
    			if ($id =~ m/^M_(.+)/) {
    				$id = $1;
    			}
    			if ($id =~ m/(.+)_([a-z])$/) {
    				$id = $1;
    			}
    		} elsif ($nm eq "name") {
    			$name = $value;
    			if ($name =~ m/^M_(.+)/) {
    				$name = $1;
    			}
    			if ($name =~ m/(.+)_([A-Z0123456789]+)$/) {
    				$name = $1;
    				$formula = $2;
    			}
    		} elsif ($nm eq "compartment") {
    			$compartment = $value;
    			if (defined($cmptrans->{$compartment})) {
    				$compartment = $cmptrans->{$compartment};
    			}
    		} elsif ($nm eq "charge") {
    			$charge = $value;
    		} elsif ($nm eq "formula") {
    			$formula = $value;
    		} elsif ($nm eq "boundaryCondition" && $value =~ m/true/i) {
    			$boundary = 1;
    		}
    	}
    	if (!defined($name)) {
    		$name = $id;
    	}
    	if (!defined($cpdidhash->{$id})) {
    		$cpdidhash->{$id} = [$id,$charge,$formula,lc($name),undef];
    		push(@{$compounds},$cpdidhash->{$id});
    	}
    	$cpdhash->{$sbmlid} = [$id,$compartment,$boundary];
    	
    }
    #Parsing reactions
    my $reactions;
    my $rxns = [$doc->getElementsByTagName("reaction")];
    foreach my $rxn (@$rxns){
    	my $id = undef;
    	my $name = undef;
    	my $direction = "=";
    	my $reactants;
    	my $products;
    	my $compartment = "c";
    	my $gpr;
    	my $pathway;
    	my $enzyme;
    	my $protein = "Unknown";
    	foreach my $attr ($rxn->getAttributes()->getValues()) {
    		my $nm = $attr->getName();
    		my $value = $attr->getValue();
    		if ($nm eq "id") {
    			if ($value =~ m/^R_(.+)/) {
    				$value = $1;
    			}
    			$id = $value;
    		} elsif ($nm eq "name") {
    			if ($value =~ m/^R_(.+)/) {
    				$value = $1;
    			}
    			$value =~ s/_/-/g;
    			$name = $value;
    		} elsif ($nm eq "reversible") {
    			if ($value ne "true") {
    				$direction = ">";
    			}
    		} else {
    			#print $nm.":".$value."\n";
    		}
    	}
    	foreach my $node ($rxn->getElementsByTagName("*",0)){
    		if ($node->getNodeName() eq "listOfReactants" || $node->getNodeName() eq "listOfProducts") {
    			foreach my $species ($node->getElementsByTagName("speciesReference",0)){
    				my $spec;
    				my $stoich = 1;
    				my $boundary = 0;
    				foreach my $attr ($species->getAttributes()->getValues()) {
    					if ($attr->getName() eq "species") {
    						$spec = $attr->getValue();
    						if (defined($cpdhash->{$spec})) {
    							$boundary = $cpdhash->{$spec}->[2];
    							$spec = $cpdhash->{$spec}->[0]."[".$cpdhash->{$spec}->[1]."]";
    						}
    					} elsif ($attr->getName() eq "stoichiometry") {
    						$stoich = $attr->getValue();
    					}
    				}
    				if ($boundary == 0) {
	    				if ($node->getNodeName() eq "listOfReactants") {
	    					if (length($reactants) > 0) {
	    						$reactants .= " + ";
	    					}
	    					$reactants .= "(".$stoich.") ".$spec;
	    				} else {
	    					if (length($products) > 0) {
	    						$products .= " + ";
	    					}
	    					$products .= "(".$stoich.") ".$spec;
	    				}
    				}
    			}	
    		} elsif ($node->getNodeName() eq "notes") {
    			foreach my $html ($node->getElementsByTagName("*",0)){
    				my $text = $html->getFirstChild()->getNodeValue();
					if ($text =~ m/GENE_ASSOCIATION:\s*(.+)/) {
						$gpr = $1;
					} elsif ($text =~ m/PROTEIN_ASSOCIATION:\s*/) {
						$protein = $1;
					} elsif ($text =~ m/PROTEIN_CLASS:\s*(.+)/) {
						my $array = [split(/\s/,$1)];
						$enzyme = $array->[0];
					} elsif ($text =~ m/SUBSYSTEM:\s*(.+)/) {
						$pathway = $1;
						$pathway =~ s/^S_//;
					}
    			}
    		}
    	}
    	if (!defined($name)) {
    		$name = $id;
    	}
    	push(@{$reactions},[$id,$direction,$compartment,$gpr,$name,$enzyme,$pathway,undef,$reactants." => ".$products]);
    }
    return ($reactions,$compounds);
}

=head3 _cdd_database

Definition:
	? = $self->_cdd_database(?);
Description:
	?
		
=cut
sub _cdd_database {
	return "/vol/model-prod/kbase/deploy/CDD/data/";
}

=head3 _cdd_temp

Definition:
	? = $self->_cdd_temp(?);
Description:
	?
		
=cut
sub _cdd_temp {
	return "/vol/model-prod/kbase/deploy/CDD/tmp/";
}

=head3 _update_CDD_database

Definition:
	? = $self->_update_CDD_database(?);
Description:
	?
		
=cut
sub _update_CDD_database {
	my($self) = @_;
	my $cdd_url = 'ftp://ftp.ncbi.nih.gov/pub/mmdb/cdd/cdd.tar.gz';
	my $cddid_url = 'ftp://ftp.ncbi.nih.gov/pub/mmdb/cdd/cddid.tbl.gz';
	my $cdd_file = basename($cdd_url);
	my $cddid_file = basename($cddid_url);

	my @format_cmds = (
		'makeprofiledb -title Pfam.v.26.0 -in Pfam.pn -out Pfam -threshold 9.82 -scale 100.0 -dbtype rps -index true',
		'makeprofiledb -title COG.v.1.0 -in Cog.pn -out Cog -threshold 9.82 -scale 100.0 -dbtype rps -index true',
		'makeprofiledb -title KOG.v.1.0 -in Kog.pn -out Kog -threshold 9.82 -scale 100.0 -dbtype rps -index true',
		'makeprofiledb -title CDD.v.3.10 -in Cdd.pn -out Cdd -threshold 9.82 -scale 100.0 -dbtype rps -index true',
		'makeprofiledb -title PRK.v.6.00 -in Prk.pn -out Prk -threshold 9.82 -scale 100.0 -dbtype rps -index true',
	);

    my $rc;
    my $cdd_tmp = $self->_cdd_temp();
    if (! -s "$cdd_tmp/$cdd_file") {
		$rc = system("curl", "-L", "-o", "$cdd_tmp/$cdd_file", $cdd_url);
		$rc == 0 or die "Error downloading $cdd_url to $cdd_tmp/$cdd_file";
    }
    if (! -s "$cdd_tmp/$cddid_file") {
		$rc = system("curl", "-L", "-o", "$cdd_tmp/$cddid_file", $cddid_url);
		$rc == 0 or die "Error downloading $cddid_url to $cdd_tmp/$cddid_file";
    }


	chdir($self->_cdd_database()) or die "cannot chdir: $!";
	if (! -f "Cdd.pn") {
	    $rc = system(("tar", "-z", "-x", "-f", "$cdd_tmp/$cdd_file"));
    	$rc == 0 or die "tar failed!";
	}
	
	$rc = system(("gunzip < $cdd_tmp/$cddid_file > cddid.tbl"));
    $rc == 0 or die "gunzip failed!";
	
	$rc = system(("formatrpsdb", "-t", "Cdd", "-i", "Cdd.pn", "-o", "T", "-f", "9.82", "-n", "Cdd", "-S", "100.0"));
    $rc == 0 or die "formatrpsdb failed!";
}

=head3 _compute_CDD

Definition:
	? = $self->_compute_CDD(?);
Description:
	?
		
=cut

sub _compute_CDD {
	my($self,$proteins,$update) = @_;
	if (!-e $self->_cdd_database()."/Cdd.pn" || $update == 1) {
		$self->_update_CDD_database();
	}
	my $output;
	my $input;
	foreach my $protein (keys(%{$proteins})) {
		my $seq = $proteins->{$protein};
		$input .= ">$protein\n" . $seq . "\n";
	}
	my @cmd = ('rpsblast', "-d", $self->_cdd_database()."/Cdd", "-F", "T", "-e", "0.01", "-m", "9");
	my $output;
    open(my $fh, "> ".$self->_cdd_temp()."tempinput.txt");
    print $fh $input;
    close $fh;
    system(\@cmd, '<', $self->_cdd_temp()."tempinput.txt", '>', $self->_cdd_temp()."tempoutput.txt");
    open($fh, "< ".$self->_cdd_temp()."tempoutput.txt");
   	my $output;
   	while (my $line = <$fh>) {
   		$output .= $line;
   	}
    close $fh;
	for my $l (split(/\n/, $output)){
        next if $l =~ /^#/;
        my($qry, $subj, @x) = split(/\t/, $l);
		$subj =~ s/^gnl\|CDD\|//;
		print join("\t", $subj, $qry, @x), "\n";
    }
}

=head3 _compute_eflux_bounds

Definition:
	scores = $self->_classify_genome(FBAModel model, series_id series id, sample_id picked_sample_id, workspace_id ws_name);
Description:
	Returns eflux expression scores for each reaction.
		
=cut
sub _compute_eflux_scores {
	my($self,$model,$series_id,$picked_sample_id,$ws_name) = @_;    
	my $ws = $self->_KBaseStore()->workspace();

	my $samples;
	if (defined($series_id)) {
		# "Improved" E-FLux
		my $getparams = {
			id => $series_id,
			type => "KBaseExpression.ExpressionSeries",
			workspace => $ws_name,
		};
		my $series = $ws->get_object($getparams);
		if (!exists $series->{"data"}->{"genome_expression_sample_ids_map"}->{$model->genome()->id()}) {
			warn("Genome does not match between Model and Gene Expression Data.\n");
		} 
		my $sample_refs = $series->{"data"}->{"genome_expression_sample_ids_map"}->{$model->genome()->id()};    
		$samples = $ws->get_objects([map {{ref => $_}} @$sample_refs]);
	} else {
		# "Original" E-Flux
		my $getparams = {
			id => $picked_sample_id,
			type => "KBaseExpression.ExpressionSample",
			workspace => $ws_name
		};
		my $sample = $ws->get_object($getparams);
		$samples = [$sample];
	}
    # Re-index them by reactions rather than samples
    # And checks if specified sample exists within the series
    my $scores_collection = {}; # expression scores for each reaction.
    my $unknown = {};

    my $matched = 0;    
    foreach my $sample (@$samples) {
	$matched = 1 if ($sample->{"data"}->{"id"} eq $picked_sample_id);	
	my $mdlrxns = $model->modelreactions();
	foreach my $mdlrxn (@{$mdlrxns}) {			
	    $scores_collection->{$mdlrxn->id()}->{$sample->{"data"}->{"id"}} = 0;
	    $unknown->{$mdlrxn->id()} = 1 if (@{$mdlrxn->modelReactionProteins()} == 0);
	    # OR, meaning there may be isozymes for this reaction. Add their expression scores.
	    foreach my $prot (@{$mdlrxn->modelReactionProteins()}) {
		# AND, meaning each isozyme may have multiple subunits.  Take minimum expression score.
		my $prot_score = POSIX::FLT_MAX;
		foreach my $subunit (@{$prot->modelReactionProteinSubunits()}) {
		    if (@{$subunit->features()} == 0) {
			next; # Not last, since there may be scores for other subunits
		    }
		    # OR, meaning there may be isozymes for the subunit. Add their expression scores.
		    my $subunit_score = 0;
		    foreach my $feature (@{$subunit->features()}) {
			if (!exists $sample->{"data"}->{"expression_levels"}->{$feature->id()}) {
			    # exp level is Unknown, so we can't compute a score for the subunit
			    $subunit_score = POSIX::FLT_MAX;
			    last;
			}
			$subunit_score += $sample->{"data"}->{"expression_levels"}->{$feature->id};
		    }		    
		    $prot_score = ($prot_score < $subunit_score) ? $prot_score : $subunit_score;
		}
		if ($prot_score == POSIX::FLT_MAX) {
		    # there was insufficient information to compute a protein score
		    $unknown->{$mdlrxn->id()} = 1;
		    last;
		}
		$scores_collection->{$mdlrxn->id()}->{$sample->{"data"}->{"id"}} += $prot_score;		    
	    }
	}
    }

    if (!$matched) {
    	$self->_error("Sample $picked_sample_id does not exist in series $series_id in workspace $ws_name!");
    }

    # debug
    warn "Number of reactions with unavailable expression scores is " . (scalar keys %$unknown) ." out of ". (scalar keys %$scores_collection)."\n";

    my $scores_for_picked_sample = {};
    my $max_score;
    if (!defined $series_id) {
    	# "original eflux"
    	$max_score = (sort {$b <=> $a} map {$scores_collection->{$_}->{$picked_sample_id}} keys %$scores_collection)[0]
    }
    foreach my $rxn_id (keys %$scores_collection) {
	if (exists $unknown->{$rxn_id}) {
	    $scores_for_picked_sample->{$rxn_id} = 1; # i.e., 100% flux bounds when expression score is not available
	} else {
		if (defined $series_id) {
			# Take max expression score across all samples for this reaction
			$max_score = (sort {$b <=> $a } map {$scores_collection->{$rxn_id}->{$_}} keys $scores_collection->{$rxn_id})[0];
		}
	    # Then normalize the picked sample's expression score by the max
	    $scores_for_picked_sample->{$rxn_id} = $scores_collection->{$rxn_id}->{$picked_sample_id} / $max_score;
	}
    }
    return $scores_for_picked_sample;      
}

=head3 _add_eflux_bounds

Definition:
	(Float ) = $self->_add_eflux_bounds(FBA, Model, Eflux-scores)
Description:
	Add reaction bounds computed by eflux.
	Return objective value for later comparison.	
=cut
sub _add_eflux_bounds {
    my ($self, $fba, $model, $eflux_scores, $samplename) = @_;

    my $clone = $fba->cloneObject();
    $clone->parent($fba->parent());
    $clone->objectiveConstraintFraction(0.9); # According to the paper.
    $clone->fva(1);
    my $objectiveValue = $clone->runFBA();
    my $fluxes = $clone->FBAReactionVariables();
    my $essentialreactions = {headings => ["", "rxn_id", "definition"," eflux_score","lower_bound","upper_bound"]}; # debug
    foreach my $flux (@{$fluxes}) {
    	#debug for essential reactions.
	if ($flux->max ()< 0 || $flux->min() > 0) {
		push @{$essentialreactions->{data}}, [
		$flux->modelreaction()->id(), 
		$flux->modelreaction()->definition(),
		$eflux_scores->{$flux->modelreaction()->id()},
		$flux->min() * $eflux_scores->{$flux->modelreaction()->id()},
		$flux->max() * $eflux_scores->{$flux->modelreaction()->id()},
		];
	}
    	# No constraint for transporters.
    	next if ($flux->modelreaction()->isTransporter());

    	# Reset the flux bound to the e-flux percentage of the maximum computed by FVA,
    	# but make sure that 0 is within the bounds.
    	my ($upper, $lower) = (0,0);
    	if ($flux->max() > 0) {
    		$upper = $flux->max() * $eflux_scores->{$flux->modelreaction()->id()};
    	}
    	if ($flux->min() < 0) {
    		$lower = $flux->min() * $eflux_scores->{$flux->modelreaction()->id()};
    	}


    	$fba->add("FBAReactionBounds",{modelreaction_ref => $flux->modelreaction_ref(),
    		variableType=> $flux->variableType,
    		upperBound => $upper,
    		lowerBound => $lower,
    		});
	}

    # debug
    Bio::KBase::ObjectAPI::utilities::PRINTTABLE("essentialreactions.".$fba->media()->name().".$samplename.tbl", $essentialreactions, "\t");

    return $objectiveValue;
}

sub _process_reactions_list {
	my ($self, $reactions,$compounds) = @_;
	my $translation = {};
    for (my $i=0; $i < @{$compounds}; $i++) {
    	my $cpd = $compounds->[$i];
    	my $id = $cpd->[0];
    	if ($id =~ m/[^\w]/) {
    		$cpd->[0] =~ s/[^\w]/_/g;
    	}
    	if ($id =~ m/-/) {
    		$cpd->[0] =~ s/-/_/g;
    	}
    	$translation->{$id} = $cpd->[0];
    }
    for (my $i=0; $i < @{$reactions}; $i++) {
    	my $rxn = $reactions->[$i];
    	$rxn->[0] =~ s/[^\w]/_/g;
    	if (defined($rxn->[8])) {
    		if ($rxn->[8] =~ m/^\[([A-Za-z])\]\s*:\s*(.+)/) {
    			$rxn->[2] = lc($1);
    			$rxn->[8] = $2;
    		}
    		my $eqn = "| ".$rxn->[8]." |";
    		foreach my $cpd (keys(%{$translation})) {
    			if (index($eqn,$cpd) >= 0 && $cpd ne $translation->{$cpd}) {
    				my $origcpd = $cpd;
    				$cpd =~ s/\+/\\+/g;
    				$cpd =~ s/\(/\\(/g;
    				$cpd =~ s/\)/\\)/g;
    				my $array = [split(/\s$cpd\s/,$eqn)];
    				$eqn = join(" ".$translation->{$origcpd}." ",@{$array});
    				$array = [split(/\s$cpd\[/,$eqn)];
    				$eqn = join(" ".$translation->{$origcpd}."[",@{$array});
    			}
    		}
    		$eqn =~ s/^\|\s//;
    		$eqn =~ s/\s\|$//;
    		while ($eqn =~ m/\[([A-Z])\]/) {
    			my $reqplace = "[".lc($1)."]";
    			$eqn =~ s/\[[A-Z]\]/$reqplace/;
    		}
    		if ($eqn =~ m/<[-=]+>/) {
    			if (!defined($rxn->[1])) {
    				$rxn->[1] = "=";
    			}
    		} elsif ($eqn =~ m/[-=]+>/) {
    			if (!defined($rxn->[1])) {
    				$rxn->[1] = ">";
    			}
    		} elsif ($eqn =~ m/<[-=]+/) {
    			if (!defined($rxn->[1])) {
    				$rxn->[1] = "<";
    			}
    		}
    		$rxn->[8] = $eqn;
    	}
    }
	my $compoundhash = {};
	for (my $i=0; $i < @{$compounds}; $i++) {
		$compoundhash->{$compounds->[$i]->[0]} = $compounds->[$i];
	}
	return ($reactions,$compoundhash);
}

#END_HEADER

sub new
{
    my($class, @args) = @_;
    my $self = {
    };
    bless $self, $class;
    #BEGIN_CONSTRUCTOR
    my $options = $args[0];
	$ENV{KB_NO_FILE_ENVIRONMENT} = 1;
	
    my $params;
    $self->{_defaultJobState} = "queued";
    $self->{_accounttype} = "kbase";
    $self->{'_awe-url'} = "http://140.221.85.54:7080";
    $self->{'_shock-url'} = "http://140.221.85.54:7445";
    $self->{_jobqueue} = "workspace";
    $self->{'_fba-url'} = "";
    Bio::KBase::ObjectAPI::utilities::ID_SERVER_URL("http://kbase.us/services/idserver");
    $self->{'_jobserver-url'} = "http://kbase.us/services/workspace";
    $self->{'_gaserver-url'} = "http://kbase.us/services/genome_annotation";
    $self->{'_mssserver-url'} = "http://bio-data-1.mcs.anl.gov/services/ms_fba";
    $self->{"_probanno-url"} = "http://localhost:7073";
    $self->{"_workspace-url"} = "http://kbase.us/services/ws";
    my $paramlist = [qw(fbajobcache awe-url shock-url jobqueue gaserver-url jobserver-url fbajobdir mfatoolkitbin fba-url probanno-url mssserver-url accounttype workspace-url defaultJobState idserver-url)];

    # so it looks like params is created by looping over the config object
    # if deployment.cfg exists

    # the keys in the params hash are the same as in the config obuject 
    # except the block name from the config file is ommitted.

    # the block name is picked up from KB_SERVICE_NAME. this has to be set
    # in the start_service script as an environment variable.

    # looping over a set of predefined set of parameter keys, see if there
    # is a value for that key in the config object
    if ((my $e = $ENV{KB_DEPLOYMENT_CONFIG}) && -e $ENV{KB_DEPLOYMENT_CONFIG}) {
		my $service = $ENV{KB_SERVICE_NAME};
		if (!defined($service)) {
			$service = "fbaModelService";
		}
		if (defined($service)) {
			my $c = Config::Simple->new();
			$c->read($e);
			for my $p (@{$paramlist}) {
			  	my $v = $c->param("$service.$p");
			    if ($v) {
					$params->{$p} = $v;
			    }
			}
		}
    }

    # now, we have the options hash. THis is passed into the constructor as a
    # parameter to new(). If a key from the predefined set of parameter keys
    # is found in the incoming hash, let the associated value override what
    # was previously assigned to the params hash from the config object.

	print STDERR "\nServer config values:\n";
    for my $p (@{$paramlist}) {
  		if (defined($options->{$p})) {
			$params->{$p} = $options->{$p};
        }
        print STDERR $p."\t".$params->{$p}."\n";
    }

    # now, if params has one of the predefined set of parameter keys,
    # use that value to override object instance variable values. The
    # default object instance variable values were set above.
	if (defined($params->{mfatoolkitbin})) {
		Bio::KBase::ObjectAPI::utilities::MFATOOLKIT_BINARY($params->{mfatoolkitbin});
	}
	if (defined($params->{fbajobdir})) {
		Bio::KBase::ObjectAPI::utilities::MFATOOLKIT_JOB_DIRECTORY($params->{fbajobdir});
	}
	if (defined($params->{fbajobcache})) {
		Bio::KBase::ObjectAPI::utilities::FinalJobCache($params->{fbajobcache});
	}
    if (defined $params->{accounttype}) {
		$self->{_accounttype} = $params->{accounttype};
    }
    if (defined $params->{defaultJobState}) {
		$self->{_defaultJobState} = $params->{defaultJobState};
    }
    if (defined $params->{'gaserver-url'}) {
    		$self->{'_gaserver-url'} = $params->{'gaserver-url'};
    }
    if (defined $params->{'fba-url'}) {
    		$self->{'_fba-url'} = $params->{'fba-url'};
    }
    if (defined $params->{'idserver-url'}) {
    	Bio::KBase::ObjectAPI::utilities::ID_SERVER_URL($params->{'idserver-url'});
    }
    if (defined $params->{'jobserver-url'}) {
    		$self->{'_jobserver-url'} = $params->{'jobserver-url'};
    }
    if (defined $params->{'mssserver-url'}) {
    		$self->{'_mssserver-url'} = $params->{'mssserver-url'};
    }
    if (defined $params->{'workspace-url'}) {
    		$self->{'_workspace-url'} = $params->{'workspace-url'};
    }
    if (defined $params->{'probanno-url'}) {
    		$self->{'_probanno-url'} = $params->{'probanno-url'};
    }
    if (defined $params->{'jobqueue'}) {
    		$self->{'_jobqueue'} = $params->{'jobqueue'};
    }
    if (defined $params->{'shock-url'}) {
    		$self->{'_shock-url'} = $params->{'shock-url'};
    }
    if (defined $params->{'awe-url'}) {
    		$self->{'_awe-url'} = $params->{'awe-url'};
    }
    #This final condition allows one to specify a fully implemented workspace IMPL or CLIENT for use

    if (defined($options->{workspace})) {
    	$self->{_workspaceServiceOveride} = $options->{workspace};
    }
    if (defined($options->{verbose})) {
    	set_verbose(1);
    }
	$self->{_jobserver} = Bio::KBase::workspaceService::Client->new($self->{'_jobserver-url'});
    #END_CONSTRUCTOR

    if ($self->can('_init_instance'))
    {
	$self->_init_instance();
    }
    return $self;
}

=head1 METHODS



=head2 get_models

  $out_models = $obj->get_models($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_models_params
$out_models is a reference to a list where each element is an FBAModel
get_models_params is a reference to a hash where the following keys are defined:
	models has a value which is a reference to a list where each element is a fbamodel_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
fbamodel_id is a string
workspace_id is a string
FBAModel is a reference to a hash where the following keys are defined:
	id has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	map has a value which is a mapping_id
	map_workspace has a value which is a workspace_id
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	name has a value which is a string
	type has a value which is a string
	status has a value which is a string
	biomasses has a value which is a reference to a list where each element is a ModelBiomass
	compartments has a value which is a reference to a list where each element is a ModelCompartment
	reactions has a value which is a reference to a list where each element is a ModelReaction
	compounds has a value which is a reference to a list where each element is a ModelCompound
	fbas has a value which is a reference to a list where each element is an FBAMeta
	integrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
	unintegrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
	integrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta
	unintegrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta
genome_id is a string
mapping_id is a string
biochemistry_id is a string
ModelBiomass is a reference to a hash where the following keys are defined:
	id has a value which is a biomass_id
	name has a value which is a string
	definition has a value which is a string
	biomass_compounds has a value which is a reference to a list where each element is a BiomassCompound
biomass_id is a string
BiomassCompound is a reference to a list containing 3 items:
	0: (modelcompound) a modelcompound_id
	1: (coefficient) a float
	2: (name) a string
modelcompound_id is a string
ModelCompartment is a reference to a hash where the following keys are defined:
	id has a value which is a modelcompartment_id
	name has a value which is a string
	pH has a value which is a float
	potential has a value which is a float
	index has a value which is an int
modelcompartment_id is a string
ModelReaction is a reference to a hash where the following keys are defined:
	id has a value which is a modelreaction_id
	reaction has a value which is a reaction_id
	name has a value which is a string
	direction has a value which is a string
	equation has a value which is a string
	definition has a value which is a string
	gapfilled has a value which is a bool
	features has a value which is a reference to a list where each element is a feature_id
	compartment has a value which is a modelcompartment_id
modelreaction_id is a string
reaction_id is a string
bool is an int
feature_id is a string
ModelCompound is a reference to a hash where the following keys are defined:
	id has a value which is a modelcompound_id
	compound has a value which is a compound_id
	name has a value which is a string
	compartment has a value which is a modelcompartment_id
compound_id is a string
FBAMeta is a reference to a list containing 6 items:
	0: (id) a fba_id
	1: (workspace) a workspace_id
	2: (media) a media_id
	3: (media_workspace) a workspace_id
	4: (objective) a float
	5: (ko) a reference to a list where each element is a feature_id
fba_id is a string
media_id is a string
GapFillMeta is a reference to a list containing 6 items:
	0: (id) a gapfill_id
	1: (workspace) a workspace_id
	2: (media) a media_id
	3: (media_workspace) a workspace_id
	4: (done) a bool
	5: (ko) a reference to a list where each element is a feature_id
gapfill_id is a string
GapGenMeta is a reference to a list containing 6 items:
	0: (id) a gapgen_id
	1: (workspace) a workspace_id
	2: (media) a media_id
	3: (media_workspace) a workspace_id
	4: (done) a bool
	5: (ko) a reference to a list where each element is a feature_id
gapgen_id is a string

</pre>

=end html

=begin text

$input is a get_models_params
$out_models is a reference to a list where each element is an FBAModel
get_models_params is a reference to a hash where the following keys are defined:
	models has a value which is a reference to a list where each element is a fbamodel_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
fbamodel_id is a string
workspace_id is a string
FBAModel is a reference to a hash where the following keys are defined:
	id has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	map has a value which is a mapping_id
	map_workspace has a value which is a workspace_id
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	name has a value which is a string
	type has a value which is a string
	status has a value which is a string
	biomasses has a value which is a reference to a list where each element is a ModelBiomass
	compartments has a value which is a reference to a list where each element is a ModelCompartment
	reactions has a value which is a reference to a list where each element is a ModelReaction
	compounds has a value which is a reference to a list where each element is a ModelCompound
	fbas has a value which is a reference to a list where each element is an FBAMeta
	integrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
	unintegrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
	integrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta
	unintegrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta
genome_id is a string
mapping_id is a string
biochemistry_id is a string
ModelBiomass is a reference to a hash where the following keys are defined:
	id has a value which is a biomass_id
	name has a value which is a string
	definition has a value which is a string
	biomass_compounds has a value which is a reference to a list where each element is a BiomassCompound
biomass_id is a string
BiomassCompound is a reference to a list containing 3 items:
	0: (modelcompound) a modelcompound_id
	1: (coefficient) a float
	2: (name) a string
modelcompound_id is a string
ModelCompartment is a reference to a hash where the following keys are defined:
	id has a value which is a modelcompartment_id
	name has a value which is a string
	pH has a value which is a float
	potential has a value which is a float
	index has a value which is an int
modelcompartment_id is a string
ModelReaction is a reference to a hash where the following keys are defined:
	id has a value which is a modelreaction_id
	reaction has a value which is a reaction_id
	name has a value which is a string
	direction has a value which is a string
	equation has a value which is a string
	definition has a value which is a string
	gapfilled has a value which is a bool
	features has a value which is a reference to a list where each element is a feature_id
	compartment has a value which is a modelcompartment_id
modelreaction_id is a string
reaction_id is a string
bool is an int
feature_id is a string
ModelCompound is a reference to a hash where the following keys are defined:
	id has a value which is a modelcompound_id
	compound has a value which is a compound_id
	name has a value which is a string
	compartment has a value which is a modelcompartment_id
compound_id is a string
FBAMeta is a reference to a list containing 6 items:
	0: (id) a fba_id
	1: (workspace) a workspace_id
	2: (media) a media_id
	3: (media_workspace) a workspace_id
	4: (objective) a float
	5: (ko) a reference to a list where each element is a feature_id
fba_id is a string
media_id is a string
GapFillMeta is a reference to a list containing 6 items:
	0: (id) a gapfill_id
	1: (workspace) a workspace_id
	2: (media) a media_id
	3: (media_workspace) a workspace_id
	4: (done) a bool
	5: (ko) a reference to a list where each element is a feature_id
gapfill_id is a string
GapGenMeta is a reference to a list containing 6 items:
	0: (id) a gapgen_id
	1: (workspace) a workspace_id
	2: (media) a media_id
	3: (media_workspace) a workspace_id
	4: (done) a bool
	5: (ko) a reference to a list where each element is a feature_id
gapgen_id is a string


=end text



=item Description

Returns model data for input ids

=back

=cut

sub get_models
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_models:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_models');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_models);
    #BEGIN get_models
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["models","workspaces"],{});
    for (my $i=0; $i < @{$input->{models}}; $i++) {
    	my $id = $input->{models}->[$i];
    	my $ws = $input->{workspaces}->[$i];
    	my $model = $self->_get_msobject("FBAModel",$input->{workspaces}->[$i],$input->{models}->[$i]);
    	my $mdldata = {
    		id => $input->{models}->[$i],
    		genome_ref => $model->genome_ref(),
    		biochemistry_ref => $model->template()->biochemistry_ref(),
    		name => $model->name(),
    		type => $model->type(),
    		biomasses => [],
    		compartments => [],
    		reactions => [],
    		compounds => [],
    		fbas => [],
    		integrated_gapfillings => [],
    		unintegrated_gapfillings => [],
    		integrated_gapgenerations => [],
    		unintegrated_gapgenerations => []
    	};
    	#Creating model biomasses
    	foreach my $bio (@{$model->biomasses()}) {
    		my $biodata = {
    			id => $bio->id(),
    			name => $bio->name(),
    			definition => $bio->definition()
    		};
    		push(@{$mdldata->{biomasses}},$biodata);
    	}
    	#Creating model compartments
    	foreach my $comp (@{$model->modelcompartments()}) {
    		my $compdata = {
    			id => $comp->id(),
    			name => $comp->id(),
    			pH => $comp->pH(),
    			potential => $comp->potential(),
    			"index" => $comp->compartmentIndex()
    		};
    		push(@{$mdldata->{compartments}},$compdata);
    	}
    	#Creating model compounds
    	foreach my $cpd (@{$model->modelcompounds()}) {
    		my $cpddata = {
    			id => $cpd->id(),
    			compound => $cpd->compound()->id(),
    			name => $cpd->compound()->name(),
    			compartment => $cpd->modelcompartment()->id()
    		};
    		push(@{$mdldata->{compounds}},$cpddata);
    	}
    	#Creating model reactions
    	foreach my $rxn (@{$model->modelreactions()}) {
    		my $rxndata = {
    			id => $rxn->id(),
    			reaction => $rxn->reaction()->id(),
    			name => $rxn->reaction()->name(),
    			direction => $rxn->direction(),
    			features => $rxn->featureIDs(),
    			compartment => $rxn->modelcompartment()->id(),
    			equation => $rxn->equation(),
    			definition => $rxn->definition(),
    			gapfilled => 0
    		};
		$rxndata->{gapfilled} = $self->_was_reaction_gapfilled($rxn);
    		push(@{$mdldata->{reactions}},$rxndata);
    	}
    	#Creating fbas, gapfills, and gapgens
    	foreach my $obj (@{$model->gapfillings()}) {
    		if ($obj->integrated() == 1) {
    			push(@{$mdldata->{integrated_gapfillings}},$self->_generate_gapmeta($obj->gapfill()));
    		} else {
    			push(@{$mdldata->{unintegrated_gapfillings}},$self->_generate_gapmeta($obj->gapfill()));
    		}
    	}
    	foreach my $obj (@{$model->gapgens()}) {
    		if ($obj->integrated() == 1) {
    			push(@{$mdldata->{integrated_gapfillings}},$self->_generate_gapmeta($obj->gapgen()));
    		} else {
    			push(@{$mdldata->{unintegrated_gapfillings}},$self->_generate_gapmeta($obj->gapgen()));
    		}
    	}
    	push(@{$out_models},$mdldata);
    }
	$self->_clearContext();
    #END get_models
    my @_bad_returns;
    (ref($out_models) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_models\" (value was \"$out_models\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_models:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_models');
    }
    return($out_models);
}




=head2 get_fbas

  $out_fbas = $obj->get_fbas($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_fbas_params
$out_fbas is a reference to a list where each element is an FBA
get_fbas_params is a reference to a hash where the following keys are defined:
	fbas has a value which is a reference to a list where each element is a fba_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
fba_id is a string
workspace_id is a string
FBA is a reference to a hash where the following keys are defined:
	id has a value which is a fba_id
	workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	objective has a value which is a float
	isComplete has a value which is a bool
	formulation has a value which is an FBAFormulation
	minimalMediaPredictions has a value which is a reference to a list where each element is a MinimalMediaPrediction
	metaboliteProductions has a value which is a reference to a list where each element is a MetaboliteProduction
	reactionFluxes has a value which is a reference to a list where each element is a ReactionFlux
	compoundFluxes has a value which is a reference to a list where each element is a CompoundFlux
	geneAssertions has a value which is a reference to a list where each element is a GeneAssertion
fbamodel_id is a string
bool is an int
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
MinimalMediaPrediction is a reference to a hash where the following keys are defined:
	optionalNutrients has a value which is a reference to a list where each element is a compound_id
	essentialNutrients has a value which is a reference to a list where each element is a compound_id
MetaboliteProduction is a reference to a list containing 3 items:
	0: (maximumProduction) a float
	1: (modelcompound) a modelcompound_id
	2: (name) a string
modelcompound_id is a string
ReactionFlux is a reference to a list containing 8 items:
	0: (reaction) a modelreaction_id
	1: (value) a float
	2: (upperBound) a float
	3: (lowerBound) a float
	4: (max) a float
	5: (min) a float
	6: (type) a string
	7: (definition) a string
modelreaction_id is a string
CompoundFlux is a reference to a list containing 8 items:
	0: (compound) a modelcompound_id
	1: (value) a float
	2: (upperBound) a float
	3: (lowerBound) a float
	4: (max) a float
	5: (min) a float
	6: (type) a string
	7: (name) a string
GeneAssertion is a reference to a list containing 4 items:
	0: (feature) a feature_id
	1: (growthFraction) a float
	2: (growth) a float
	3: (isEssential) a bool

</pre>

=end html

=begin text

$input is a get_fbas_params
$out_fbas is a reference to a list where each element is an FBA
get_fbas_params is a reference to a hash where the following keys are defined:
	fbas has a value which is a reference to a list where each element is a fba_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
fba_id is a string
workspace_id is a string
FBA is a reference to a hash where the following keys are defined:
	id has a value which is a fba_id
	workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	objective has a value which is a float
	isComplete has a value which is a bool
	formulation has a value which is an FBAFormulation
	minimalMediaPredictions has a value which is a reference to a list where each element is a MinimalMediaPrediction
	metaboliteProductions has a value which is a reference to a list where each element is a MetaboliteProduction
	reactionFluxes has a value which is a reference to a list where each element is a ReactionFlux
	compoundFluxes has a value which is a reference to a list where each element is a CompoundFlux
	geneAssertions has a value which is a reference to a list where each element is a GeneAssertion
fbamodel_id is a string
bool is an int
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
MinimalMediaPrediction is a reference to a hash where the following keys are defined:
	optionalNutrients has a value which is a reference to a list where each element is a compound_id
	essentialNutrients has a value which is a reference to a list where each element is a compound_id
MetaboliteProduction is a reference to a list containing 3 items:
	0: (maximumProduction) a float
	1: (modelcompound) a modelcompound_id
	2: (name) a string
modelcompound_id is a string
ReactionFlux is a reference to a list containing 8 items:
	0: (reaction) a modelreaction_id
	1: (value) a float
	2: (upperBound) a float
	3: (lowerBound) a float
	4: (max) a float
	5: (min) a float
	6: (type) a string
	7: (definition) a string
modelreaction_id is a string
CompoundFlux is a reference to a list containing 8 items:
	0: (compound) a modelcompound_id
	1: (value) a float
	2: (upperBound) a float
	3: (lowerBound) a float
	4: (max) a float
	5: (min) a float
	6: (type) a string
	7: (name) a string
GeneAssertion is a reference to a list containing 4 items:
	0: (feature) a feature_id
	1: (growthFraction) a float
	2: (growth) a float
	3: (isEssential) a bool


=end text



=item Description

Returns data for the requested flux balance analysis formulations

=back

=cut

sub get_fbas
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_fbas:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_fbas');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_fbas);
    #BEGIN get_fbas
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["fbas","workspaces"],{
		id_type => "ModelSEED",
		biochemistry => "default",
		biochemistry_workspace => "kbase"
	});
    for (my $i=0; $i < @{$input->{fbas}}; $i++) {
    	my $id = $input->{fbas}->[$i];
    	my $ws = $input->{workspaces}->[$i];
    	my $fba = $self->_get_msobject("FBA",$ws,$id);
    	my $fbadata = $self->_FBA_to_FBAdata($fba);
       	push(@{$out_fbas},$fbadata);
    }
	$self->_clearContext();
    #END get_fbas
    my @_bad_returns;
    (ref($out_fbas) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_fbas\" (value was \"$out_fbas\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_fbas:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_fbas');
    }
    return($out_fbas);
}




=head2 get_gapfills

  $out_gapfills = $obj->get_gapfills($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_gapfills_params
$out_gapfills is a reference to a list where each element is a GapFill
get_gapfills_params is a reference to a hash where the following keys are defined:
	gapfills has a value which is a reference to a list where each element is a gapfill_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
gapfill_id is a string
workspace_id is a string
GapFill is a reference to a hash where the following keys are defined:
	id has a value which is a gapfill_id
	workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	isComplete has a value which is a bool
	formulation has a value which is a GapfillingFormulation
	solutions has a value which is a reference to a list where each element is a GapFillSolution
fbamodel_id is a string
bool is an int
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
compartment_id is a string
probanno_id is a string
GapFillSolution is a reference to a hash where the following keys are defined:
	id has a value which is a gapfillsolution_id
	objective has a value which is a float
	integrated has a value which is a bool
	biomassRemovals has a value which is a reference to a list where each element is a biomassRemoval
	mediaAdditions has a value which is a reference to a list where each element is a mediaAddition
	reactionAdditions has a value which is a reference to a list where each element is a reactionAddition
gapfillsolution_id is a string
biomassRemoval is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
mediaAddition is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
reactionAddition is a reference to a list containing 5 items:
	0: (reaction) a reaction_id
	1: (direction) a string
	2: (compartment_id) a string
	3: (equation) a string
	4: (definition) a string

</pre>

=end html

=begin text

$input is a get_gapfills_params
$out_gapfills is a reference to a list where each element is a GapFill
get_gapfills_params is a reference to a hash where the following keys are defined:
	gapfills has a value which is a reference to a list where each element is a gapfill_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
gapfill_id is a string
workspace_id is a string
GapFill is a reference to a hash where the following keys are defined:
	id has a value which is a gapfill_id
	workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	isComplete has a value which is a bool
	formulation has a value which is a GapfillingFormulation
	solutions has a value which is a reference to a list where each element is a GapFillSolution
fbamodel_id is a string
bool is an int
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
compartment_id is a string
probanno_id is a string
GapFillSolution is a reference to a hash where the following keys are defined:
	id has a value which is a gapfillsolution_id
	objective has a value which is a float
	integrated has a value which is a bool
	biomassRemovals has a value which is a reference to a list where each element is a biomassRemoval
	mediaAdditions has a value which is a reference to a list where each element is a mediaAddition
	reactionAdditions has a value which is a reference to a list where each element is a reactionAddition
gapfillsolution_id is a string
biomassRemoval is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
mediaAddition is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
reactionAddition is a reference to a list containing 5 items:
	0: (reaction) a reaction_id
	1: (direction) a string
	2: (compartment_id) a string
	3: (equation) a string
	4: (definition) a string


=end text



=item Description

Returns data for the requested gap filling simulations

=back

=cut

sub get_gapfills
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_gapfills:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_gapfills');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_gapfills);
    #BEGIN get_gapfills
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["gapfills","workspaces"],{
		id_type => "ModelSEED"
	});
    for (my $i=0; $i < @{$input->{gapfills}}; $i++) {
    	my $id = $input->{gapfills}->[$i];
    	my $ws = $input->{workspaces}->[$i];
    	my $obj = $self->_get_msobject("Gapfilling",$ws,$id);
    	my $data = $self->_GapFill_to_GapFillData($obj);
    	push(@{$out_gapfills},$data);
    }
	$self->_clearContext();
    #END get_gapfills
    my @_bad_returns;
    (ref($out_gapfills) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_gapfills\" (value was \"$out_gapfills\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_gapfills:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_gapfills');
    }
    return($out_gapfills);
}




=head2 get_gapgens

  $out_gapgens = $obj->get_gapgens($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_gapgens_params
$out_gapgens is a reference to a list where each element is a GapGen
get_gapgens_params is a reference to a hash where the following keys are defined:
	gapgens has a value which is a reference to a list where each element is a gapgen_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
gapgen_id is a string
workspace_id is a string
GapGen is a reference to a hash where the following keys are defined:
	id has a value which is a gapgen_id
	workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	isComplete has a value which is a bool
	formulation has a value which is a GapgenFormulation
	solutions has a value which is a reference to a list where each element is a GapgenSolution
fbamodel_id is a string
bool is an int
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapgenSolution is a reference to a hash where the following keys are defined:
	id has a value which is a gapgensolution_id
	objective has a value which is a float
	biomassAdditions has a value which is a reference to a list where each element is a biomassAddition
	mediaRemovals has a value which is a reference to a list where each element is a mediaRemoval
	reactionRemovals has a value which is a reference to a list where each element is a reactionRemoval
gapgensolution_id is a string
biomassAddition is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
mediaRemoval is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
reactionRemoval is a reference to a list containing 4 items:
	0: (reaction) a modelreaction_id
	1: (direction) a string
	2: (equation) a string
	3: (definition) a string
modelreaction_id is a string

</pre>

=end html

=begin text

$input is a get_gapgens_params
$out_gapgens is a reference to a list where each element is a GapGen
get_gapgens_params is a reference to a hash where the following keys are defined:
	gapgens has a value which is a reference to a list where each element is a gapgen_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
	id_type has a value which is a string
gapgen_id is a string
workspace_id is a string
GapGen is a reference to a hash where the following keys are defined:
	id has a value which is a gapgen_id
	workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	isComplete has a value which is a bool
	formulation has a value which is a GapgenFormulation
	solutions has a value which is a reference to a list where each element is a GapgenSolution
fbamodel_id is a string
bool is an int
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapgenSolution is a reference to a hash where the following keys are defined:
	id has a value which is a gapgensolution_id
	objective has a value which is a float
	biomassAdditions has a value which is a reference to a list where each element is a biomassAddition
	mediaRemovals has a value which is a reference to a list where each element is a mediaRemoval
	reactionRemovals has a value which is a reference to a list where each element is a reactionRemoval
gapgensolution_id is a string
biomassAddition is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
mediaRemoval is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (name) a string
reactionRemoval is a reference to a list containing 4 items:
	0: (reaction) a modelreaction_id
	1: (direction) a string
	2: (equation) a string
	3: (definition) a string
modelreaction_id is a string


=end text



=item Description

Returns data for the requested gap generation simulations

=back

=cut

sub get_gapgens
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_gapgens:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_gapgens');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_gapgens);
    #BEGIN get_gapgens
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["gapgens","workspaces"],{
		id_type => "ModelSEED"
	});
    for (my $i=0; $i < @{$input->{gapgens}}; $i++) {
    	my $id = $input->{gapgens}->[$i];
    	my $ws = $input->{workspaces}->[$i];
    	my $obj = $self->_get_msobject("GapGen",$ws,$id);
    	my $data = $self->_GapGen_to_GapGenData($obj);
       	push(@{$out_gapgens},$data);
    }
	$self->_clearContext();
    #END get_gapgens
    my @_bad_returns;
    (ref($out_gapgens) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_gapgens\" (value was \"$out_gapgens\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_gapgens:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_gapgens');
    }
    return($out_gapgens);
}




=head2 get_reactions

  $out_reactions = $obj->get_reactions($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_reactions_params
$out_reactions is a reference to a list where each element is a Reaction
get_reactions_params is a reference to a hash where the following keys are defined:
	reactions has a value which is a reference to a list where each element is a reaction_id
	auth has a value which is a string
	id_type has a value which is a string
reaction_id is a string
Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a reaction_id
	name has a value which is a string
	abbrev has a value which is a string
	enzymes has a value which is a reference to a list where each element is a string
	direction has a value which is a string
	reversibility has a value which is a string
	deltaG has a value which is a float
	deltaGErr has a value which is a float
	equation has a value which is a string
	definition has a value which is a string

</pre>

=end html

=begin text

$input is a get_reactions_params
$out_reactions is a reference to a list where each element is a Reaction
get_reactions_params is a reference to a hash where the following keys are defined:
	reactions has a value which is a reference to a list where each element is a reaction_id
	auth has a value which is a string
	id_type has a value which is a string
reaction_id is a string
Reaction is a reference to a hash where the following keys are defined:
	id has a value which is a reaction_id
	name has a value which is a string
	abbrev has a value which is a string
	enzymes has a value which is a reference to a list where each element is a string
	direction has a value which is a string
	reversibility has a value which is a string
	deltaG has a value which is a float
	deltaGErr has a value which is a float
	equation has a value which is a string
	definition has a value which is a string


=end text



=item Description

Returns data for the requested reactions

=back

=cut

sub get_reactions
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_reactions);
    #BEGIN get_reactions
	$self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["reactions"],{
    	biochemistry => "default",
    	biochemistry_workspace => "kbase"
    });
	my $biochem = $self->_get_msobject("Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
	$out_reactions = [];
	for (my $i=0; $i < @{$input->{reactions}}; $i++) {
		my $rxn = $input->{reactions}->[$i];
		my $obj;
		if ($rxn =~ m/(rxn\d+)$/) {
			$obj = $biochem->getObject("reactions",$1);
		} else {
			$obj = $biochem->searchForReaction($rxn);
		}
		my $new;
		if (defined($obj)) {
			$new = {
                id => $obj->id(),
                abbrev => $obj->abbreviation(),
                name => $obj->name(),
                enzymes => $obj->getAliases("Enzyme Class"),
				aliases => $obj->allAliases(),
                direction => $obj->direction(),
                reversibility => $obj->thermoReversibility(),
                deltaG => $obj->deltaG(),
                deltaGErr => $obj->deltaGErr(),
                equation => $obj->equation(),
                definition => $obj->definition()
			};
		}
		push(@{$out_reactions},$new);
	}
	$self->_clearContext();
    #END get_reactions
    my @_bad_returns;
    (ref($out_reactions) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_reactions\" (value was \"$out_reactions\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_reactions');
    }
    return($out_reactions);
}




=head2 get_compounds

  $out_compounds = $obj->get_compounds($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_compounds_params
$out_compounds is a reference to a list where each element is a Compound
get_compounds_params is a reference to a hash where the following keys are defined:
	compounds has a value which is a reference to a list where each element is a compound_id
	auth has a value which is a string
	id_type has a value which is a string
compound_id is a string
Compound is a reference to a hash where the following keys are defined:
	id has a value which is a compound_id
	abbrev has a value which is a string
	name has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaGErr has a value which is a float
	formula has a value which is a string

</pre>

=end html

=begin text

$input is a get_compounds_params
$out_compounds is a reference to a list where each element is a Compound
get_compounds_params is a reference to a hash where the following keys are defined:
	compounds has a value which is a reference to a list where each element is a compound_id
	auth has a value which is a string
	id_type has a value which is a string
compound_id is a string
Compound is a reference to a hash where the following keys are defined:
	id has a value which is a compound_id
	abbrev has a value which is a string
	name has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	charge has a value which is a float
	deltaG has a value which is a float
	deltaGErr has a value which is a float
	formula has a value which is a string


=end text



=item Description

Returns data for the requested compounds

=back

=cut

sub get_compounds
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_compounds:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_compounds');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_compounds);
    #BEGIN get_compounds
	$self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["compounds"],{
    	id_type => "all",
    	biochemistry => "default",
		biochemistry_workspace => "kbase"
    });
	my $biochem = $self->_get_msobject("Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
	$out_compounds = [];
	for (my $i=0; $i < @{$input->{compounds}}; $i++) {
		my $cpd = $input->{compounds}->[$i];
		my $obj;
		if ($cpd =~ m/(cpd\d+)$/) {
			$obj = $biochem->getObject("compounds",$1);
		} else {
			$obj = $biochem->searchForCompound($cpd);
		}
		my $new;
		if (defined($obj)) {
			$new = {
                id => $obj->id(),
                name => $obj->name(),
                abbrev => $obj->abbreviation(),
                aliases => $obj->allAliases(),
                charge => $obj->defaultCharge,
                formula => $obj->formula,
                deltaG => $obj->deltaG(),
                deltaGErr => $obj->deltaGErr()
			};
		}
		push(@{$out_compounds},$new);
	}
	$self->_clearContext();
    #END get_compounds
    my @_bad_returns;
    (ref($out_compounds) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_compounds\" (value was \"$out_compounds\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_compounds:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_compounds');
    }
    return($out_compounds);
}




=head2 get_alias

  $output = $obj->get_alias($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_alias_params
$output is a reference to a list where each element is a get_alias_outputs
get_alias_params is a reference to a hash where the following keys are defined:
	object_type has a value which is a string
	input_id_type has a value which is a string
	output_id_type has a value which is a string
	input_ids has a value which is a reference to a list where each element is a string
	auth has a value which is a string
get_alias_outputs is a reference to a hash where the following keys are defined:
	original_id has a value which is a string
	aliases has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

$input is a get_alias_params
$output is a reference to a list where each element is a get_alias_outputs
get_alias_params is a reference to a hash where the following keys are defined:
	object_type has a value which is a string
	input_id_type has a value which is a string
	output_id_type has a value which is a string
	input_ids has a value which is a reference to a list where each element is a string
	auth has a value which is a string
get_alias_outputs is a reference to a hash where the following keys are defined:
	original_id has a value which is a string
	aliases has a value which is a reference to a list where each element is a string


=end text



=item Description

Turns one compound I into another of a different type

=back

=cut

sub get_alias
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_alias:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_alias');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN get_alias
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["input_ids", "input_id_type", "output_id_type", "object_type"],{
        biochemistry => "default",
        biochemistry_workspace => "kbase"
    });
    my $biochem = $self->_get_msobject("Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
    $output = [];
    for (my $i=0; $i < @{$input->{input_ids}}; $i++) {
		my $id = $input->{input_ids}->[$i];
		my $obj;
		my $oneoutput = {};
		if (lc($input->{"object_type"}) eq "compound") {
		    $obj = $biochem->getObjectByAlias("compounds",$id,$input->{input_id_type});
		} elsif (lc($input->{"object_type"}) eq "reaction") {
		    $obj = $biochem->getObjectByAlias("reactions", $id, $input->{input_id_type});
		} else { 
		    die "Object type $input->{object_type} does not support alias sets";
		}
		if (defined($obj)) {
		    $oneoutput->{original_id} = $id;
		    $oneoutput->{aliases} = [];
		    my $alias = $obj->getAliases($input->{output_id_type});
		    push(@{$oneoutput->{aliases}},$alias);
		    push(@{$output}, $oneoutput);
		}
    }
    #END get_alias
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_alias:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_alias');
    }
    return($output);
}




=head2 get_aliassets

  $aliassets = $obj->get_aliassets($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_aliassets_params
$aliassets is a reference to a list where each element is a string
get_aliassets_params is a reference to a hash where the following keys are defined:
	object_type has a value which is a string
	auth has a value which is a string

</pre>

=end html

=begin text

$input is a get_aliassets_params
$aliassets is a reference to a list where each element is a string
get_aliassets_params is a reference to a hash where the following keys are defined:
	object_type has a value which is a string
	auth has a value which is a string


=end text



=item Description

Get possible types of aliases (alias sets)

=back

=cut

sub get_aliassets
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_aliassets:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_aliassets');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($aliassets);
    #BEGIN get_aliassets
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["object_type"],{biochemistry => "default"});
    my $biochem = $self->_get_msobject("Biochemistry","kbase",$input->{biochemistry});
    $aliassets = [];
    my $aliashash = {};
    if (lc($input->{object_type}) eq "compound") {
    	$aliashash = $biochem->compoundsByAlias();
    } elsif (lc($input->{object_type}) eq "reaction") {
    	$aliashash = $biochem->reactionsByAlias();
    }
    $aliassets = [keys(%{$aliashash})];

    #END get_aliassets
    my @_bad_returns;
    (ref($aliassets) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"aliassets\" (value was \"$aliassets\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_aliassets:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_aliassets');
    }
    return($aliassets);
}




=head2 get_media

  $out_media = $obj->get_media($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_media_params
$out_media is a reference to a list where each element is a Media
get_media_params is a reference to a hash where the following keys are defined:
	medias has a value which is a reference to a list where each element is a media_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
media_id is a string
workspace_id is a string
Media is a reference to a hash where the following keys are defined:
	id has a value which is a media_id
	name has a value which is a string
	media_compounds has a value which is a reference to a list where each element is a MediaCompound
	pH has a value which is a float
	temperature has a value which is a float
MediaCompound is a reference to a hash where the following keys are defined:
	compound has a value which is a compound_id
	name has a value which is a string
	concentration has a value which is a float
	max_flux has a value which is a float
	min_flux has a value which is a float
compound_id is a string

</pre>

=end html

=begin text

$input is a get_media_params
$out_media is a reference to a list where each element is a Media
get_media_params is a reference to a hash where the following keys are defined:
	medias has a value which is a reference to a list where each element is a media_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
media_id is a string
workspace_id is a string
Media is a reference to a hash where the following keys are defined:
	id has a value which is a media_id
	name has a value which is a string
	media_compounds has a value which is a reference to a list where each element is a MediaCompound
	pH has a value which is a float
	temperature has a value which is a float
MediaCompound is a reference to a hash where the following keys are defined:
	compound has a value which is a compound_id
	name has a value which is a string
	concentration has a value which is a float
	max_flux has a value which is a float
	min_flux has a value which is a float
compound_id is a string


=end text



=item Description

Returns data for the requested media formulations

=back

=cut

sub get_media
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_media:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_media');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_media);
    #BEGIN get_media
	$self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["medias","workspaces"],{});
	$out_media = [];
	for (my $i=0; $i < @{$input->{medias}}; $i++) {
		my $media = $input->{medias}->[$i];
		my $workspace = $input->{workspaces}->[$i];
		my $obj = $self->_get_msobject("Media",$workspace,$media);
		my $new;
		if (defined($obj)) {
			$new = {
                id => $obj->id(),
                name => $obj->name(),
                pH => 7,#TODO:Fix this
                temperature => 298,#TODO:Fix this
                media_compounds => [],
            };
            foreach my $mediaCompound (@{$obj->mediacompounds}) {
                push(@{$new->{media_compounds}},{
                	compound => $mediaCompound->compound()->id(),
                	name => $mediaCompound->compound()->name(),
                	concentration => $mediaCompound->concentration(),
                	max_flux => $mediaCompound->maxFlux(),
                	min_flux => $mediaCompound->minFlux()
                });
            }
		}
		push(@{$out_media},$new);
	}
	$self->_clearContext();
    #END get_media
    my @_bad_returns;
    (ref($out_media) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"out_media\" (value was \"$out_media\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_media:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_media');
    }
    return($out_media);
}




=head2 get_biochemistry

  $out_biochemistry = $obj->get_biochemistry($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a get_biochemistry_params
$out_biochemistry is a Biochemistry
get_biochemistry_params is a reference to a hash where the following keys are defined:
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	id_type has a value which is a string
	auth has a value which is a string
biochemistry_id is a string
workspace_id is a string
Biochemistry is a reference to a hash where the following keys are defined:
	id has a value which is a biochemistry_id
	name has a value which is a string
	compounds has a value which is a reference to a list where each element is a compound_id
	reactions has a value which is a reference to a list where each element is a reaction_id
	media has a value which is a reference to a list where each element is a media_id
compound_id is a string
reaction_id is a string
media_id is a string

</pre>

=end html

=begin text

$input is a get_biochemistry_params
$out_biochemistry is a Biochemistry
get_biochemistry_params is a reference to a hash where the following keys are defined:
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	id_type has a value which is a string
	auth has a value which is a string
biochemistry_id is a string
workspace_id is a string
Biochemistry is a reference to a hash where the following keys are defined:
	id has a value which is a biochemistry_id
	name has a value which is a string
	compounds has a value which is a reference to a list where each element is a compound_id
	reactions has a value which is a reference to a list where each element is a reaction_id
	media has a value which is a reference to a list where each element is a media_id
compound_id is a string
reaction_id is a string
media_id is a string


=end text



=item Description

Returns biochemistry object

=back

=cut

sub get_biochemistry
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_biochemistry:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_biochemistry');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($out_biochemistry);
    #BEGIN get_biochemistry
	$self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,[],{
		biochemistry => "default",
		biochemistry_workspace => "kbase",
	});
    my $biochem = $self->_get_msobject("Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
    my $compounds = [];
    my $reactions = [];
    $out_biochemistry = {
        id => $biochem->id(),
        name => $biochem->name,
        compounds => $compounds,
        reactions => $reactions,
    };
	my $cpds = $biochem->compounds();
    for (my $i=0; $i < @{$cpds}; $i++) {
    	push(@{$compounds},$cpds->[$i]->id());
    }
    my $rxns = $biochem->reactions();
    for (my $i=0; $i < @{$rxns}; $i++) {
    	push(@{$reactions},$rxns->[$i]->id());
    }
	$self->_clearContext();
    #END get_biochemistry
    my @_bad_returns;
    (ref($out_biochemistry) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"out_biochemistry\" (value was \"$out_biochemistry\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_biochemistry:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_biochemistry');
    }
    return($out_biochemistry);
}




=head2 import_probanno

  $probannoMeta = $obj->import_probanno($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an import_probanno_params
$probannoMeta is an object_metadata
import_probanno_params is a reference to a hash where the following keys are defined:
	probanno has a value which is a probanno_id
	workspace has a value which is a workspace_id
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	annotationProbabilities has a value which is a reference to a list where each element is an annotationProbability
	ignore_errors has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
probanno_id is a string
workspace_id is a string
genome_id is a string
annotationProbability is a reference to a list containing 3 items:
	0: (feature) a feature_id
	1: (function) a string
	2: (probability) a float
feature_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an import_probanno_params
$probannoMeta is an object_metadata
import_probanno_params is a reference to a hash where the following keys are defined:
	probanno has a value which is a probanno_id
	workspace has a value which is a workspace_id
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	annotationProbabilities has a value which is a reference to a list where each element is an annotationProbability
	ignore_errors has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
probanno_id is a string
workspace_id is a string
genome_id is a string
annotationProbability is a reference to a list containing 3 items:
	0: (feature) a feature_id
	1: (function) a string
	2: (probability) a float
feature_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Loads an input genome object into the workspace.

=back

=cut

sub import_probanno
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_probanno:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_probanno');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($probannoMeta);
    #BEGIN import_probanno
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["workspace","annotationProbabilities","genome"],{
		probanno => undef,
		genome_workspace => $input->{workspace},
		ignore_errors => 0
	});
    if (!defined($input->{probanno})) {
    	$input->{probanno} = $self->_get_new_id($input->{genome}.".probanno.");
    }
    #Retrieving specified genome
    my $genomeObj = $self->_get_msobject("Genome",$input->{genome_workspace},$input->{genome});
    if (!defined($genomeObj)) {
    	my $msg = "Failed to retrieve genome ".$input->{genome_workspace}."/".$input->{genome};
    	$self->_error($msg,'import_phenotypes');
    }
    #Retrieving the annotation object
    my $annotation = $self->_get_msobject("Annotation","NO_WORKSPACE",$genomeObj->{annotation_uuid});
    if (!defined($annotation)) {
    	my $msg = "Failed to retrieve annotation ".$input->{genome_workspace}."/".$input->{genome};
    	$self->_error($msg,'import_phenotypes');
    }
    #Retrieving the mapping object
    my $map = $annotation->mapping();
    #Building a hash for all gene aliases mapped to gene IDs
    my $genehash = {};
    for (my $i=0; $i < @{$genomeObj->{features}}; $i++) {
    	my $ftr = $genomeObj->{features}->[$i];
    	$genehash->{$ftr->{id}} = $ftr->{id};
    	if (defined($ftr->{aliases})) {
    		for (my $j=0; $j < @{$ftr->{aliases}}; $j++) {
    			$genehash->{$ftr->{aliases}->[$j]} = $ftr->{id};
    		}
    	}
    }
    #Instantiating probabilistic annotation object
    my $object = {
    	id => $input->{probanno},
    	genome => $input->{genome},
    	genome_uuid => $genomeObj->{_kbaseWSMeta}->{wsref},
    	featureAlternativeFunctions => [],
    };
    #Validating roles and genes
    my $missingGenes = [];
    my $missingRoles = [];
    my $featureHash;
    my $allfound = 1;
    my $found = 0;
    my $missing = 0;
    for (my $i=0; $i < @{$input->{annotationProbabilities}}; $i++) {
    	my $annoprob = $input->{annotationProbabilities}->[$i];
    	if (!defined($genehash->{$annoprob->[0]})) {
    		push(@{$missingGenes},$annoprob->[0]);
    		$allfound = 0;
    	} else {
    		$annoprob->[0] = $genehash->{$annoprob->[0]};
    		
    		my $searchName = ModelSEED::MS::Utilities::GlobalFunctions::convertRoleToSearchRole($annoprob->[1]);
    		my $roleObj = $map->queryObject("roles",{searchname => $searchName});
    		if (defined($roleObj)) {
    			$found++;
    			if (defined($featureHash->{$annoprob->[0]})) {
		    		push(@{$featureHash->{$annoprob->[0]}->{alternative_functions}},[
		    			$annoprob->[1],
		    			$annoprob->[2]
		    		]);
		    	} else {
		    		$featureHash->{$annoprob->[0]} = {
		    			id => $annoprob->[0],
		    			alternative_functions => [
		    				[
		    					$annoprob->[1],
		    					$annoprob->[2]
		    				]
		    			]
		    		};
		    	}
    		} else {
    			$missing++;
    			push(@{$missingRoles},$annoprob->[1]);
    			$allfound = 0;
    		}
    	} 
    }
    #Adding fuction annotation array to structure
    foreach my $key (keys(%{$featureHash})) {
    	push(@{$object->{featureAlternativeFunctions}},$featureHash->{$key});
    }
    #Printing error if any entities could not be validated
    my $msg = "";
    if (@{$missingGenes} > 0) {
    	$msg = "Could not find genes:".join(";",@{$missingGenes})."\n";
    }
    if (@{$missingRoles} > 0) {
    	$msg = "Could not find role:".join(";",@{$missingRoles})."\n";
    }
    my $meta = {};
	if (length($msg) > 0 && $input->{ignore_errors} == 0) {
		$self->_error($msg,'import_phenotypes');
	} elsif (length($msg) > 0) {
		$object->{importErrors} = $msg;
	}
    #Saving object to database
    $probannoMeta = $self->_workspaceServices()->save_object({
		id => $input->{probanno},
		type => "ProbAnno",
		data => $object,
		workspace => $input->{workspace},
		command => "import_probanno",
		auth => $self->_authentication()
	});
	$self->_clearContext();
    #END import_probanno
    my @_bad_returns;
    (ref($probannoMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"probannoMeta\" (value was \"$probannoMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_probanno:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_probanno');
    }
    return($probannoMeta);
}




=head2 genome_object_to_workspace

  $genomeMeta = $obj->genome_object_to_workspace($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a genome_object_to_workspace_params
$genomeMeta is an object_metadata
genome_object_to_workspace_params is a reference to a hash where the following keys are defined:
	uid has a value which is a Genome_uid
	genomeobj has a value which is a GenomeObject
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
Genome_uid is a string
GenomeObject is a reference to a hash where the following keys are defined:
	id has a value which is a genome_id
	scientific_name has a value which is a string
	domain has a value which is a string
	genetic_code has a value which is an int
	source has a value which is a string
	source_id has a value which is a string
	contigs has a value which is a reference to a list where each element is a contig
	features has a value which is a reference to a list where each element is a feature
genome_id is a string
contig is a reference to a hash where the following keys are defined:
	id has a value which is a contig_id
	dna has a value which is a string
contig_id is a string
feature is a reference to a hash where the following keys are defined:
	id has a value which is a feature_id
	location has a value which is a location
	type has a value which is a feature_type
	function has a value which is a string
	alternative_functions has a value which is a reference to a list where each element is an alt_func
	protein_translation has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	annotations has a value which is a reference to a list where each element is an annotation
feature_id is a string
location is a reference to a list where each element is a region_of_dna
region_of_dna is a reference to a list containing 4 items:
	0: a contig_id
	1: (begin) an int
	2: (strand) a string
	3: (length) an int
feature_type is a string
alt_func is a reference to a list containing 2 items:
	0: (function) a string
	1: (probability) a float
gene_hit is a reference to a list containing 2 items:
	0: (gene) a feature_id
	1: (blast_score) a float
annotation is a reference to a list containing 3 items:
	0: (comment) a string
	1: (annotator) a string
	2: (annotation_time) an int
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a genome_object_to_workspace_params
$genomeMeta is an object_metadata
genome_object_to_workspace_params is a reference to a hash where the following keys are defined:
	uid has a value which is a Genome_uid
	genomeobj has a value which is a GenomeObject
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
Genome_uid is a string
GenomeObject is a reference to a hash where the following keys are defined:
	id has a value which is a genome_id
	scientific_name has a value which is a string
	domain has a value which is a string
	genetic_code has a value which is an int
	source has a value which is a string
	source_id has a value which is a string
	contigs has a value which is a reference to a list where each element is a contig
	features has a value which is a reference to a list where each element is a feature
genome_id is a string
contig is a reference to a hash where the following keys are defined:
	id has a value which is a contig_id
	dna has a value which is a string
contig_id is a string
feature is a reference to a hash where the following keys are defined:
	id has a value which is a feature_id
	location has a value which is a location
	type has a value which is a feature_type
	function has a value which is a string
	alternative_functions has a value which is a reference to a list where each element is an alt_func
	protein_translation has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	annotations has a value which is a reference to a list where each element is an annotation
feature_id is a string
location is a reference to a list where each element is a region_of_dna
region_of_dna is a reference to a list containing 4 items:
	0: a contig_id
	1: (begin) an int
	2: (strand) a string
	3: (length) an int
feature_type is a string
alt_func is a reference to a list containing 2 items:
	0: (function) a string
	1: (probability) a float
gene_hit is a reference to a list containing 2 items:
	0: (gene) a feature_id
	1: (blast_score) a float
annotation is a reference to a list containing 3 items:
	0: (comment) a string
	1: (annotator) a string
	2: (annotation_time) an int
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Loads an input genome object into the workspace.

=back

=cut

sub genome_object_to_workspace
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to genome_object_to_workspace:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_object_to_workspace');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($genomeMeta);
    #BEGIN genome_object_to_workspace
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genomeobj","workspace"],{
    	uid => $input->{genomeobj}->{id}
    });
    #Processing genome object
	my $genome = $input->{genomeobj};
	if (!defined($genome->{id})) {
		$genome->{id} = $self->_get_new_id("kb|g");
	}
	if (!defined($genome->{scientific_name})) {
		$genome->{scientific_name} = $genome->{id};
	}
	if (defined($genome->{gc})) {
		$genome->{gc_content} = $genome->{gc};
		delete $genome->{gc};
	}
	if (!defined($genome->{source})) {
		$genome->{source} = "KBase";
		$genome->{source_id} = $genome->{id};
	}
	if (defined($genome->{contigs})) {
		my $label = "dna";
		if (defined($genome->{contigs}->[0]->{seq})) {
			$label = "seq";
		}
		$genome->{num_contigs} = @{$genome->{contigs}};
		my $sortedcontigs = [sort { $a->{$label} cmp $b->{$label} } @{$genome->{contigs}}];
		my $str = "";
		for (my $i=0; $i < @{$sortedcontigs}; $i++) {
			if (length($str) > 0) {
				$str .= ";";
			}
			$str .= $sortedcontigs->[$i]->{$label};
			
		}
		$genome->{dna_size} = length($str);
		$genome->{md5} = Digest::MD5::md5_hex($str);
		my $contigset = {
			id => $self->_register_kb_id("kb|contigset",$genome->{md5},"md5hash"),
			name => $genome->{scientific_name},
			md5 => $genome->{md5},
			source_id => $genome->{source_id},
			source => $genome->{source},
			type => "Organism",
			contigs => []
		};
		for (my $i=0; $i < @{$genome->{contigs}}; $i++) {
			push(@{$genome->{contig_ids}},$genome->{contigs}->[$i]->{id});
			push(@{$genome->{contig_lengths}},length($genome->{contigs}->[$i]->{$label}));
			my $md5 = Digest::MD5::md5_hex($genome->{contigs}->[$i]->{$label});
			push(@{$contigset->{contigs}},{
				id => $genome->{contigs}->[$i]->{id},
				"length" => length($genome->{contigs}->[$i]->{$label}),
				md5 => $md5,
				sequence => $genome->{contigs}->[$i]->{$label},
				name => $genome->{contigs}->[$i]->{id}
			});
		}
		my $ContigObj = Bio::KBase::ObjectAPI::KBaseGenomes::ContigSet->new($contigset);
		$self->_save_msobject($ContigObj,"ContigSet",$input->{workspace},$input->{uid}.".contigset",{hidden => 0});
		$genome->{contigset_ref} = $ContigObj->_reference();
	}
	if (defined($genome->{features})) {
		for (my $i=0; $i < @{$genome->{features}}; $i++) {
			my $ftr = $genome->{features}->[$i];
			if (!defined($ftr->{type}) && $ftr->{id} =~ m/(\w+)\.\d+$/) {
				$ftr->{type} = $1;
			}
			if (defined($ftr->{protein_translation})) {
				$ftr->{protein_translation_length} = length($ftr->{protein_translation});
				$ftr->{md5} = Digest::MD5::md5_hex($ftr->{protein_translation});
			}
			if (defined($ftr->{dna_sequence})) {
				$ftr->{dna_sequence_length} = length($ftr->{dna_sequence});
			}
			delete $ftr->{feature_creation_event};
		}
	}
	delete $genome->{contigs};
	delete $genome->{feature_creation_event};
	delete $genome->{analysis_events};
	my $GenomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new($genome);
	$GenomeObj->features();
	$genomeMeta = $self->_save_msobject($GenomeObj,"Genome",$input->{workspace},$input->{uid});
	$self->_clearContext();
    #END genome_object_to_workspace
    my @_bad_returns;
    (ref($genomeMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"genomeMeta\" (value was \"$genomeMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to genome_object_to_workspace:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_object_to_workspace');
    }
    return($genomeMeta);
}




=head2 genome_to_workspace

  $genomeMeta = $obj->genome_to_workspace($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a genome_to_workspace_params
$genomeMeta is an object_metadata
genome_to_workspace_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	workspace has a value which is a workspace_id
	sourceLogin has a value which is a string
	sourcePassword has a value which is a string
	source has a value which is a string
	auth has a value which is a string
	overwrite has a value which is a bool
genome_id is a string
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a genome_to_workspace_params
$genomeMeta is an object_metadata
genome_to_workspace_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	workspace has a value which is a workspace_id
	sourceLogin has a value which is a string
	sourcePassword has a value which is a string
	source has a value which is a string
	auth has a value which is a string
	overwrite has a value which is a bool
genome_id is a string
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Retrieves a genome from the CDM and saves it as a genome object in the workspace.

=back

=cut

sub genome_to_workspace
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to genome_to_workspace:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_to_workspace');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($genomeMeta);
    #BEGIN genome_to_workspace
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genome","workspace"],{
    	sourceLogin => undef,
    	sourcePassword => undef,
    	source => "kbase",
    });
    my $objects;
    if ($input->{source} eq "kbase") {
    	$objects = $self->_get_genomeObj_from_CDM($input->{genome});
    } elsif ($input->{source} eq "seed") {
    	$objects = $self->_get_genomeObj_from_SEED($input->{genome});
    } elsif ($input->{source} eq "rast") {
    	$objects = $self->_get_genomeObj_from_RAST($input->{genome},$input->{sourceLogin},$input->{sourcePassword});
    }
    if (defined($objects->[1])) {
    	my $contigmeta = $self->_save_msobject($objects->[1],"ContigSet",$input->{workspace},$objects->[1]->{id});
		$objects->[0]->contigset_ref($objects->[1]->_reference());
    }
	$genomeMeta = $self->_save_msobject($objects->[0],"Genome",$input->{workspace},$input->{genome});
	$self->_clearContext();
    #END genome_to_workspace
    my @_bad_returns;
    (ref($genomeMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"genomeMeta\" (value was \"$genomeMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to genome_to_workspace:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_to_workspace');
    }
    return($genomeMeta);
}




=head2 domains_to_workspace

  $GenomeDomainMeta = $obj->domains_to_workspace($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a domains_to_workspace_params
$GenomeDomainMeta is an object_metadata
domains_to_workspace_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	output_id has a value which is a string
	workspace has a value which is a workspace_id
	auth has a value which is a string
genome_id is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a domains_to_workspace_params
$GenomeDomainMeta is an object_metadata
domains_to_workspace_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	output_id has a value which is a string
	workspace has a value which is a workspace_id
	auth has a value which is a string
genome_id is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Computes or fetches domains for a genome

=back

=cut

sub domains_to_workspace
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to domains_to_workspace:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'domains_to_workspace');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($GenomeDomainMeta);
    #BEGIN domains_to_workspace
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genome","workspace"],{
    	output_id => $input->{genome}.".domains",
    	genome_workspace => $input->{workspace},
    });
	my $obj = $self->_get_CDD_data_from_CDM($input->{genome});
    $obj->domains();
    $obj->featuredomains();
    $GenomeDomainMeta = $self->_save_msobject($obj,"GenomeDomainData",$input->{workspace},$input->{output_id});
    #END domains_to_workspace
    my @_bad_returns;
    (ref($GenomeDomainMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"GenomeDomainMeta\" (value was \"$GenomeDomainMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to domains_to_workspace:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'domains_to_workspace');
    }
    return($GenomeDomainMeta);
}




=head2 compute_domains

  $output = $obj->compute_domains($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a compute_domains_params
$output is an object_metadata
compute_domains_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	proteins has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: a string
	1: a string

	workspace has a value which is a workspace_id
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a compute_domains_params
$output is an object_metadata
compute_domains_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	proteins has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: a string
	1: a string

	workspace has a value which is a workspace_id
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Computes domains for either a genome or a list of proteins

=back

=cut

sub compute_domains
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to compute_domains:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'compute_domains');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN compute_domains
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["workspace"],{
    	update => 0,
    	genome => undef,
    	genome_workspace => $params->{workspace},
    	proteins => {}
    });
    my $proteins = $params->{proteins};
    if (defined($params->{genome})) {
    	my $genome = $self->_get_msobject("Genome",$params->{genome_workspace},$params->{genome});
	    my $features = $genome->features();
	    for (my $i=0; $i < @{$features}; $i++) {
	    	if (defined($features->[$i]->protein_translation())) {
	    		$proteins->{$features->[$i]->id()} = $features->[$i]->protein_translation();
	    	}
	    }    
    }
    $self->_compute_CDD($proteins);
    #END compute_domains
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to compute_domains:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'compute_domains');
    }
    return($output);
}




=head2 add_feature_translation

  $genomeMeta = $obj->add_feature_translation($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an add_feature_translation_params
$genomeMeta is an object_metadata
add_feature_translation_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	workspace has a value which is a workspace_id
	translations has a value which is a reference to a list where each element is a translation
	id_type has a value which is a string
	auth has a value which is a string
	overwrite has a value which is a bool
genome_id is a string
workspace_id is a string
translation is a reference to a list containing 2 items:
	0: (foreign_id) a string
	1: (feature) a feature_id
feature_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an add_feature_translation_params
$genomeMeta is an object_metadata
add_feature_translation_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	workspace has a value which is a workspace_id
	translations has a value which is a reference to a list where each element is a translation
	id_type has a value which is a string
	auth has a value which is a string
	overwrite has a value which is a bool
genome_id is a string
workspace_id is a string
translation is a reference to a list containing 2 items:
	0: (foreign_id) a string
	1: (feature) a feature_id
feature_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Adds a new set of alternative feature IDs to the specified genome typed object

=back

=cut

sub add_feature_translation
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to add_feature_translation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_feature_translation');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($genomeMeta);
    #BEGIN add_feature_translation
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genome","workspace","translations","id_type"],{});
    my $genome = $self->_get_msobject("Genome",$input->{workspace},$input->{genome});
    my $aliases;
    for (my $i=0; $i < @{$input->{translations}}; $i++) {
    	my $trans = $input->{translations}->[$i];
    	$aliases->{$trans->[1]}->{$trans->[0]} = 1;
    }
    my $features = $genome->features();
    for (my $i=0; $i < @{$features}; $i++) {
    	my $ftr = $features->[$i];
    	if (defined($aliases->{$ftr->id()})) {
    		my $existingAliases = {};
	    	foreach my $alias (@{$ftr->aliases()}) {
	    		$existingAliases->{$alias} = 1;
	    	}
    		foreach my $alias (keys(%{$aliases->{$ftr->id()}})) {
    			if (!defined($existingAliases->{$alias})) {
    				push(@{$ftr->aliases()},$alias);
    			}
    		}
    	}
    }
    $genomeMeta = $self->_save_msobject($genome,"Genome",$input->{workspace},$input->{genome});
    $self->_clearContext();
    #END add_feature_translation
    my @_bad_returns;
    (ref($genomeMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"genomeMeta\" (value was \"$genomeMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to add_feature_translation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_feature_translation');
    }
    return($genomeMeta);
}




=head2 genome_to_fbamodel

  $modelMeta = $obj->genome_to_fbamodel($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a genome_to_fbamodel_params
$modelMeta is an object_metadata
genome_to_fbamodel_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	templatemodel has a value which is a template_id
	templatemodel_workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	coremodel has a value which is a bool
	workspace has a value which is a workspace_id
	auth has a value which is a string
	fulldb has a value which is a bool
genome_id is a string
workspace_id is a string
template_id is a string
fbamodel_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a genome_to_fbamodel_params
$modelMeta is an object_metadata
genome_to_fbamodel_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	templatemodel has a value which is a template_id
	templatemodel_workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	coremodel has a value which is a bool
	workspace has a value which is a workspace_id
	auth has a value which is a string
	fulldb has a value which is a bool
genome_id is a string
workspace_id is a string
template_id is a string
fbamodel_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Build a genome-scale metabolic model based on annotations in an input genome typed object

=back

=cut

sub genome_to_fbamodel
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to genome_to_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_to_fbamodel');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN genome_to_fbamodel
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genome","workspace"],{
    	templatemodel => undef,
    	templatemodel_workspace => $input->{workspace},
    	coremodel => 0,
    	genome_workspace => $input->{workspace},
    	model => undef,
    	fulldb => 0
    });
    #Retreiving genome object from workspace
    my $genome = $self->_get_msobject("Genome",$input->{genome_workspace},$input->{genome});
    #Determining model ID
    my $kbid = $self->_get_new_id($genome->id().".fbamdl");
    if (!defined($input->{model})) {
    	$input->{model} = $input->{genome}.".fbamdl";
    }
    my $mdl = $self->_genome_to_model($genome,$kbid,$input);
	#Model uuid and model id will be set to WS values during save
	$modelMeta = $self->_save_msobject($mdl,"FBAModel",$input->{workspace},$input->{model});
    $self->_clearContext();
    #END genome_to_fbamodel
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to genome_to_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_to_fbamodel');
    }
    return($modelMeta);
}




=head2 translate_fbamodel

  $modelMeta = $obj->translate_fbamodel($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a translate_fbamodel_params
$modelMeta is an object_metadata
translate_fbamodel_params is a reference to a hash where the following keys are defined:
	protcomp has a value which is a string
	protcomp_workspace has a value which is a string
	model has a value which is a string
	model_workspace has a value which is a string
	workspace has a value which is a workspace_id
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a translate_fbamodel_params
$modelMeta is an object_metadata
translate_fbamodel_params is a reference to a hash where the following keys are defined:
	protcomp has a value which is a string
	protcomp_workspace has a value which is a string
	model has a value which is a string
	model_workspace has a value which is a string
	workspace has a value which is a workspace_id
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Translate an existing model to a new genome based on the genome comparison object

=back

=cut

sub translate_fbamodel
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to translate_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'translate_fbamodel');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN translate_fbamodel
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["protcomp","model","workspace"],{
    	protcomp_workspace => $input->{workspace},
    	model_workspace => $input->{workspace},
    	output_id => "Translated_".$input->{model},
    	keep_nogene_rxn => 1
    });
    my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
    my $protcomp = $self->_get_msobject("ProteomeComparison",$input->{protcomp_workspace},$input->{protcomp});
	my $report = $model->translate_model({
		proteome_comparison => $protcomp,
		keep_nogene_rxn => $input->{keep_nogene_rxn}
	});
	$modelMeta = $self->_save_msobject($model,"",$input->{workspace},$input->{output_id},{meta => $report});
    #END translate_fbamodel
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to translate_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'translate_fbamodel');
    }
    return($modelMeta);
}




=head2 build_pangenome

  $output = $obj->build_pangenome($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a build_pangenome_params
$output is an object_metadata
build_pangenome_params is a reference to a hash where the following keys are defined:
	genomes has a value which is a reference to a list where each element is a string
	genome_workspace has a value which is a reference to a list where each element is a string
	workspace has a value which is a workspace_id
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a build_pangenome_params
$output is an object_metadata
build_pangenome_params is a reference to a hash where the following keys are defined:
	genomes has a value which is a reference to a list where each element is a string
	genome_workspace has a value which is a reference to a list where each element is a string
	workspace has a value which is a workspace_id
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Translate an existing model to a new genome based on the genome comparison object

=back

=cut

sub build_pangenome
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to build_pangenome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'build_pangenome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN build_pangenome
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genomes","genome_workspaces","workspace"],{
    	output_id => undef,
    	name => undef,
    });
    my $orthlist = [];
    my $okdb;
    my $id = $self->_get_new_id("kb|pangen");
    if (!defined($input->{output_id})) {
    	$input->{output_id} = $id;
    }
    my $pangenome = {
    	id => $id,
		type => "kmer",
		genome_refs => [],
		orthologs => [],
    };
    my $proteins = {};
    for (my $i=0; $i < @{$input->{genomes}}; $i++) {
    	print "Processing genome ".$i."\n";
    	my $gkdb = {};
    	my $genepairs;
    	my $bestorthos = [];
    	my $currgenome = $self->_get_msobject("Genome",$input->{genome_workspaces}->[$i],$input->{genomes}->[$i]);
    	push(@{$pangenome->{genome_refs}},$currgenome->_reference());
    	if ($i==0) {
    		my $array = [split(/\s/,$currgenome->scientific_name())];
    		$pangenome->{name} = $array->[0]." pangenome";
    	}
    	my $ftrs = $currgenome->features();
    	for (my $j=0; $j < @{$ftrs}; $j++) {
    		my $feature = $ftrs->[$j];
    		if (defined($feature->protein_translation())) {
    			$proteins->{$feature->id()} = $feature->protein_translation();
    			my $matchortho;
    			my $bestortho;
    			my $bestscore = 0;
    			my $seq = $feature->protein_translation();
    			for (my $k=	0; $k < (length($seq)-8); $k++) {
    				my $kmer = substr($seq,$k,8);
    				if ($i > 0) {
	    				if (defined($okdb->{$kmer})) {
	    					if (!defined($matchortho->{$okdb->{$kmer}})) {
	    						$matchortho->{$okdb->{$kmer}} = 0;
	    					}
	    					$matchortho->{$okdb->{$kmer}}++;
	    					if ($matchortho->{$okdb->{$kmer}} > $bestscore) {
	    						$bestscore = $matchortho->{$okdb->{$kmer}};
	    						$bestortho = $okdb->{$kmer};
	    					}
	    				}
    				}
    				if (defined($gkdb->{$kmer}) && !defined($gkdb->{$kmer}->{-1})) {
    					if (keys(%{$gkdb->{$kmer}}) >= 5) {
    						my $keylist = [keys(%{$gkdb->{$kmer}})];
    						for (my $m=0; $m < 4; $m++) {
    							for (my $n=($m+1); $n < 5; $n++) {
    								$genepairs->{$keylist->[$m]}->{$keylist->[$n]}--;
    								$genepairs->{$keylist->[$n]}->{$keylist->[$m]}--;
    							}
    						}
    						$gkdb->{$kmer} = {-1 => 0};
    					} else {
    						foreach my $key (keys(%{$gkdb->{$kmer}})) {
    							if ($key ne $j) {
    								if (!defined($genepairs->{$key}->{$j})) {
    									$genepairs->{$key}->{$j} = 0;
    									$genepairs->{$j}->{$key} = 0;
    								}
    								$genepairs->{$key}->{$j}++;
    								$genepairs->{$j}->{$key}++;
    							}
    						}
    						$gkdb->{$kmer}->{$j} = 1;
    					}
    				} else {
    					$gkdb->{$kmer}->{$j} = 1;
    				}
    			}
    			if ($bestscore < 10) {
    				$bestorthos->[$j] = -1;
    			} else {
    				$bestorthos->[$j] = $bestortho;
    				push(@{$pangenome->{orthologs}->[$bestortho]->{orthologs}},[$ftrs->[$j]->id(),0,$currgenome->_reference()]);
    			}
    		}
    	};
    	foreach my $kmer (keys(%{$gkdb})) {
    		if (!defined($gkdb->{$kmer}->{-1})) {
	    		my $keep = 1;
	    		if (keys(%{$gkdb->{$kmer}}) > 1) {
	    			my $keylist = [keys(%{$gkdb->{$kmer}})];
	    			for (my $m=0; $m < (@{$keylist}-1); $m++) {
	    				for (my $n=($m+1); $n < @{$keylist}; $n++) {
	    					if ($genepairs->{$keylist->[$m]}->{$keylist->[$n]} < 10 && $bestorthos->[$keylist->[$m]] == $bestorthos->[$keylist->[$n]]) {
	    						$keep = 0;
	    						$m = 1000;
	    						last;
	    					};
	    				}
	    			}
	    		}
	    		if ($keep == 1) {
	    			foreach my $gene (keys(%{$gkdb->{$kmer}})) {
	    				if ($bestorthos->[$gene] == -1) {
	    					$bestorthos->[$gene] = @{$pangenome->{orthologs}};
	    					my $list = [[$ftrs->[$gene]->id(),0,$currgenome->_reference()]];
	    					foreach my $partner (keys(%{$genepairs->{$gene}})) {
	    						if ($genepairs->{$gene}->{$partner} >= 10 && $bestorthos->[$partner] == -1) {
	    							$bestorthos->[$partner] = @{$pangenome->{orthologs}};
	    							push(@{$list},[$ftrs->[$partner]->id(),0,$currgenome->_reference()]);
	    						}
	    					}
	    					my $seq = $ftrs->[$gene]->protein_translation();
	    					my $index = @{$pangenome->{orthologs}};
	    					my $neworthofam = {
						    	id => $ftrs->[$gene]->id(),
						    	type => $ftrs->[$gene]->type(),
						    	function => $ftrs->[$gene]->function(),
								protein_translation => $ftrs->[$gene]->protein_translation(),
								orthologs => $list
						    };
						    if (!defined($neworthofam->{function})) {
						    	$neworthofam->{function} = "unknown";
						    }
	    					push(@{$pangenome->{orthologs}},$neworthofam);
	    				}
	    				$okdb->{$kmer} = $bestorthos->[$gene];
	    			}
	    		}
    		}
    	}
    	$self->_resetKBaseStore();
    }
    print "Final score computing!\n";
    foreach my $kmer (keys(%{$okdb})) {
    	my $index = $okdb->{$kmer};
    	my $list = $pangenome->{orthologs}->[$index]->{orthologs};
    	my $hits = [];
    	for (my $i=0; $i < @{$list}; $i++) {
    		if (index($proteins->{$list->[$i]->[0]},$kmer) >= 0) {
    			push(@{$hits},$i);
    		}
    	}
    	my $numhits = @{$hits};
    	my $numorthos = @{$list};
    	if ((2*$numhits) >= $numorthos) {
    		foreach my $item (@{$hits}) {
    			$list->[$item]->[1]++;
    		}
    	}
    }
    $pangenome = Bio::KBase::ObjectAPI::KBaseGenomes::Pangenome->new($pangenome);
	$pangenome->orthologs();
	$output = $self->_save_msobject($pangenome,"Pangenome",$input->{workspace},$input->{output_id});
	$self->_clearContext();
    #END build_pangenome
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to build_pangenome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'build_pangenome');
    }
    return($output);
}




=head2 genome_heatmap_from_pangenome

  $output = $obj->genome_heatmap_from_pangenome($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a genome_heatmap_from_pangenome_params
$output is a heat_map_matrix
genome_heatmap_from_pangenome_params is a reference to a hash where the following keys are defined:
	pangenome has a value which is a string
	pangenome_workspace has a value which is a string
	workspace has a value which is a string
heat_map_matrix is a reference to a hash where the following keys are defined:
	is_refs has a value which is a bool
	labels has a value which is a reference to a list where each element is a string
	matrix has a value which is a reference to a list where each element is a reference to a list where each element is a float
bool is an int

</pre>

=end html

=begin text

$input is a genome_heatmap_from_pangenome_params
$output is a heat_map_matrix
genome_heatmap_from_pangenome_params is a reference to a hash where the following keys are defined:
	pangenome has a value which is a string
	pangenome_workspace has a value which is a string
	workspace has a value which is a string
heat_map_matrix is a reference to a hash where the following keys are defined:
	is_refs has a value which is a bool
	labels has a value which is a reference to a list where each element is a string
	matrix has a value which is a reference to a list where each element is a reference to a list where each element is a float
bool is an int


=end text



=item Description

Builds a comparason matrix for genomes included in a pangenome object

=back

=cut

sub genome_heatmap_from_pangenome
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to genome_heatmap_from_pangenome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_heatmap_from_pangenome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN genome_heatmap_from_pangenome
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["pangenome","workspace"],{
    	pangenome_workspace => $input->{workspace}
    });
    my $pangenome = $self->_get_msobject("Pangenome",$input->{pangenome_workspace},$input->{pangenome});
    my $indecies = {};
    my $genomerefs = $pangenome->genome_refs();
    my $output = {
    	references => $genomerefs,
    	labels => $genomerefs,
    	matrix => []
    };
    for (my $i=0; $i < @{$genomerefs}; $i++) {
    	$indecies->{$genomerefs->[$i]} = $i;
    }
    my $orthos = $pangenome->orthologs();
    foreach my $ortholog (@{$orthos}) {
    	my $famorthos = $ortholog->orthologs();
    	for (my $i=0; $i < (@{$famorthos}-1); $i++) {
    		for (my $j=$i+1; $j < @{$famorthos}; $j++) {
    			if (!defined($output->{matrix}->[$indecies->{$famorthos->[$i]->[2]}]->[$indecies->{$famorthos->[$i]->[2]}])) {
    				$output->{matrix}->[$indecies->{$famorthos->[$i]->[2]}]->[$indecies->{$famorthos->[$i]->[2]}] = 0;
    			}
    			$output->{matrix}->[$indecies->{$famorthos->[$i]->[2]}]->[$indecies->{$famorthos->[$i]->[2]}]++;
    		}
    	}
    }
    return $output;
    $self->_clearContext();
    #END genome_heatmap_from_pangenome
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to genome_heatmap_from_pangenome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'genome_heatmap_from_pangenome');
    }
    return($output);
}




=head2 ortholog_family_from_pangenome

  $output = $obj->ortholog_family_from_pangenome($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an ortholog_family_from_pangenome_params
$output is an ortholog_data
ortholog_family_from_pangenome_params is a reference to a hash where the following keys are defined:
	pangenome has a value which is a string
	pangenome_workspace has a value which is a string
	orthologid has a value which is a string
	workspace has a value which is a string
ortholog_data is a reference to a hash where the following keys are defined:
	gene_data has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: a string
	1: a string
	2: a string
	3: a string
	4: a float

	protein_heatmap has a value which is a heat_map_matrix
heat_map_matrix is a reference to a hash where the following keys are defined:
	is_refs has a value which is a bool
	labels has a value which is a reference to a list where each element is a string
	matrix has a value which is a reference to a list where each element is a reference to a list where each element is a float
bool is an int

</pre>

=end html

=begin text

$input is an ortholog_family_from_pangenome_params
$output is an ortholog_data
ortholog_family_from_pangenome_params is a reference to a hash where the following keys are defined:
	pangenome has a value which is a string
	pangenome_workspace has a value which is a string
	orthologid has a value which is a string
	workspace has a value which is a string
ortholog_data is a reference to a hash where the following keys are defined:
	gene_data has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: a string
	1: a string
	2: a string
	3: a string
	4: a float

	protein_heatmap has a value which is a heat_map_matrix
heat_map_matrix is a reference to a hash where the following keys are defined:
	is_refs has a value which is a bool
	labels has a value which is a reference to a list where each element is a string
	matrix has a value which is a reference to a list where each element is a reference to a list where each element is a float
bool is an int


=end text



=item Description

Returns more detailed data from a single ortholog family from a pangenome object

=back

=cut

sub ortholog_family_from_pangenome
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to ortholog_family_from_pangenome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'ortholog_family_from_pangenome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN ortholog_family_from_pangenome
    #END ortholog_family_from_pangenome
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to ortholog_family_from_pangenome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'ortholog_family_from_pangenome');
    }
    return($output);
}




=head2 pangenome_to_proteome_comparison

  $output = $obj->pangenome_to_proteome_comparison($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a pangenome_to_proteome_comparison_params
$output is an object_metadata
pangenome_to_proteome_comparison_params is a reference to a hash where the following keys are defined:
	pangenome has a value which is a string
	pangenome_workspace has a value which is a string
	outputid has a value which is a string
	workspace has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a pangenome_to_proteome_comparison_params
$output is an object_metadata
pangenome_to_proteome_comparison_params is a reference to a hash where the following keys are defined:
	pangenome has a value which is a string
	pangenome_workspace has a value which is a string
	outputid has a value which is a string
	workspace has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Builds a proteome comparison object from a pangenome object

=back

=cut

sub pangenome_to_proteome_comparison
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to pangenome_to_proteome_comparison:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'pangenome_to_proteome_comparison');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN pangenome_to_proteome_comparison
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["pangenome","workspace","genomeone","genometwo"],{
    	pangenome_workspace => $input->{workspace},
    	outputid => $input->{genomeone}."_".$input->{genometwo}."_comp"
    });
    my $pangenome = $self->_get_msobject("Pangenome",$input->{pangenome_workspace},$input->{pangenome});
    my $genomes = $pangenome->genomes();
    my $genomeone;
    my $genometwo;
    for (my $i=0; $i < @{$genomes}; $i++) {
    	if ($genomes->[$i]->_wsname() eq $input->{genomeone} || $genomes->[$i]->id() eq $input->{genomeone}) {
    		$genomeone = $genomes->[$i];
    	}
    	if ($genomes->[$i]->_wsname() eq $input->{genometwo} || $genomes->[$i]->id() eq $input->{genometwo}) {
    		$genometwo = $genomes->[$i];
    	}
    }
    if (!defined($genomeone)) {
    	$self->_error("Could not find ".$input->{genomeone}." in pangenome.");
    }
    if (!defined($genometwo)) {
    	$self->_error("Could not find ".$input->{genometwo}." in pangenome.");
    }
    my $protcomp = {
    	genome1ws => $genomeone->_wsworkspace(),
		genome1id => $genomeone->_wsname(),
		genome2ws => $genometwo->_wsworkspace(),
		genome2id => $genometwo->_wsname(),
		sub_bbh_percent => 0,
		max_evalue => "0",
		proteome1names => [],
		proteome1map => {},
		proteome2names => [],
		proteome2map => {},
		data1 => [],
		data2 => []
    };
    my $ftrs = $genomeone->features();
    my $protonelen = {};
    for(my $i=0; $i < @{$ftrs}; $i++) {
    	push(@{$protcomp->{proteome1names}},$ftrs->[$i]->id());
    	$protcomp->{data1}->[$i] = [];
    	$protcomp->{proteome1map}->{$ftrs->[$i]->id()} = $i;
    	$protonelen->{$ftrs->[$i]->id()} = $ftrs->[$i]->protein_translation_length();
    }
    $ftrs = $genometwo->features();
    my $prottwolen = {};
    for(my $i=0; $i < @{$ftrs}; $i++) {
    	$protcomp->{data2}->[$i] = [];
    	push(@{$protcomp->{proteome2names}},$ftrs->[$i]->id());
    	$protcomp->{proteome2map}->{$ftrs->[$i]->id()} = $i;
    	$prottwolen->{$ftrs->[$i]->id()} = $ftrs->[$i]->protein_translation_length();
    }
    my $orthos = $pangenome->orthologs();
    foreach my $ortholog (@{$orthos}) {
    	my $famorthos = $ortholog->orthologs();
    	my $one;
    	my $two;
    	my $onescore;
    	my $twoscore;
    	for (my $i=0; $i < (@{$famorthos}); $i++) {
    		if (defined($protcomp->{proteome1map}->{$famorthos->[$i]->[0]})) {
    			$one = $famorthos->[$i]->[0];
    			$onescore = $famorthos->[$i]->[1];
    		} elsif (defined($protcomp->{proteome2map}->{$famorthos->[$i]->[0]})) {
    			$two = $famorthos->[$i]->[0];
    			$twoscore = $famorthos->[$i]->[1];
    		}
    	}
    	if (defined($one) && defined($two)) {
    		$protcomp->{data2}->[$protcomp->{proteome2map}->{$two}] = [[$protcomp->{proteome1map}->{$one},floor(100*(($onescore+$twoscore)/2+8)/$prottwolen->{$two}),100]];
    		$protcomp->{data1}->[$protcomp->{proteome1map}->{$one}] = [[$protcomp->{proteome2map}->{$two},floor(100*(($onescore+$twoscore)/2+8)/$protonelen->{$one}),100]];
    	}
    }
    $protcomp = Bio::KBase::ObjectAPI::GenomeComparison::ProteomeComparison->new($protcomp);
    $protcomp->parent($self->_KBaseStore());
    $output = $self->_save_msobject($protcomp,"ProteomeComparison",$input->{workspace},$input->{outputid});
    $self->_clearContext();
    #END pangenome_to_proteome_comparison
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to pangenome_to_proteome_comparison:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'pangenome_to_proteome_comparison');
    }
    return($output);
}




=head2 import_fbamodel

  $modelMeta = $obj->import_fbamodel($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an import_fbamodel_params
$modelMeta is an object_metadata
import_fbamodel_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	biomass has a value which is a string
	reactions has a value which is a reference to a list where each element is a reference to a list containing 4 items:
	0: (id) a string
	1: (direction) a string
	2: (compartment) a string
	3: (gpr) a string

	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	ignore_errors has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
genome_id is a string
workspace_id is a string
fbamodel_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an import_fbamodel_params
$modelMeta is an object_metadata
import_fbamodel_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	biomass has a value which is a string
	reactions has a value which is a reference to a list where each element is a reference to a list containing 4 items:
	0: (id) a string
	1: (direction) a string
	2: (compartment) a string
	3: (gpr) a string

	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	ignore_errors has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
genome_id is a string
workspace_id is a string
fbamodel_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Import a model from an input table of model and gene IDs

=back

=cut

sub import_fbamodel
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_fbamodel');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN import_fbamodel
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genome","workspace"],{
    	reactions => undef,
    	biomass => undef,
    	sbml => undef,
    	genome_workspace => $input->{workspace},
    	model => undef,
    	ignore_errors => 0,
    	source => "Imported",
    	type => "SingleOrganism",
    	template => undef,
    	template_workspace => $input->{workspace},
    	compounds => [],
    });
    my $genome = $self->_get_msobject("Genome",$input->{genome_workspace},$input->{genome});
    my $template;
    if (defined($input->{template})) {
    	$template = $self->_get_msobject("ModelTemplate",$input->{template_workspace},$input->{template});
    } else {
    	my $class = $self->_classify_genome($genome);
		if ($class eq "Gram positive") {
    		$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramPosModelTemplate");
    	} elsif ($class eq "Gram negative") {
    		$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramNegModelTemplate");
    	} elsif ($class eq "Plant") {
    		$template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","PlantModelTemplate");
    	}
    }
    if (!defined($input->{sbml}) && (!defined($input->{biomass}) || !defined($input->{reactions}))) {
    	$self->_error("Must provide either SBML or reaction list to import model");
    } elsif (defined($input->{sbml})) {
    	($input->{reactions},$input->{compounds}) = $self->_parse_SBML($genome,$template->biochemistry(),$input->{sbml});
    }
    my $kbid = $self->_get_new_id($genome->id().".fbamdl.");
    if (!defined($input->{model})) {
    	$input->{model} = $kbid;
    }
    if (ref($input->{biomass}) ne 'ARRAY') {
    	$input->{biomass} = [split(/;/,$input->{biomass})];
    }
    my $model = Bio::KBase::ObjectAPI::KBaseFBA::FBAModel->new({
		id => $kbid,
		source => $input->{source},
		source_id => $input->{model},
		name => $genome->scientific_name(),
		type => $input->{type},
		genome_ref => $genome->_reference(),
		template_ref => $template->_reference(),
		gapfillings => [],
		gapgens => [],
		biomasses => [],
		modelcompartments => [],
		modelcompounds => [],
		modelreactions => []
	});
	$model->parent($self->_KBaseStore());
    #Reprocessing IDs
    my $translation = {};
    for (my $i=0; $i < @{$input->{compounds}}; $i++) {
    	my $cpd = $input->{compounds}->[$i];
    	my $id = $cpd->[0];
    	if ($id =~ m/[^\w]/) {
    		$cpd->[0] =~ s/[^\w]/_/g;
    	}
    	if ($id =~ m/-/) {
    		$cpd->[0] =~ s/-/_/g;
    	}
    	$translation->{$id} = $cpd->[0];
    }
    for (my $i=0; $i < @{$input->{reactions}}; $i++) {
    	my $rxn = $input->{reactions}->[$i];
    	$rxn->[0] =~ s/[^\w]/_/g;
    	if (defined($rxn->[8])) {
    		if ($rxn->[8] =~ m/^\[([A-Za-z])\]\s*:\s*(.+)/) {
    			$rxn->[2] = lc($1);
    			$rxn->[8] = $2;
    		}
    		my $eqn = "| ".$rxn->[8]." |";
    		foreach my $cpd (keys(%{$translation})) {
    			if (index($eqn,$cpd) >= 0 && $cpd ne $translation->{$cpd}) {
    				my $origcpd = $cpd;
    				$cpd =~ s/\+/\\+/g;
    				$cpd =~ s/\(/\\(/g;
    				$cpd =~ s/\)/\\)/g;
    				my $array = [split(/\s$cpd\s/,$eqn)];
    				$eqn = join(" ".$translation->{$origcpd}." ",@{$array});
    				$array = [split(/\s$cpd\[/,$eqn)];
    				$eqn = join(" ".$translation->{$origcpd}."[",@{$array});
    			}
    		}
    		$eqn =~ s/^\|\s//;
    		$eqn =~ s/\s\|$//;
    		while ($eqn =~ m/\[([A-Z])\]/) {
    			my $reqplace = "[".lc($1)."]";
    			$eqn =~ s/\[[A-Z]\]/$reqplace/;
    		}
    		if ($eqn =~ m/<[-=]+>/) {
    			if (!defined($rxn->[1])) {
    				$rxn->[1] = "=";
    			}
    		} elsif ($eqn =~ m/[-=]+>/) {
    			if (!defined($rxn->[1])) {
    				$rxn->[1] = ">";
    			}
    		} elsif ($eqn =~ m/<[-=]+/) {
    			if (!defined($rxn->[1])) {
    				$rxn->[1] = "<";
    			}
    		}
    		$rxn->[8] = $eqn;
    		for (my $j=0; $j < @{$input->{biomass}}; $j++) {
	    		if ($rxn->[0] eq $input->{biomass}->[$j]) {
	    			$input->{biomass}->[$j] = $eqn;
	    			splice(@{$input->{reactions}},$i,1);
	    			$i--;
	    		}
    		}
    	}
    }
    for (my $i=0; $i < @{$input->{biomass}}; $i++) {
	    my $eqn = "| ".$input->{biomass}->[$i]." |";
	    foreach my $cpd (keys(%{$translation})) {
	    	if (index($input->{biomass}->[$i],$cpd) >= 0 && $cpd ne $translation->{$cpd}) {
	    		my $origcpd = $cpd;
	    		$cpd =~ s/\+/\\+/g;
	    		$cpd =~ s/\(/\\(/g;
	    		$cpd =~ s/\)/\\)/g;
	    		my $array = [split(/\s$cpd\s/,$eqn)];
	    		$eqn = join(" ".$translation->{$origcpd}." ",@{$array});
	    		$array = [split(/\s$cpd\[/,$eqn)];
	    		$eqn = join(" ".$translation->{$origcpd}."[",@{$array});
	    	}
	    }
	    $eqn =~ s/^\|\s//;
	    $eqn =~ s/\s\|$//;
	    while ($eqn =~ m/\[([A-Z])\]/) {
	    	my $reqplace = "[".lc($1)."]";
	    	$eqn =~ s/\[[A-Z]\]/$reqplace/;
	    }
	    $input->{biomass}->[$i] = $eqn;
    }
    #Loading reactions to model
	my $missingGenes = {};
	my $missingCompounds = {};
	my $missingReactions = {};
	my $compoundhash = {};
	for (my $i=0; $i < @{$input->{compounds}}; $i++) {
		$compoundhash->{$input->{compounds}->[$i]->[0]} = $input->{compounds}->[$i];
	}
	for (my  $i=0; $i < @{$input->{reactions}}; $i++) {
		my $rxnrow = $input->{reactions}->[$i];
		my $input = {
		    reaction => $rxnrow->[0],
		    direction => $rxnrow->[1],
		    compartment => $rxnrow->[2],
		    compartmentIndex => 0,
		    gpr => $rxnrow->[3],
		    removeReaction => 0,
		    addReaction => 1,
		    compounds => $compoundhash
		};
		if (defined($rxnrow->[4])) {
			$input->{name} = $rxnrow->[4];
		}
		if (defined($rxnrow->[5])) {
			$input->{enzyme} = $rxnrow->[5];
		}
		if (defined($rxnrow->[6])) {
			$input->{pathway} = $rxnrow->[6];
		}
		if (defined($rxnrow->[7])) {
			$input->{reference} = $rxnrow->[7];
		}
		if (defined($rxnrow->[8])) {
			$input->{equation} = $rxnrow->[8];
		}
		#print $input->{equation}."\n";
		$model->addModelReaction($input);
		#if (defined($report->{missing_genes})) {
		#	for (my $i=0; $i < @{$report->{missing_genes}}; $i++) {
		#		$missingGenes->{$report->{missing_genes}->[$i]} = 1;
		#	}
		#}
		#if (defined($report->{missing_compounds})) {
		#	for (my $i=0; $i < @{$report->{missing_compounds}}; $i++) {
		#		$missingCompounds->{$report->{missing_compounds}->[$i]} = 1;
		#	}
		#}
		#if (defined($report->{missing_reactions})) {
		#	for (my $i=0; $i < @{$report->{missing_reactions}}; $i++) {
		#		$missingReactions->{$report->{missing_reactions}->[$i]} = 1;
		#	}
		#}
	}
	my $rxns = $model->modelreactions();
	for (my $i=0; $i < @{$rxns}; $i++) {
		my $rxn = $rxns->[$i];
		my $rgts = $rxn->modelReactionReagents();
		if (@{$rgts} == 1 && $rgts->[0]->modelcompound()->id() =~ m/_e\d+$/) {
			print "Removing reaction:".$rxn->definition()."\n";
			$model->remove("modelreactions",$rxn);
		}	
	}
	for (my $i=0; $i < @{$input->{biomass}}; $i++) {
		print "Biomass:".$input->{biomass}->[$i]."\n";
		my $report = $model->adjustBiomassReaction({
			biomass => "bio".($i+1),
			equation => $input->{biomass}->[$i],
			compartment => "c",
			compartmentIndex => 0,
		    compounds => $compoundhash
		});
	}
	my $msg = "";
	#if (keys(%{$missingReactions}) > 0) {
	#	$msg .= "Missing reactions:".join(";",keys(%{$missingReactions}))."\n";
	#}
	#if (keys(%{$missingCompounds}) > 0) {
	#	$msg .= "Missing biomass compounds:".join(";",keys(%{$missingCompounds}))."\n";
	#}
	#if (keys(%{$missingGenes}) > 0) {
	#	$msg .= "Missing genes:".join(";",keys(%{$missingGenes}))."\n";
	#}
	if (length($msg) > 0 && $input->{ignore_errors} == 0) {
		$self->_error($msg);
	}

	#Saving imported model
	$modelMeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{model});
    $self->_clearContext();
    #END import_fbamodel
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_fbamodel');
    }
    return($modelMeta);
}




=head2 export_fbamodel

  $output = $obj->export_fbamodel($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an export_fbamodel_params
$output is a string
export_fbamodel_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	fbas has a value which is a reference to a list where each element is a fba_id
	format has a value which is a string
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
fba_id is a string

</pre>

=end html

=begin text

$input is an export_fbamodel_params
$output is a string
export_fbamodel_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	fbas has a value which is a reference to a list where each element is a fba_id
	format has a value which is a string
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
fba_id is a string


=end text



=item Description

This function exports the specified FBAModel to a specified format (sbml,html)

=back

=cut

sub export_fbamodel
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to export_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_fbamodel');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN export_fbamodel
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["model","workspace","format"],{});
    my $model = $self->_get_msobject("FBAModel",$input->{workspace},$input->{model});
    my $fbas;
    foreach my $fba_id (@{$input->{fbas}}) {
    	push @$fbas, $self->_get_msobject("FBA",$input->{workspace},$fba_id);
    }
    $output = $model->export({format => $input->{format}, fbas => $fbas});
    $self->_clearContext();
    #END export_fbamodel
    my @_bad_returns;
    (!ref($output)) or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to export_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_fbamodel');
    }
    return($output);
}




=head2 export_object

  $output = $obj->export_object($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an export_object_params
$output is a string
export_object_params is a reference to a hash where the following keys are defined:
	reference has a value which is a workspace_ref
	type has a value which is a string
	format has a value which is a string
	auth has a value which is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an export_object_params
$output is a string
export_object_params is a reference to a hash where the following keys are defined:
	reference has a value which is a workspace_ref
	type has a value which is a string
	format has a value which is a string
	auth has a value which is a string
workspace_ref is a string


=end text



=item Description

This function prints the object pointed to by the input reference in the specified format

=back

=cut

sub export_object
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to export_object:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_object');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN export_object
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["reference","type"],{
    	format => "html"
    });
 	my $array = [split(/\//,$input->{reference})];
    my $obj = $self->_get_msobject($input->{type},$array->[0],$array->[1]);
	if (ref($obj) eq "HASH") {
		my $JSON = JSON::XS->new->utf8(1);
    	$output = $JSON->encode($obj);
	} elsif (ref($obj) =~ m/Bio::KBase::ObjectAPI/) {
		$output = $obj->export({format => $input->{format}});;
	} else {
		$output = $obj;
	}
    $self->_clearContext();
    #END export_object
    my @_bad_returns;
    (!ref($output)) or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to export_object:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_object');
    }
    return($output);
}




=head2 export_genome

  $output = $obj->export_genome($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an export_genome_params
$output is a string
export_genome_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
genome_id is a string
workspace_id is a string

</pre>

=end html

=begin text

$input is an export_genome_params
$output is a string
export_genome_params is a reference to a hash where the following keys are defined:
	genome has a value which is a genome_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
genome_id is a string
workspace_id is a string


=end text



=item Description

This function exports the specified FBAModel to a specified format (sbml,html)

=back

=cut

sub export_genome
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to export_genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_genome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN export_genome
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["genome","workspace","format"],{});
    my $genome = $self->_get_msobject("Genome",$input->{workspace},$input->{genome});
    $output = $genome->export({format => $input->{format}});
    $self->_clearContext();
    #END export_genome
    my @_bad_returns;
    (!ref($output)) or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to export_genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_genome');
    }
    return($output);
}




=head2 adjust_model_reaction

  $modelMeta = $obj->adjust_model_reaction($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an adjust_model_reaction_params
$modelMeta is an object_metadata
adjust_model_reaction_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	reaction has a value which is a reference to a list where each element is a reaction_id
	direction has a value which is a reference to a list where each element is a string
	compartment has a value which is a reference to a list where each element is a compartment_id
	compartmentIndex has a value which is a reference to a list where each element is an int
	gpr has a value which is a reference to a list where each element is a string
	removeReaction has a value which is a bool
	addReaction has a value which is a bool
	overwrite has a value which is a bool
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
reaction_id is a string
compartment_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an adjust_model_reaction_params
$modelMeta is an object_metadata
adjust_model_reaction_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	reaction has a value which is a reference to a list where each element is a reaction_id
	direction has a value which is a reference to a list where each element is a string
	compartment has a value which is a reference to a list where each element is a compartment_id
	compartmentIndex has a value which is a reference to a list where each element is an int
	gpr has a value which is a reference to a list where each element is a string
	removeReaction has a value which is a bool
	addReaction has a value which is a bool
	overwrite has a value which is a bool
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
reaction_id is a string
compartment_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Enables the manual addition of a reaction to model

=back

=cut

sub adjust_model_reaction
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_model_reaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_model_reaction');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN adjust_model_reaction
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["reaction","model","workspace"],{
    	model_workspace => $input->{workspace},
    	direction => [undef],
    	compartment => ["c"],
    	compartmentIndex => [0],
    	gpr => [undef],
    	removeReaction => 0,
    	addReaction => 0,
    	compounds => [],
		outputid => $input->{model},
		equation => [undef]
    });

    # For reverse compatibility, if we are given scalar arguments for the reactions or other multi-component objects
    # we turn them into array refs.
    if ( ref($input->{equation}) eq 'SCALAR' ) {  $input->{equation} = [ $input->{equation} ];   }
    if ( ref($input->{reaction}) eq 'SCALAR' ) {  $input->{reaction} = [ $input->{reaction} ];   }
    if ( ref($input->{direction}) eq 'SCALAR' ) { $input->{direction} = [ $input->{direction} ]; }
    if ( ref($input->{gpr}) eq 'SCALAR' ) {  $input->{gpr} = [ $input->{gpr} ];  }
    if ( ref($input->{compartment}) eq 'SCALAR') { $input->{compartment} = [ $input->{compartment} ]; }
    if ( ref($input->{compartmentIndex}) eq 'SCALAR') { $input->{compartmentIndex} = [ $input->{compartmentIndex} ]; }

    # If we receive entries for compartments, directions, gprs, etc... they must all either have the same size
    # or be size 1 (in which case we apply the same value to all of the elements)
    my $nreactions = scalar @{ $input->{reaction} };
    my $ncomps = scalar @{ $input->{compartment} };
    my $ncompidx = scalar @{ $input->{compartmentIndex} };
    my $ndir = scalar @{ $input->{direction} };
    my $ngpr = scalar @{ $input->{gpr} };
    if( !($ncomps == $nreactions || $ncomps == 1) ||
	!($ncompidx == $nreactions || $ncompidx == 1) ||
	!($ndir == $nreactions || $ndir == 1) ||
	!($ngpr == $nreactions || $ngpr == 1) ) {
	die "Size mismatch between number of reactions and number of GPR, direction, compartment or compartmentIndexes";
    }

    my $model = $self->_get_msobject("FBAModel",$input->{workspace},$input->{model});
    my $compoundhash = {};
	for (my $i=0; $i < @{$input->{compounds}}; $i++) {
		$compoundhash->{$input->{compounds}->[$i]->[0]} = $input->{compounds}->[$i];
	}
    for (my $i=0; $i < @{$input->{reaction}}; $i++)  {
		my $equation;
		my $gpr;
		my $dir;
		my $comp;
		my $compidx;
		if ( scalar @{$input->{gpr}} eq 1) {
		    $gpr = $input->{gpr}->[0];
		} else {
		   	$gpr = $input->{gpr}->[$i];
		}
		if ( scalar @{$input->{direction}} eq 1 ) {
		    $dir = $input->{direction}->[0];
		} else {
		    $dir = $input->{direction}->[$i];
		}
		if ( scalar @{$input->{equation}} eq 1 ) {
		    $equation = $input->{equation}->[0];
		} else {
		    $equation = $input->{equation}->[$i];
		}
		if ( scalar @{$input->{compartment}} eq 1 ) {  
		    $comp = $input->{compartment}->[0]; 
		} else {  
		    $comp = $input->{compartment}->[$i];
		}
		if ( scalar @{$input->{compartmentIndex}} eq 1 ) {
		    $compidx = $input->{compartmentIndex}->[0];
		} else {
		    $compidx = $input->{compartmentIndex}->[$i];
		}
		if (defined($input->{removeReaction}) && $input->{removeReaction} == 1) {
			$model->removeModelReaction({
			    reaction => $input->{reaction}->[$i]
			});
		} elsif (defined($input->{addReaction}) && $input->{addReaction} == 1) {
			$model->addModelReaction({
			    reaction => $input->{reaction}->[$i],
			    direction => $dir,
			    compartment => $comp,
			    compartmentIndex => $compidx,
			    gpr => $gpr,
			    compounds => $compoundhash,
			    equation => $equation
			});
		} else {
			$model->adjustModelReaction({
			    reaction => $input->{reaction}->[$i],
			    direction => $dir,
			    gpr => $gpr
			});
		}
	}
    $modelMeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{outputid});
    $self->_clearContext();
    #END adjust_model_reaction
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_model_reaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_model_reaction');
    }
    return($modelMeta);
}




=head2 adjust_biomass_reaction

  $modelMeta = $obj->adjust_biomass_reaction($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an adjust_biomass_reaction_params
$modelMeta is an object_metadata
adjust_biomass_reaction_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	biomass has a value which is a biomass_id
	coefficients has a value which is a reference to a list where each element is a float
	compounds has a value which is a reference to a list where each element is a compound_id
	compartments has a value which is a reference to a list where each element is a compartment_id
	compartmentIndecies has a value which is a reference to a list where each element is an int
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
biomass_id is a string
compound_id is a string
compartment_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an adjust_biomass_reaction_params
$modelMeta is an object_metadata
adjust_biomass_reaction_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	biomass has a value which is a biomass_id
	coefficients has a value which is a reference to a list where each element is a float
	compounds has a value which is a reference to a list where each element is a compound_id
	compartments has a value which is a reference to a list where each element is a compartment_id
	compartmentIndecies has a value which is a reference to a list where each element is an int
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
biomass_id is a string
compound_id is a string
compartment_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Enables the manual adjustment of model biomass reaction

=back

=cut

sub adjust_biomass_reaction
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_biomass_reaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_biomass_reaction');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN adjust_biomass_reaction
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["compounds","model","workspace"],{
    	biomass => "bio1",
    	coefficients => [],
    	compartments => [],
    	compartmentIndices => [],
    	output_id => $input->{model}
    });
	my $model = $self->_get_msobject("FBAModel",$input->{workspace},$input->{model});
	for (my $i=0; $i < @{$input->{compounds}}; $i++) {
		if (!defined($input->{coefficients}->[$i])) {
			$input->{coefficients}->[$i] = 1;
		}
		if (!defined($input->{compartments}->[$i])) {
			$input->{compartments}->[$i] = 'c';
		}
		if (!defined($input->{compartmentIndices}->[$i])) {
			$input->{compartmentIndices}->[$i] = '0';
		}
		$model->adjustBiomassReaction({compound => $input->{compounds}->[$i],
					       coefficient => $input->{coefficients}->[$i],
					       biomass => $input->{biomass},
					       compartment => $input->{compartments}->[$i],
					       compartmentIndex => $input->{compartmentIndices}->[$i]});
	}
	$modelMeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{output_id});
    $self->_clearContext();
    #END adjust_biomass_reaction
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_biomass_reaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_biomass_reaction');
    }
    return($modelMeta);
}




=head2 addmedia

  $mediaMeta = $obj->addmedia($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an addmedia_params
$mediaMeta is an object_metadata
addmedia_params is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	workspace has a value which is a workspace_id
	name has a value which is a string
	isDefined has a value which is a bool
	isMinimal has a value which is a bool
	type has a value which is a string
	compounds has a value which is a reference to a list where each element is a string
	concentrations has a value which is a reference to a list where each element is a float
	maxflux has a value which is a reference to a list where each element is a float
	minflux has a value which is a reference to a list where each element is a float
	overwrite has a value which is a bool
	auth has a value which is a string
media_id is a string
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an addmedia_params
$mediaMeta is an object_metadata
addmedia_params is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	workspace has a value which is a workspace_id
	name has a value which is a string
	isDefined has a value which is a bool
	isMinimal has a value which is a bool
	type has a value which is a string
	compounds has a value which is a reference to a list where each element is a string
	concentrations has a value which is a reference to a list where each element is a float
	maxflux has a value which is a reference to a list where each element is a float
	minflux has a value which is a reference to a list where each element is a float
	overwrite has a value which is a bool
	auth has a value which is a string
media_id is a string
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Add media condition to workspace

=back

=cut

sub addmedia
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to addmedia:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'addmedia');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($mediaMeta);
    #BEGIN addmedia
	$self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["media","workspace","compounds"],{
    	name => $input->{media},
    	isDefined => 0,
    	isMinimal => 0,
    	type => "custom",
    	concentrations => [],
    	maxflux => [],
    	minflux => [],
    	biochemistry => "default",
    	biochemistry_workspace => "kbase"
    });
    #Creating the media object from the specifications
    my $bio = $self->_get_msobject("Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
    my $media = Bio::KBase::ObjectAPI::KBaseBiochem::Media->new({
    	id => "kb|media.".$self->_idServer()->allocate_id_range("kb|media",1),
    	name => $input->{name},
    	isDefined => $input->{isDefined},
    	isMinimal => $input->{isMinimal},
    	type => $input->{type},
    	source_id => $input->{media}
    });
    my $missing = [];
    my $found = [];
    for (my $i=0; $i < @{$input->{compounds}}; $i++) {
    	my $name = $input->{compounds}->[$i];
    	my $cpdobj = $bio->searchForCompound($name);
    	if (defined($cpdobj)) {
	    	my $data = {
	    		compound_ref => $bio->_reference()."/compounds/id/".$cpdobj->id(),
	    		concentration => 0.001,
	    		maxFlux => 100,
	    		minFlux => -100
	    	};
	    	if (defined($input->{concentrations}->[$i])) {
	    		$data->{concentration} = $input->{concentrations}->[$i];
	    	}
	    	if (defined($input->{maxflux}->[$i])) {
	    		$data->{maxFlux} = $input->{maxflux}->[$i];
	    	}
	    	if (defined($input->{minflux}->[$i])) {
	    		$data->{minFlux} = $input->{minflux}->[$i];
	    	}
	    	$media->add("mediacompounds",$data);
	    	push(@{$found},$cpdobj->id());
    	} else {
    		push(@{$missing},$input->{compounds}->[$i]);
    	}
    }
    #Checking that all compounds specified for media were found
	if (defined($missing->[0])) {
		$self->_error("Compounds specified for media not found: ".join(";",@{$missing}),'addmedia');
	}
    #Saving media in database
    $media->parent($self->_KBaseStore());
    $mediaMeta = $self->_save_msobject($media,"Media",$input->{workspace},$input->{media});
	$self->_clearContext();
    #END addmedia
    my @_bad_returns;
    (ref($mediaMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"mediaMeta\" (value was \"$mediaMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to addmedia:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'addmedia');
    }
    return($mediaMeta);
}




=head2 export_media

  $output = $obj->export_media($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an export_media_params
$output is a string
export_media_params is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
media_id is a string
workspace_id is a string

</pre>

=end html

=begin text

$input is an export_media_params
$output is a string
export_media_params is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
media_id is a string
workspace_id is a string


=end text



=item Description

Exports media in specified format (html,readable)

=back

=cut

sub export_media
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to export_media:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_media');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN export_media
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["media","workspace","format"],{});
    my $med = $self->_get_msobject("Media",$input->{workspace},$input->{media});
    $output = $med->export({
	    format => $input->{format}
	});
	$self->_clearContext();
    #END export_media
    my @_bad_returns;
    (!ref($output)) or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to export_media:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_media');
    }
    return($output);
}




=head2 runfba

  $fbaMeta = $obj->runfba($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a runfba_params
$fbaMeta is an object_metadata
runfba_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	fva has a value which is a bool
	simulateko has a value which is a bool
	minimizeflux has a value which is a bool
	findminmedia has a value which is a bool
	notes has a value which is a string
	fba has a value which is a fba_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
	add_to_model has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
fba_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a runfba_params
$fbaMeta is an object_metadata
runfba_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	fva has a value which is a bool
	simulateko has a value which is a bool
	minimizeflux has a value which is a bool
	findminmedia has a value which is a bool
	notes has a value which is a string
	fba has a value which is a fba_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
	add_to_model has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
fba_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Run flux balance analysis and return ID of FBA object with results

=back

=cut

sub runfba
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to runfba:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'runfba');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($fbaMeta);
    #BEGIN runfba
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["model","workspace"],{
		formulation => undef,
		fva => 0,
		simulateko => 0,
		minimizeflux => 0,
		findminmedia => 0,
		notes => "",
		model_workspace => $input->{workspace},
		fba => undef,
		biomass => undef
	});
	my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
	if (!defined($input->{fba})) {
		$input->{fba} = $self->_get_new_id($input->{model}.".fba.");
	}
	$input->{formulation} = $self->_setDefaultFBAFormulation($input->{formulation});
	#Creating FBAFormulation Object
	my $fba = $self->_buildFBAObject($input->{formulation},$model,$input->{workspace},$input->{fba});
	$fba->fva($input->{fva});
	$fba->comboDeletions($input->{simulateko});
	$fba->fluxMinimization($input->{minimizeflux});
	$fba->findMinimalMedia($input->{findminmedia});
	if (defined($input->{biomass}) && defined($fba->biomassflux_objterms()->{bio1})) {
		my $bio = $model->searchForBiomass($input->{biomass});
		if (defined($bio)) {
			delete $fba->biomassflux_objterms()->{bio1};
			$fba->biomassflux_objterms()->{$bio->id()} = 1;
		}			
	}
	if (defined($input->{formulation}->{eflux_sample}) && defined($input->{formulation}->{eflux_workspace})) {
		my $scores = $self->_compute_eflux_scores($model,$input->{formulation}->{eflux_series}, $input->{formulation}->{eflux_sample}, $input->{formulation}->{eflux_workspace});
		$self->_add_eflux_bounds($fba, $model, $scores, $input->{formulation}->{eflux_sample});
	}

    #Running FBA
    my $objective;
    eval {
		local $SIG{ALRM} = sub { die "FBA timed out! Model likely contains numerical instability!" };
		alarm 3600;
		$objective = $fba->runFBA();
		alarm 0;
	};
	if ($@) {
		$self->_error($@);
    }
    if (!defined($objective)) {
    	$self->_error("FBA failed with no solution returned!");
    }
	$fbaMeta = $self->_save_msobject($fba,"FBA",$input->{workspace},$input->{fba});
    $fbaMeta->[10]->{Media} = $input->{formulation}->{media_workspace}."/".$input->{formulation}->{media};
    $fbaMeta->[10]->{Objective} = $objective;

    $self->_clearContext();
    #END runfba
    my @_bad_returns;
    (ref($fbaMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"fbaMeta\" (value was \"$fbaMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to runfba:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'runfba');
    }
    return($fbaMeta);
}




=head2 generate_model_stats

  $output = $obj->generate_model_stats($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a generate_model_stats_params
$output is a model_statistics
generate_model_stats_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
fbamodel_id is a string
workspace_id is a string
model_statistics is a reference to a hash where the following keys are defined:
	total_reactions has a value which is an int
	total_genes has a value which is an int
	total_compounds has a value which is an int
	extracellular_compounds has a value which is an int
	intracellular_compounds has a value which is an int
	transport_reactions has a value which is an int
	subsystem_reactions has a value which is an int
	subsystem_genes has a value which is an int
	spontaneous_reactions has a value which is an int
	reactions_with_genes has a value which is an int
	gapfilled_reactions has a value which is an int
	model_genes has a value which is an int
	minimal_essential_genes has a value which is an int
	complete_essential_genes has a value which is an int
	minimal_essential_reactions has a value which is an int
	complete_essential_reactions has a value which is an int
	minimal_blocked_reactions has a value which is an int
	complete_blocked_reactions has a value which is an int
	minimal_variable_reactions has a value which is an int
	complete_variable_reactions has a value which is an int
	growth_complete_media has a value which is a bool
	growth_minimal_media has a value which is a bool
	subsystems has a value which is a reference to a list where each element is a subsystem_statistics
bool is an int
subsystem_statistics is a reference to a hash where the following keys are defined:
	name has a value which is a string
	class has a value which is a string
	subclass has a value which is a string
	genes has a value which is an int
	reactions has a value which is an int
	model_genes has a value which is an int
	minimal_essential_genes has a value which is an int
	complete_essential_genes has a value which is an int
	minimal_essential_reactions has a value which is an int
	complete_essential_reactions has a value which is an int
	minimal_blocked_reactions has a value which is an int
	complete_blocked_reactions has a value which is an int
	minimal_variable_reactions has a value which is an int
	complete_variable_reactions has a value which is an int

</pre>

=end html

=begin text

$input is a generate_model_stats_params
$output is a model_statistics
generate_model_stats_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
fbamodel_id is a string
workspace_id is a string
model_statistics is a reference to a hash where the following keys are defined:
	total_reactions has a value which is an int
	total_genes has a value which is an int
	total_compounds has a value which is an int
	extracellular_compounds has a value which is an int
	intracellular_compounds has a value which is an int
	transport_reactions has a value which is an int
	subsystem_reactions has a value which is an int
	subsystem_genes has a value which is an int
	spontaneous_reactions has a value which is an int
	reactions_with_genes has a value which is an int
	gapfilled_reactions has a value which is an int
	model_genes has a value which is an int
	minimal_essential_genes has a value which is an int
	complete_essential_genes has a value which is an int
	minimal_essential_reactions has a value which is an int
	complete_essential_reactions has a value which is an int
	minimal_blocked_reactions has a value which is an int
	complete_blocked_reactions has a value which is an int
	minimal_variable_reactions has a value which is an int
	complete_variable_reactions has a value which is an int
	growth_complete_media has a value which is a bool
	growth_minimal_media has a value which is a bool
	subsystems has a value which is a reference to a list where each element is a subsystem_statistics
bool is an int
subsystem_statistics is a reference to a hash where the following keys are defined:
	name has a value which is a string
	class has a value which is a string
	subclass has a value which is a string
	genes has a value which is an int
	reactions has a value which is an int
	model_genes has a value which is an int
	minimal_essential_genes has a value which is an int
	complete_essential_genes has a value which is an int
	minimal_essential_reactions has a value which is an int
	complete_essential_reactions has a value which is an int
	minimal_blocked_reactions has a value which is an int
	complete_blocked_reactions has a value which is an int
	minimal_variable_reactions has a value which is an int
	complete_variable_reactions has a value which is an int


=end text



=item Description

Generate statistics with model and associated genome properties

=back

=cut

sub generate_model_stats
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to generate_model_stats:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'generate_model_stats');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN generate_model_stats
	$input = $self->_setContext($ctx,$input,{
    	model => {type => "KBaseFBA.FBAModel",ws => "model_workspace"}
	},["model"],{model_workspace => $input->{workspace}});
    my $model = $input->{model};
    $output = $model->compute_model_stats();
    $self->_clearContext();
    #END generate_model_stats
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to generate_model_stats:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'generate_model_stats');
    }
    return($output);
}




=head2 minimize_reactions

  $fbaMeta = $obj->minimize_reactions($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a minimize_reactions_params
$fbaMeta is an object_metadata
minimize_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	reactions has a value which is a reference to a list where each element is a string
	all_model_reactions has a value which is a bool
	reaction_costs has a value which is a reference to a hash where the key is a string and the value is a float
	output_id has a value which is a fba_id
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
fba_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a minimize_reactions_params
$fbaMeta is an object_metadata
minimize_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	reactions has a value which is a reference to a list where each element is a string
	all_model_reactions has a value which is a bool
	reaction_costs has a value which is a reference to a hash where the key is a string and the value is a float
	output_id has a value which is a fba_id
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
fba_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Minimize the specified set of reactions while maintaining the FBA objective above a specified threshold

=back

=cut

sub minimize_reactions
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to minimize_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'minimize_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($fbaMeta);
    #BEGIN minimize_reactions
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["model","workspace"],{
		model_workspace => $input->{workspace},
		formulation => undef,
		reactions => [],
		all_model_reactions => 0,
		reaction_costs => {},
		output_id => undef,
		biomass => undef,
		timelimit => 86000,
		solver => undef
	});    
	my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
	if (!defined($input->{output_id})) {
		$input->{output_id} = $self->_get_new_id($input->{model}.".fba.");
	}
	$input->{formulation} = $self->_setDefaultFBAFormulation($input->{formulation});
	#Creating FBAFormulation Object
	my $fba = $self->_buildFBAObject($input->{formulation},$model,$input->{workspace},$input->{fba});
	$fba->minimize_reactions(1);
	if (@{$input->{reactions}} == 0 || $input->{all_model_reactions} == 1) {
		my $mdlrxns = $model->modelreactions();
		for (my $i=0; $i < @{$mdlrxns}; $i++) {
			$fba->minimize_reaction_costs()->{$mdlrxns->[$i]->id()} = 1;
			if (defined($input->{reaction_costs}->{$mdlrxns->[$i]->id()})) {
				$fba->minimize_reaction_costs()->{$mdlrxns->[$i]->id()} = $input->{reaction_costs}->{$mdlrxns->[$i]->id()};
			}
		}
	} else {
		for (my $i=0; $i < @{$input->{reactions}}; $i++) {
			my $mdlrxn = $model->searchForReaction($input->{reactions}->[$i]);
			if (defined($mdlrxn)) {
				$fba->minimize_reaction_costs()->{$mdlrxn->id()} = 1;
				if (defined($input->{reaction_costs}->{$mdlrxn->id()})) {
					$fba->minimize_reaction_costs()->{$mdlrxn->id()} = $input->{reaction_costs}->{$mdlrxn->id()};
				}
			}
		}
	}
	$fba->inputfiles()->{"InactiveModelReactions.txt"} = ["bio1"];
	$fba->fluxUseVariables(1);
	$fba->decomposeReversibleFlux(1);
	if (defined($input->{biomass}) && defined($fba->biomassflux_objterms()->{bio1})) {
		my $bio = $model->searchForBiomass($input->{biomass});
		if (defined($bio)) {
			delete $fba->biomassflux_objterms()->{bio1};
			$fba->inputfiles()->{"InactiveModelReactions.txt"} = [$bio->id()];
			$fba->biomassflux_objterms()->{$bio->id()} = 1;
		}			
	}
	$fba->parameters()->{"just print LP file"} = "0";
	$fba->parameters()->{"use database fields"} = "1";
	$fba->parameters()->{"REVERSE_USE;FORWARD_USE;REACTION_USE"} = "1";
	$fba->parameters()->{"CPLEX solver time limit"} = $input->{timelimit};
	$fba->parameters()->{"Recursive MILP timeout"} = $input->{timelimit};
	$fba->parameters()->{"Perform gap filling"} = "1";
	$fba->parameters()->{"Add positive use variable constraints"} = "0";
	$fba->outputfiles()->{"ProblemReport.txt"} = [];
	$fba->parameters()->{"Biomass modification hypothesis"} = "0";
    if (defined($input->{solver})) {
    	$fba->parameters()->{MFASolver} = uc($input->{solver});
    }
    #Running FBA
    my $objective;
    eval {
		local $SIG{ALRM} = sub { die "FBA timed out! Model likely contains numerical instability!" };
		alarm 90000;
		$objective = $fba->runFBA();
		alarm 0;
	};
	if ($@) {
		$self->_error($@);
    }
    if (!defined($objective)) {
    	$self->_error("FBA failed with no solution returned!");
    }
	$fbaMeta = $self->_save_msobject($fba,"FBA",$input->{workspace},$input->{output_id});
    $fbaMeta->[10]->{Objective} = $objective;
    $self->_clearContext();
    #END minimize_reactions
    my @_bad_returns;
    (ref($fbaMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"fbaMeta\" (value was \"$fbaMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to minimize_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'minimize_reactions');
    }
    return($fbaMeta);
}




=head2 export_fba

  $output = $obj->export_fba($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an export_fba_params
$output is a string
export_fba_params is a reference to a hash where the following keys are defined:
	fba has a value which is a fba_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
fba_id is a string
workspace_id is a string

</pre>

=end html

=begin text

$input is an export_fba_params
$output is a string
export_fba_params is a reference to a hash where the following keys are defined:
	fba has a value which is a fba_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
fba_id is a string
workspace_id is a string


=end text



=item Description

Export an FBA solution for viewing

=back

=cut

sub export_fba
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to export_fba:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_fba');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN export_fba
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["fba","workspace","format"],{});
    my $fba = $self->_get_msobject("FBA",$input->{workspace},$input->{fba});
    $output = $fba->export({
	    format => $input->{format}
	});
	$self->_clearContext();
    #END export_fba
    my @_bad_returns;
    (!ref($output)) or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to export_fba:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_fba');
    }
    return($output);
}




=head2 import_phenotypes

  $output = $obj->import_phenotypes($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an import_phenotypes_params
$output is an object_metadata
import_phenotypes_params is a reference to a hash where the following keys are defined:
	phenotypeSet has a value which is a phenotype_set_id
	workspace has a value which is a workspace_id
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	phenotypes has a value which is a reference to a list where each element is a Phenotype
	name has a value which is a string
	source has a value which is a string
	ignore_errors has a value which is a bool
	auth has a value which is a string
phenotype_set_id is a string
workspace_id is a string
genome_id is a string
Phenotype is a reference to a list containing 6 items:
	0: (geneKO) a reference to a list where each element is a feature_id
	1: (baseMedia) a media_id
	2: (media_workspace) a workspace_id
	3: (additionalCpd) a reference to a list where each element is a compound_id
	4: (normalizedGrowth) a float
	5: (label) a string
feature_id is a string
media_id is a string
compound_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an import_phenotypes_params
$output is an object_metadata
import_phenotypes_params is a reference to a hash where the following keys are defined:
	phenotypeSet has a value which is a phenotype_set_id
	workspace has a value which is a workspace_id
	genome has a value which is a genome_id
	genome_workspace has a value which is a workspace_id
	phenotypes has a value which is a reference to a list where each element is a Phenotype
	name has a value which is a string
	source has a value which is a string
	ignore_errors has a value which is a bool
	auth has a value which is a string
phenotype_set_id is a string
workspace_id is a string
genome_id is a string
Phenotype is a reference to a list containing 6 items:
	0: (geneKO) a reference to a list where each element is a feature_id
	1: (baseMedia) a media_id
	2: (media_workspace) a workspace_id
	3: (additionalCpd) a reference to a list where each element is a compound_id
	4: (normalizedGrowth) a float
	5: (label) a string
feature_id is a string
media_id is a string
compound_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Loads the specified phenotypes into the workspace

=back

=cut

sub import_phenotypes
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_phenotypes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_phenotypes');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN import_phenotypes
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["workspace","genome","phenotypes"],{
		phenotypeSet => undef,
		genome_workspace => $input->{workspace},
		ignore_errors => 0,
		biochemistry => "default",
		biochemistry_workspace => "kbase",
		name => undef,
		source => "unknown",
		type => "unspecified",
	});
	my $genomeObj = $self->_get_msobject("Genome",$input->{genome_workspace},$input->{genome});
	my $kbid = $self->_get_new_id($genomeObj->id().".phe.");
	my $uid = $input->{genome}.".phe.".$input->{type};
	if (!defined($input->{phenotypeSet})) {
		$input->{phenotypeSet} = $uid;
	}
	if (!defined($input->{name})) {
		$input->{name} = $input->{phenotypeSet};
	}
	
	my $phenoset = Bio::KBase::ObjectAPI::KBasePhenotypes::PhenotypeSet->new({
		id => $kbid,
		source_id => $input->{phenotypeSet},
		source => $input->{source},
		name => $input->{name},
		genome_ref => $genomeObj->_reference(),
		phenotypes => [],
		importErrors => "",
		type => $input->{type}
	});
	$phenoset->parent($self->_KBaseStore());
	my $bio = $self->_get_msobject("Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
	$phenoset->import_phenotype_table({
		data => $input->{phenotypes},
		biochem => $bio
	});
	if (length($phenoset->importErrors()) > 0 && $input->{ignore_errors} == 0) {
		$self->_error($phenoset->importErrors());
	}
	$output = $phenoset->save($input->{workspace}."/".$input->{phenotypeSet});
	$self->_clearContext();
    #END import_phenotypes
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_phenotypes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_phenotypes');
    }
    return($output);
}




=head2 simulate_phenotypes

  $output = $obj->simulate_phenotypes($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a simulate_phenotypes_params
$output is an object_metadata
simulate_phenotypes_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	notes has a value which is a string
	phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
	workspace has a value which is a workspace_id
	overwrite has a value which is a bool
	auth has a value which is a string
	all_transporters has a value which is a bool
	positive_transporters has a value which is a bool
fbamodel_id is a string
workspace_id is a string
phenotype_set_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
phenotypeSimulationSet_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a simulate_phenotypes_params
$output is an object_metadata
simulate_phenotypes_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	notes has a value which is a string
	phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
	workspace has a value which is a workspace_id
	overwrite has a value which is a bool
	auth has a value which is a string
	all_transporters has a value which is a bool
	positive_transporters has a value which is a bool
fbamodel_id is a string
workspace_id is a string
phenotype_set_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
phenotypeSimulationSet_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Simulates the specified phenotype set

=back

=cut

sub simulate_phenotypes
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to simulate_phenotypes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'simulate_phenotypes');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN simulate_phenotypes
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["phenotypeSet","workspace","model"],{
		phenotypeSet_workspace => $input->{workspace},
		model_workspace => $input->{workspace},
		formulation => undef,
		phenotypeSimultationSet => $input->{phenotypeSet}.".simulation",
		all_transporters => 0,
		positive_transporters => 0
	});
	my $pheno = $self->_get_msobject("PhenotypeSet",$input->{phenotypeSet_workspace},$input->{phenotypeSet});
	my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
    if ( $input->{all_transporters} ) {
		$model->addPhenotypeTransporters({phenotypes => $pheno,positiveonly => 0});
	} elsif ( $input->{positive_transporters} ) {
		$model->addPhenotypeTransporters({phenotypes => $pheno,positiveonly => 1});
	}
	$input->{formulation} = $self->_setDefaultFBAFormulation($input->{formulation});
	my $fba = $self->_buildFBAObject($input->{formulation},$model);
	$fba->parent($self->_KBaseStore());
	$fba->phenotypeset_ref($pheno->_reference());
	$fba->runFBA();
	if (!defined($fba->phenotypesimulationset())) {
    	$self->_error("Simulation of phenotypes failed to return results from FBA!");
	}
	if (!defined($input->{phenotypeSimulationSet})) {
		$input->{phenotypeSimulationSet} = $fba->phenotypesimulationset()->id();
	}
	$fba->phenotypesimulationset()->parent($self->_KBaseStore());
	$output = $self->_save_msobject($fba->phenotypesimulationset(),"PhenotypeSimulationSet",$input->{workspace},$input->{phenotypeSimultationSet});
	$fba->phenotypesimulationset_ref($fba->phenotypesimulationset()->_reference());
    my $meta = $self->_save_msobject($fba,"FBA",$input->{workspace},$fba->id(),{hidden => 1});
	$self->_clearContext();
    #END simulate_phenotypes
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to simulate_phenotypes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'simulate_phenotypes');
    }
    return($output);
}




=head2 add_media_transporters

  $output = $obj->add_media_transporters($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an add_media_transporters_params
$output is an object_metadata
add_media_transporters_params is a reference to a hash where the following keys are defined:
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	outmodel has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	overwrite has a value which is a bool
	auth has a value which is a string
	all_transporters has a value which is a bool
	positive_transporters has a value which is a bool
phenotype_set_id is a string
workspace_id is a string
fbamodel_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an add_media_transporters_params
$output is an object_metadata
add_media_transporters_params is a reference to a hash where the following keys are defined:
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	outmodel has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	overwrite has a value which is a bool
	auth has a value which is a string
	all_transporters has a value which is a bool
	positive_transporters has a value which is a bool
phenotype_set_id is a string
workspace_id is a string
fbamodel_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Adds transporters for media in a PhenotypeSet to a model

=back

=cut

sub add_media_transporters
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to add_media_transporters:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_media_transporters');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN add_media_transporters
    # TODO - I could also attempt to use the probanno object to add the "best" transporters. But I didn't
    # get that complicated here.
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["phenotypeSet","model","outmodel", "workspace"],{
		phenotypeSet_workspace => $input->{workspace},
		model_workspace => $input->{workspace},
		all_transporters => 0,
		positive_transporters => 0
	});

    my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
    my $pheno = $self->_get_msobject("PhenotypeSet", $input->{phenotypeSet_workspace}, $input->{phenotypeSet});

    if ( $input->{all_transporters} ) {
		$model->addPhenotypeTransporters({phenotypes => $pheno,positiveonly => 0});
    } elsif ( $input->{positive_transporters} ) {
		$model->addPhenotypeTransporters({phenotypes => $pheno,positiveonly => 1});
    } else {
		die "Must specify either all_transporters or positive_transporters.\n";
    }

    $output = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{outmodel});

    #END add_media_transporters
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to add_media_transporters:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_media_transporters');
    }
    return($output);
}




=head2 export_phenotypeSimulationSet

  $output = $obj->export_phenotypeSimulationSet($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an export_phenotypeSimulationSet_params
$output is a string
export_phenotypeSimulationSet_params is a reference to a hash where the following keys are defined:
	phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
phenotypeSimulationSet_id is a string
workspace_id is a string

</pre>

=end html

=begin text

$input is an export_phenotypeSimulationSet_params
$output is a string
export_phenotypeSimulationSet_params is a reference to a hash where the following keys are defined:
	phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
	workspace has a value which is a workspace_id
	format has a value which is a string
	auth has a value which is a string
phenotypeSimulationSet_id is a string
workspace_id is a string


=end text



=item Description

Export a PhenotypeSimulationSet for viewing

=back

=cut

sub export_phenotypeSimulationSet
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to export_phenotypeSimulationSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_phenotypeSimulationSet');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN export_phenotypeSimulationSet
	$self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["phenotypeSimulationSet","workspace"],{});
    my $phenosim = $self->_get_msobject("PhenotypeSimulationSet",$input->{workspace},$input->{phenotypeSimulationSet});
    $output = "Phenosim ID\tPheno ID\tMedia\tKO\tAdditional compounds\tObserved growth\tSimulated growth\tSimulated growth fraction\tClass\n";
    my $phenos = $phenosim->phenotypeSimulations();
    foreach my $pheno (@{$phenos}) {
    	$output .= $pheno->id()."\t".$pheno->phenotype()->id()."\t".
    		$pheno->phenotype()->media()->_wsworkspace()."/".$pheno->phenotype()->media()->_wsname().
    		"\t".$pheno->phenotype()->geneKOString()."\t".$pheno->phenotype()->additionalCpdString().
    		"\t".$pheno->phenotype()->normalizedGrowth()."\t".$pheno->simulatedGrowth()."\t".$pheno->simulatedGrowthFraction().
    		"\t".$pheno->phenoclass()."\n";
    }
    $self->_clearContext();
    #END export_phenotypeSimulationSet
    my @_bad_returns;
    (!ref($output)) or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to export_phenotypeSimulationSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'export_phenotypeSimulationSet');
    }
    return($output);
}




=head2 integrate_reconciliation_solutions

  $modelMeta = $obj->integrate_reconciliation_solutions($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an integrate_reconciliation_solutions_params
$modelMeta is an object_metadata
integrate_reconciliation_solutions_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	gapfillSolutions has a value which is a reference to a list where each element is a gapfillsolution_id
	gapgenSolutions has a value which is a reference to a list where each element is a gapgensolution_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
gapfillsolution_id is a string
gapgensolution_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an integrate_reconciliation_solutions_params
$modelMeta is an object_metadata
integrate_reconciliation_solutions_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	gapfillSolutions has a value which is a reference to a list where each element is a gapfillsolution_id
	gapgenSolutions has a value which is a reference to a list where each element is a gapgensolution_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
gapfillsolution_id is a string
gapgensolution_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Integrates the specified gapfill and gapgen solutions into the specified model

=back

=cut

sub integrate_reconciliation_solutions
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to integrate_reconciliation_solutions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'integrate_reconciliation_solutions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN integrate_reconciliation_solutions
    $input = $self->_setContext($ctx,$input,{
    	model => {type => "KBaseFBA.FBAModel",ws => "model_workspace"}
    },["model","workspace","gapfillSolutions","gapgenSolutions"],{
		model_workspace => $input->{workspace},
		out_model => $input->{model},
		overwrite => 0,
		rxnprobs => undef,
		rxnprobs_workspace => $input->{workspace}
    });
    my $model = $input->{model};
    my($rxnprobs);
    my($rxnprobsGPRArray);
    if ( defined($input->{rxnprobs}) ) {
		$rxnprobs = $self->_get_msobject("RxnProbs", $input->{rxnprobs_workspace}, $input->{rxnprobs});
		$rxnprobsGPRArray = $self->_buildRxnProbsGPRArray($rxnprobs);
    }
    foreach my $id (@{$input->{gapfillSolutions}}) {
    	print "ID:".$id."\n";
    	if ($id =~ m/^(.+\.gf\.\d+)\./) {
    		my $gfid = $1;
			$model->integrateGapfillSolution({
				gapfill=> $gfid,
				solution => $id,
				rxnProbGpr => $rxnprobsGPRArray
			});
    	} elsif ($id =~ m/^(\d+)\/(\d+)$/) {
    		my $gf = $1;
    		my $sol = $2;
    		my $gfs = $model->gapfillings();
    		if (defined($gfs->[$gf])) {
    			my $gfobj = $gfs->[$gf]->gapfill();
    			if (defined($gfobj->gapfillingSolutions()->[$sol])) {
    				my $solution = $gfobj->gapfillingSolutions()->[$sol];
    				print "Solution:".$solution->id()."\n";
    				$model->integrateGapfillSolution({
						gapfill=> $gfobj->id(),
						solution => $solution->id(),
						rxnProbGpr => $rxnprobsGPRArray
					});
    			}
    		}
    	}
    }
    foreach my $id (@{$input->{gapgenSolutions}}) {
    	if ($id =~ m/^(.+\.gg\.\d+)\./) {
	    	my $ggid = $1;
			$model->integrateGapgenSolution({
				gapgen=> $ggid,
				solution => $id,
			});
	    } elsif ($id =~ m/^(\d+)\/(\d+)$/) {
    		my $gg = $1;
    		my $sol = $2;
    		my $ggs = $model->gapfillings();
    		if (defined($ggs->[$gg])) {
    			my $ggobj = $ggs->[$gg]->gapfill();
    			if (defined($ggobj->gapfillingSolutions()->[$sol])) {
    				my $solution = $ggobj->gapfillingSolutions()->[$sol];
    				$model->integrateGapgenSolution({
						gapgen=> $ggobj->id(),
						solution => $solution->id(),
					});
    			}
    		}
    	}
    }
    
    $model->modelreactions();#This must be called here to ensure that the reaction objects are instantiated
    $modelMeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{out_model});
    $self->_clearContext();
    #END integrate_reconciliation_solutions
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to integrate_reconciliation_solutions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'integrate_reconciliation_solutions');
    }
    return($modelMeta);
}




=head2 queue_runfba

  $job = $obj->queue_runfba($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a queue_runfba_params
$job is a JobObject
queue_runfba_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	fva has a value which is a bool
	simulateko has a value which is a bool
	minimizeflux has a value which is a bool
	findminmedia has a value which is a bool
	notes has a value which is a string
	fba has a value which is a fba_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
	add_to_model has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
fba_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a queue_runfba_params
$job is a JobObject
queue_runfba_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is an FBAFormulation
	fva has a value which is a bool
	simulateko has a value which is a bool
	minimizeflux has a value which is a bool
	findminmedia has a value which is a bool
	notes has a value which is a string
	fba has a value which is a fba_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
	overwrite has a value which is a bool
	add_to_model has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
fba_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues an FBA job in a single media condition

=back

=cut

sub queue_runfba
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_runfba:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_runfba');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_runfba
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace"],{
		formulation => undef,
		fva => 0,
		simulateko => 0,
		minimizeflux => 0,
		findminmedia => 0,
		notes => "",
		model_workspace => $input->{workspace},
		fba => undef,
	});
	$job = $self->_queueJob({
		type => "KBaseFBAModeling",
		jobdata => $input,
		queuecommand => "runfba",
		"state" => "queued",
		auth => $self->_authentication(),
	});
	$self->_clearContext();
    #END queue_runfba
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_runfba:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_runfba');
    }
    return($job);
}




=head2 queue_gapfill_model

  $job = $obj->queue_gapfill_model($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a gapfill_model_params
$job is a JobObject
gapfill_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapfillingFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	target_reactions has a value which is a reference to a list where each element is a string
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFill has a value which is a gapfill_id
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	auth has a value which is a string
	overwrite has a value which is a bool
	completeGapfill has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
compartment_id is a string
probanno_id is a string
phenotype_set_id is a string
gapfill_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a gapfill_model_params
$job is a JobObject
gapfill_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapfillingFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	target_reactions has a value which is a reference to a list where each element is a string
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFill has a value which is a gapfill_id
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	auth has a value which is a string
	overwrite has a value which is a bool
	completeGapfill has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
compartment_id is a string
probanno_id is a string
phenotype_set_id is a string
gapfill_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues an FBAModel gapfilling job in single media condition

=back

=cut

sub queue_gapfill_model
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_gapfill_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_gapfill_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_gapfill_model
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace"],{		
		model_workspace => $input->{workspace},
		formulation => undef,
		phenotypeSet => undef,
		phenotypeSet_workspace => $input->{workspace},
		integrate_solution => 0,
		out_model => undef,
		gapFill => undef,
		gapFill_workspace => $input->{workspace},
		target_reactions => [],
		overwrite => 0,
		timePerSolution => 3600,
		totalTimeLimit => 18000,
		completeGapfill => 0,
		solver => undef
	});
	$job = $self->_queueJob({
		type => "KBaseFBAModeling",
		jobdata => $input,
		queuecommand => "gapfill_model",
		"state" => "queued",
		auth => $self->_authentication(),
	});
	$self->_clearContext();
    #END queue_gapfill_model
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_gapfill_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_gapfill_model');
    }
    return($job);
}




=head2 gapfill_model

  $modelMeta = $obj->gapfill_model($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a gapfill_model_params
$modelMeta is an object_metadata
gapfill_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapfillingFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	target_reactions has a value which is a reference to a list where each element is a string
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFill has a value which is a gapfill_id
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	auth has a value which is a string
	overwrite has a value which is a bool
	completeGapfill has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
compartment_id is a string
probanno_id is a string
phenotype_set_id is a string
gapfill_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a gapfill_model_params
$modelMeta is an object_metadata
gapfill_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapfillingFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	target_reactions has a value which is a reference to a list where each element is a string
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFill has a value which is a gapfill_id
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	auth has a value which is a string
	overwrite has a value which is a bool
	completeGapfill has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
compartment_id is a string
probanno_id is a string
phenotype_set_id is a string
gapfill_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub gapfill_model
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to gapfill_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'gapfill_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN gapfill_model
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace"],{		
		model_workspace => $input->{workspace},
		formulation => undef,
		phenotypeSet => undef,
		phenotypeSet_workspace => $input->{workspace},
		integrate_solution => 0,
		out_model => undef,
		gapFill => undef,
		gapFill_workspace => $input->{workspace},
		target_reactions => [],
		timePerSolution => 43200,
		totalTimeLimit => 45000,
		completeGapfill => 0,
		solver => undef,
		fastgapfill => 0,
		simultaneous => 0,
		activation_penalty => 0.05,
		source_model => undef,
		source_model_ws => $input->{workspace},
	});
	$input->{formulation}->{target_reactions} = $input->{target_reactions};
	$input->{formulation}->{timePerSolution} = $input->{timePerSolution};
	$input->{formulation}->{totalTimeLimit} = $input->{totalTimeLimit};
	$input->{formulation}->{completeGapfill} = $input->{completeGapfill};
	print "Simultaneous:".$input->{simultaneous}."\n";
	if ($input->{simultaneous} == 1) {
		$input->{completeGapfill} = 1;
	}
	if (@{$input->{target_reactions}} > 0) {
		$input->{completeGapfill} = 1;
	}
	if ($input->{completeGapfill} == 1) {
		$input->{formulation}->{num_solutions} = 1;
		$input->{formulation}->{completeGapfill} = 1;
	}
	$input->{formulation} = $self->_setDefaultGapfillFormulation($input->{formulation});
	my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
	if (!defined($input->{out_model})) {
		$input->{out_model} = $input->{model};
	}
	my ($gapfill,$fba) = $self->_buildGapfillObject($input->{formulation},$model,$input->{gfid});
	if (defined($input->{solver})) {
    	$fba->parameters()->{MFASolver} = uc($input->{solver});
    }
    if (defined($input->{source_model})) {
    	$fba->parameters()->{"gapfilling source model"} = $input->{source_model_ws}."/".$input->{source_model};
    }
    if (defined($input->{fastgapfill})) {
    	$fba->parameters()->{"Fast gap filling"} = $input->{fastgapfill};
    }
    if ($input->{simultaneous} == 1) {
		$fba->parameters()->{"Simultaneous gapfill"} = $input->{simultaneous};
	}
	$fba->parameters()->{"Reaction activation bonus"} = $input->{activation_penalty};
	$fba->runFBA();
	#Error checking the FBA and gapfilling solution
	if (!defined($fba->outputfiles()->{"CompleteGapfillingOutput.txt"}->[1] ) ) {
		$self->_error("Gapfilling failed to produce an output file. Check gapfilling infrastructure!");
	}
	my $gfoutput = $fba->outputfiles()->{"CompleteGapfillingOutput.txt"};
	for (my $i=0; $i < @{$gfoutput}; $i++) {
		my $line = $gfoutput->[$i];
		if ($line =~ /FAILED/ && $line =~ /Prelim/ && $line =~ /bio\d+/) {
			my $array = [split(/\t/,$line)];
			my $msg;
			if (defined($array->[6])) {
				$msg = "Gapfilling failed in preliminary feasibility determination. The following biomass compounds appear to be problematic: ".$array->[6]."!";
			} else {
				$msg = "Gapfilling failed in preliminary feasibility determination.";
			}
			$self->_error($msg);
		} elsif ($line =~ /FAILED/ && $line =~ /bio\d+/) {
			$self->_error("Gapfilling failed with no solutions!");
		}
	}
	$gapfill->parseGapfillingResults($fba);
	if (!defined($gapfill->gapfillingSolutions()->[0])) {
		$self->_error("Gapfilling completed, but no valid solutions found!");
	}
	my $meta = $self->_save_msobject($fba,"FBA",$input->{workspace},$fba->id(),{hidden => 1});
	$gapfill->fba_ref($fba->_reference());
	$meta = $self->_save_msobject($gapfill,"Gapfilling",$input->{workspace},$gapfill->id(),{hidden => 1});
	#Since gapfilling can take hours, we retrieve the model again in case it changed since accessed previously
	if ($input->{fastgapfill} == 0 && $input->{out_model} eq $input->{model}) {
		$model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model},{refreshcache => 1});
	}
	$model->add("gapfillings",{
		id => $gapfill->id(),
		gapfill_id => $gapfill->id(),
		gapfill_ref => $gapfill->_reference(),
		integrated => 0,
		media_ref => $fba->media()->_reference()
	});
	#If specified, we now integrate the first solution of the gapfilling into the model
	if ($input->{integrate_solution} == 1) {
		my ($rxnprobsGPRArray);
		my ($rxnprobs);
		if ( defined($input->{formulation}->{probabilisticReactions} )) {
		    my $rxnprobsid = $input->{formulation}->{probabilisticReactions};
		    my $rxnprobsws = $input->{formulation}->{probabilisticReaction_workspace};
		    $rxnprobs = $self->_get_msobject("RxnProbs", $rxnprobsws, $rxnprobsid);
		    $rxnprobsGPRArray = $self->_buildRxnProbsGPRArray($rxnprobs);
		}
		my $report = $model->integrateGapfillSolution({
			gapfill => $gapfill->id(),
			rxnProbGpr => $rxnprobsGPRArray
		});
	}
	$modelMeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{out_model});
	$self->_clearContext();
    #END gapfill_model
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to gapfill_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'gapfill_model');
    }
    return($modelMeta);
}




=head2 queue_gapgen_model

  $job = $obj->queue_gapgen_model($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a gapgen_model_params
$job is a JobObject
gapgen_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapGen has a value which is a gapgen_id
	auth has a value which is a string
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
phenotype_set_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a gapgen_model_params
$job is a JobObject
gapgen_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapGen has a value which is a gapgen_id
	auth has a value which is a string
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
phenotype_set_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues an FBAModel gapfilling job in single media condition

=back

=cut

sub queue_gapgen_model
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_gapgen_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_gapgen_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_gapgen_model
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace"],{
		model_workspace => $input->{workspace},
		formulation => undef,
		phenotypeSet => undef,
		phenotypeSet_workspace => $input->{workspace},
		integrate_solution => 0,
		out_model => $input->{model},
		gapGen => undef,
		overwrite => 0,
		solver => undef
	});
	$job = $self->_queueJob({
		type => "KBaseFBAModeling",
		jobdata => $input,
		queuecommand => "gapgen_model",
		"state" => "queued",
		auth => $self->_authentication(),
	});
	$self->_clearContext();
    #END queue_gapgen_model
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_gapgen_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_gapgen_model');
    }
    return($job);
}




=head2 gapgen_model

  $modelMeta = $obj->gapgen_model($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a gapgen_model_params
$modelMeta is an object_metadata
gapgen_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapGen has a value which is a gapgen_id
	auth has a value which is a string
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
phenotype_set_id is a string
gapgen_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a gapgen_model_params
$modelMeta is an object_metadata
gapgen_model_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	integrate_solution has a value which is a bool
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapGen has a value which is a gapgen_id
	auth has a value which is a string
	timePerSolution has a value which is an int
	totalTimeLimit has a value which is an int
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
phenotype_set_id is a string
gapgen_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub gapgen_model
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to gapgen_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'gapgen_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN gapgen_model
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace"],{
		model_workspace => $input->{workspace},
		formulation => undef,
		phenotypeSet => undef,
		phenotypeSet_workspace => $input->{workspace},
		integrate_solution => 0,
		out_model => $input->{model},
		gapGen => undef,
		solver => undef
	});
	$input->{formulation}->{timePerSolution} = $input->{timePerSolution};
	$input->{formulation}->{totalTimeLimit} = $input->{totalTimeLimit};
	$input->{formulation} = $self->_setDefaultGapGenFormulation($input->{formulation});
	my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
	if (!defined($input->{out_model})) {
		$input->{out_model} = $input->{model};
	}
	my ($gapgen,$fba) = $self->_buildGapGenObject($input->{formulation},$model,$input->{ggid});
	if (defined($input->{solver})) {
    	$fba->parameters()->{MFASolver} = uc($input->{solver});
    }
    $gapgen->fbamodel_ref($model->_reference());
    if (!defined($input->{ggid})) {
		my $fbameta = $self->_save_msobject($fba,"FBA",$input->{workspace},$fba->id());
		$gapgen->fba_ref($fba->_reference());
		my $ggMeta = $self->_save_msobject($gapgen,"Gapgeneration",$input->{workspace},$gapgen->id(),{hidden => 1});
		$model->add("gapgens",{
			id => $gapgen->_reference(),
			gapgen_id => $gapgen->_reference(),
			gapgen_ref => $input->{workspace}."/".$gapgen->id(),
			integrated => 0,
			media_ref => $fba->media()->_reference()
		});
		$modelMeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{out_model});
 		$gapgen->fbamodel_ref($model->_reference());
    }
	$fba->runFBA();
	if (!defined($fba->objectiveValue())) {
		$self->_error("Gapgeneration failed to produce any results. Check gapgeneration infrastructure!");
	}
	$gapgen->parseGapgenResults($gapgen->fba());
	#We must resave the FBA and gapgen as these objects now have populated solutions
	my $fbameta = $self->_save_msobject($fba,"FBA",$input->{workspace},$fba->id());
	$gapgen->fba_ref($fba->_reference());
	my $ggMeta = $self->_save_msobject($gapgen,"Gapgeneration",$input->{workspace},$gapgen->id(),{hidden => 1});
	#Since gapgen can take hours, we retrieve the model again in case it changed since accessed previously
	$model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model},{refreshcache => 1});
	$model->add("gapgens",{
		id => $gapgen->id(),
		gapgen_id => $gapgen->id(),
		gapgen_ref => $gapgen->_reference(),
		integrated => 0,
		media_ref => $fba->media()->_reference()
	});
	#If specified, we now integrate the first solution of the gapgen into the model
	if ($input->{integrate_solution} == 1 && defined($gapgen->gapgenSolutions()->[0])) {
		$model->integrateGapgenSolution({
			gapgen => $gapgen->id(),
		});
	}
	my $modelmeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{out_model});
	$self->_clearContext();
    #END gapgen_model
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to gapgen_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'gapgen_model');
    }
    return($modelMeta);
}




=head2 queue_wildtype_phenotype_reconciliation

  $job = $obj->queue_wildtype_phenotype_reconciliation($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a wildtype_phenotype_reconciliation_params
$job is a JobObject
wildtype_phenotype_reconciliation_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	fba_formulation has a value which is an FBAFormulation
	gapfill_formulation has a value which is a GapfillingFormulation
	gapgen_formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFills has a value which is a reference to a list where each element is a gapfill_id
	gapGens has a value which is a reference to a list where each element is a gapgen_id
	queueSensitivityAnalysis has a value which is a bool
	queueReconciliationCombination has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
compartment_id is a string
probanno_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
phenotype_set_id is a string
gapfill_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a wildtype_phenotype_reconciliation_params
$job is a JobObject
wildtype_phenotype_reconciliation_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	fba_formulation has a value which is an FBAFormulation
	gapfill_formulation has a value which is a GapfillingFormulation
	gapgen_formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFills has a value which is a reference to a list where each element is a gapfill_id
	gapGens has a value which is a reference to a list where each element is a gapgen_id
	queueSensitivityAnalysis has a value which is a bool
	queueReconciliationCombination has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
compartment_id is a string
probanno_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
phenotype_set_id is a string
gapfill_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues an FBAModel reconciliation job

=back

=cut

sub queue_wildtype_phenotype_reconciliation
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_wildtype_phenotype_reconciliation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_wildtype_phenotype_reconciliation');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_wildtype_phenotype_reconciliation
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace","phenotypeSet"],{
		out_model => $input->{model},
		phenotypeSet => undef,
		gapFills => undef,
		gapGens => undef,
		model_workspace => $input->{workspace},
		phenotypeSet_workspace => $input->{workspace},
		gapGen_workspace => $input->{workspace},
		gapFill_workspace => $input->{workspace},
		fba_formulation => undef,
		gapfill_formulation => undef,
		gapgen_formulation => undef,
		overwrite => 0,
		queueSensitivityAnalysis => 0,
		queueReconciliationCombination => 0
	});
	#Code to set up job
	if (!defined($input->{gapFills}) && !defined($input->{gapGens})) {
		#Creating formulations
		$input->{fba_formulation} = $self->_setDefaultFBAFormulation($input->{fba_formulation});
		$input->{gapfill_formulation} = $self->_setDefaultGapfillFormulation($input->{gapfill_formulation});
		$input->{gapgen_formulation} = $self->_setDefaultGapGenFormulation($input->{gapgen_formulation});
		$input->{gapfill_formulation}->{formulation} = $input->{fba_formulation};
		$input->{gapgen_formulation}->{formulation} = $input->{fba_formulation};	
		#Getting the simulated phenotype set to be reconciled
		my $simPheno = $self->_get_msobject("PhenotypeSimulationSet",$input->{phenotypeSet_workspace},$input->{phenotypeSet});
		if (!defined($simPheno->{phenotypeSimulations})) {
			my $msg = "No phenotypes simulated!";
			$self->_error($msg,'queue_wildtype_phenotype_reconciliation');
		}
		#Queing up gapfill and gapgen jobs
		#TODO: This block should be in a "safe save" block to prevent race conditions
		my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
		my $input = {
			model => $input->{model},
			model_workspace => $input->{model_workspace},
			phenotypeSet => $input->{phenotypeSet},
			phenotypeSet_workspace => $input->{phenotypeSet_workspace},
			formulation => $input->{fba_formulation},
			overwrite => $input->{overwrite},
			gapFills => [],
			gapGens => []
		};
		#Creating gapfill and gapgen jobs
		my $gapgenObjs = [];
		my $gapfillObjs = [];
		for (my $i=0; $i < @{$simPheno->{phenotypeSimulations}};$i++) {
			my $phenosim = $simPheno->{phenotypeSimulations}->[$i];
			if (@{$phenosim->[0]->[0]} == 0) {
				if ($phenosim->[3] eq "FN") {
					my $id = $self->_get_new_id($input->{model}.".gapfill.");
					push(@{$input->{gapFills}},$id);
					my $gapfill = $self->_buildGapfillObject($input->{gapfill_formulation},$model,$input->{gapFill_workspace},$id);
					push(@{$gapfillObjs},$gapfill);
					push(@{$model->unintegratedGapfilling_uuids()},$gapfill->uuid());
				} elsif ($phenosim->[3] eq "FP") {
					my $id = $self->_get_new_id($input->{model}.".gapgen.");
					push(@{$input->{gapGens}},$id);
					my $gapgen = $self->_buildGapGenObject($input->{gapgen_formulation},$model,$input->{gapGen_workspace},$id);
					push(@{$gapgenObjs},$gapgen);
					push(@{$model->unintegratedGapgen_uuids()},$gapgen->uuid());
				}
			}
		}
		my $modelmeta = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{out_model},"queue_wildtype_phenotype_reconciliation");
		#End "safe save" block
		my $joblist = [];
		foreach my $gapgenObj (@{$gapgenObjs}) {
			$gapgenObj->fbaFormulation()->model_uuid($model->uuid());
			my $fbameta = $self->_save_msobject($gapgenObj->fbaFormulation(),"FBA",$gapgenObj->fbaFormulation()->{_kbaseWSMeta}->{ws},$gapgenObj->fbaFormulation()->{_kbaseWSMeta}->{wsid},"queue_wildtype_phenotype_reconciliation");
			$gapgenObj->model_uuid($model->uuid());
			my $gapgenmeta = $self->_save_msobject($gapgenObj,"GapGen",$input->{gapGen_workspace},$gapgenObj->{_kbaseWSMeta}->{wsid},"queue_wildtype_phenotype_reconciliation");
			my $subJob = $self->_queueJob({
				type => "FBA",
				jobdata => {
					postprocess_command => "queue_wildtype_phenotype_reconciliation",
					postprocess_args => [$input],
					fbaref => $fbameta->[8]
				},
				queuecommand => "queue_wildtype_phenotype_reconciliation",
				"state" => $self->_defaultJobState()
			});
			push(@{$joblist},$subJob->{id});
		}
		foreach my $gapfillObj (@{$gapfillObjs}) {
			$gapfillObj->fbaFormulation()->model_uuid($model->uuid());
			my $fbameta = $self->_save_msobject($gapfillObj->fbaFormulation(),"FBA",$gapfillObj->fbaFormulation()->{_kbaseWSMeta}->{ws},$gapfillObj->fbaFormulation()->{_kbaseWSMeta}->{wsid},"queue_wildtype_phenotype_reconciliation");
			$gapfillObj->model_uuid($model->uuid());
			my $gapfillmeta = $self->_save_msobject($gapfillObj,"GapFill",$input->{gapFill_workspace},$gapfillObj->{_kbaseWSMeta}->{wsid},"queue_wildtype_phenotype_reconciliation");
			my $subJob = $self->_queueJob({
				type => "FBA",
				jobdata => {
					postprocess_command => "queue_wildtype_phenotype_reconciliation",
					postprocess_args => [$input],
					fbaref => $fbameta->[8]
				},
				queuecommand => "queue_wildtype_phenotype_reconciliation",
				"state" => $self->_defaultJobState()
			});
			push(@{$joblist},$subJob->{id});
		}
		$job = $self->_queueJob({
			type => "FBAJobSet",
			jobdata => {
				postprocess_command => "queue_wildtype_phenotype_reconciliation",
				postprocess_args => [$input],
				jobs => $joblist
			},
			queuecommand => "queue_wildtype_phenotype_reconciliation",
			"state" => $self->_defaultJobState()
		});
	} elsif ($input->{queueSensitivityAnalysis} == 1) {
		#Code to post process job
		if (defined($input->{gapFills})) {
			foreach my $gf (@{$input->{gapFills}}) {
				my $gapfill = $self->_get_msobject("GapFill",$input->{gapFill_workspace},$gf);
				if (!defined($gapfill->fbaFormulation()->fbaResults())) {
					my $msg = "Gap filling failed!";
					$self->_error($msg,'queue_gapgen_model');
				}
				$gapfill->parseGapfillResults($gapfill->fbaFormulation()->fbaResults()->[0]);
				my $output = $self->_save_msobject($gapfill,"GapFill",$input->{gapFill_workspace},$gf,"queue_gapgen_model");
			}
		}
		if (defined($input->{gapGens})) {
			foreach my $gg (@{$input->{gapGens}}) {
				my $gapgen = $self->_get_msobject("GapGen",$input->{gapGen_workspace},$gg);
				if (!defined($gapgen->fbaFormulation()->fbaResults())) {
					my $msg = "Gap generation failed!";
					$self->_error($msg,'queue_gapgen_model');
				}
				$gapgen->parseGapgenResults($gapgen->fbaFormulation()->fbaResults()->[0]);
				my $output = $self->_save_msobject($gapgen,"GapGen",$input->{gapGen_workspace},$gg,"queue_gapgen_model");
			}
		}
		#Queing up sensitivity analysis, the next step in the pipeline
		if ($input->{queueSensitivityAnalysis} == 1) {
			my $input = {
				model => $input->{out_model},
				workspace => $input->{workspace},
				phenotypeSet => $input->{phenotypeSet},
				phenotypeSet_workspace => $input->{phenotypeSet_workspace},
				gapFills => $input->{gapFills},
				gapGens => $input->{gapGens},
				overwrite => $input->{overwrite},
				donot_submit_job => $input->{donot_submit_job},
				queueReconciliationCombination => $input->{queueReconciliationCombination}
			};
			return $self->queue_reconciliation_sensitivity_analysis($input);
		}
		$job = {};
	}	
    $self->_clearContext();
    #END queue_wildtype_phenotype_reconciliation
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_wildtype_phenotype_reconciliation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_wildtype_phenotype_reconciliation');
    }
    return($job);
}




=head2 queue_reconciliation_sensitivity_analysis

  $job = $obj->queue_reconciliation_sensitivity_analysis($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a wildtype_phenotype_reconciliation_params
$job is a JobObject
wildtype_phenotype_reconciliation_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	fba_formulation has a value which is an FBAFormulation
	gapfill_formulation has a value which is a GapfillingFormulation
	gapgen_formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFills has a value which is a reference to a list where each element is a gapfill_id
	gapGens has a value which is a reference to a list where each element is a gapgen_id
	queueSensitivityAnalysis has a value which is a bool
	queueReconciliationCombination has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
compartment_id is a string
probanno_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
phenotype_set_id is a string
gapfill_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a wildtype_phenotype_reconciliation_params
$job is a JobObject
wildtype_phenotype_reconciliation_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	fba_formulation has a value which is an FBAFormulation
	gapfill_formulation has a value which is a GapfillingFormulation
	gapgen_formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFills has a value which is a reference to a list where each element is a gapfill_id
	gapGens has a value which is a reference to a list where each element is a gapgen_id
	queueSensitivityAnalysis has a value which is a bool
	queueReconciliationCombination has a value which is a bool
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
compartment_id is a string
probanno_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
phenotype_set_id is a string
gapfill_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues an FBAModel reconciliation job

=back

=cut

sub queue_reconciliation_sensitivity_analysis
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_reconciliation_sensitivity_analysis:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_reconciliation_sensitivity_analysis');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_reconciliation_sensitivity_analysis
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace","phenotypeSet"],{
		fba_formulation => undef,
		phenotypeSet_workspace => $input->{workspace},
		model_workspace => $input->{workspace},
		gapFills => undef,
		gapGens => undef,
		queueReconciliationCombination => 0,
		overwrite => 0,
		simPhenoID => undef
	});
	#Retreiving model
	my $model = $self->_get_msobject("FBAModel",$input->{model_workspace},$input->{model});
	if (!defined($input->{simPhenoID})) {
		#Retrieving phenotypes
		my $pheno = $self->_get_msobject("PhenotypeSet",$input->{phenotypeSet_workspace},$input->{phenotypeSet});
		#Creating FBAFormulation Object
		$input->{formulation} = $self->_setDefaultFBAFormulation($input->{formulation});
		my $fba = $self->_buildFBAObject($input->{formulation},$model,"NO_WORKSPACE",Data::UUID->new()->create_str());
		#Constructing FBA simulation object from 
		($fba,my $existingPhenos,my $phenokeys) = $self->_prepPhenotypeSimultationFBA($model,$pheno,$fba);
		$fba->uuid(Data::UUID->new()->create_str());
		$fba->model($model);
		$fba->model_uuid($model->uuid());
		$fba->notes("WT");
		my $output = $self->_save_msobject($fba,"FBA","NO_WORKSPACE",$fba->uuid(),"queue_reconciliation_sensitivity_analysis",1,$fba->uuid());
		#Creating PhenotypeSensitivityAnalysis object
		my $phenoSenseAnalysis = {
			id => $self->_get_new_id($input->{model}.".phenosens."),
			phenotypeSet => $input->{phenotypeSet},
			phenotypeSet_workspace => $input->{phenotypeSet_workspace},
			model => $input->{model},
			model_workspace => $input->{model_workspace},
			phenotypes => [],
			wildtypePhenotypeSimulations => [],
			reconciliationSolutionSimulations => [],
			fbaids => [$fba->uuid()]
		};
		#Identifying gapfills and gapgens to assess
		if (!defined($input->{gapFills})) {
			$input->{gapFills} = [];
			for (my $i=0; $i < @{$model->unintegratedGapfillings()}; $i++) {
				push(@{$input->{gapFills}},$model->unintegratedGapfillings()->[$i]->uuid());
			}
		}
		if (!defined($input->{gapGens})) {
			$input->{gapGens} = [];
			for (my $i=0; $i < @{$model->unintegratedGapgens()}; $i++) {
				push(@{$input->{gapGens}},$model->unintegratedGapgens()->[$i]->uuid());
			}
		}
		#Queuing up sensitivity analysis of gapfilling solutions
		my $solIndex = 0;
		my $joblist = [];
		my $postProcArgs = {
			model => $input->{model},
			workspace => $input->{workspace},
			phenotypeSet => $input->{phenotypeSet},
			model_workspace => $input->{model_workspace},
			phenotypeSet_workspace => $input->{phenotypeSet_workspace},
			gapFills => $input->{gapFills},
			gapGens => $input->{gapGens},
			simPhenoID => $phenoSenseAnalysis->{id}
		};
		for (my $i=0;$i<@{$input->{gapFills}};$i++) {
			#print $input->{gapFills}->[$i]."\n";
			my $gf;
			for (my $j=0;$j<@{$model->unintegratedGapfillings()};$j++) {
				if ($model->unintegratedGapfillings()->[$j]->uuid() eq $input->{gapFills}->[$i]) {
					$gf = $model->unintegratedGapfillings()->[$j];
					last;
				}
			}
			if (defined($gf)) {
				#for (my $j=0;$j<2;$j++) {
				for (my $j=0;$j<@{$gf->gapfillingSolutions()};$j++) {
					#print "Integrating ".$input->{gapFills}->[$i].".".$j."\n";
					my $newmod = $model->cloneObject();
					$newmod->parent($self->_KBaseStore());
					$newmod->integrateGapfillSolution({
						solutionNum => $j,
						gapfillingFormulation => $gf
					});
					$newmod->uuid(Data::UUID->new()->create_str());
					$fba->uuid(Data::UUID->new()->create_str());
					$fba->model($newmod);
					$fba->model_uuid($newmod->uuid());
					$fba->notes($solIndex);
					my $output = $self->_save_msobject($newmod,"FBAModel","NO_WORKSPACE",$newmod->uuid(),"queue_reconciliation_sensitivity_analysis",1,$newmod->uuid());
					$output = $self->_save_msobject($fba,"FBA","NO_WORKSPACE",$fba->uuid(),"queue_reconciliation_sensitivity_analysis",1,$fba->uuid());
					push(@{$phenoSenseAnalysis->{fbaids}},$fba->uuid());
					push(@{$phenoSenseAnalysis->{reconciliationSolutionSimulations}},["GF",$gf->uuid(),$j,$gf->gapfillingSolutions()->[$j]->solrxn(),$gf->gapfillingSolutions()->[$j]->biocpd(),[]]);
					my $subJob = $self->_queueJob({
						type => "FBA",
						jobdata => {
							postprocess_command => undef,
							postprocess_args => undef,
							fbaref => $fba->uuid()
						},
						queuecommand => "queue_reconciliation_sensitivity_analysis",
						"state" => $self->_defaultJobState()
					});
					push(@{$joblist},$subJob->{id});		
				}
			}
			$solIndex++;
		}		
		#Queuing up sensitivity analysis of gapgen solutions
		for (my $i=0;$i<@{$input->{gapGens}};$i++) {
			my $gg;
			for (my $j=0;$j<@{$model->unintegratedGapgens()};$j++) {
				if ($model->unintegratedGapgens()->[$j]->uuid() eq $input->{gapGens}->[$i]) {
					$gg = $model->unintegratedGapgens()->[$j];
					last;
				}
			}
			if (defined($gg)) {
				for (my $j=0;$j<@{$gg->gapgenSolutions()};$j++) {
					my $newmod = $model->cloneObject();
					$newmod->parent($self->_KBaseStore());
					$newmod->integrateGapgenSolution({
						solutionNum => $j,
						gapgenFormulation => $gg
					});
					$newmod->uuid(Data::UUID->new()->create_str());
					$fba->uuid(Data::UUID->new()->create_str());
					$fba->model($newmod);
					$fba->model_uuid($newmod->uuid());
					$fba->notes($solIndex);
					$output = $self->_save_msobject($newmod,"FBAModel","NO_WORKSPACE",$newmod->uuid(),"queue_reconciliation_sensitivity_analysis",1,$newmod->uuid());
					$output = $self->_save_msobject($fba,"FBA","NO_WORKSPACE",$fba->uuid(),"queue_reconciliation_sensitivity_analysis",1,$fba->uuid());
					push(@{$phenoSenseAnalysis->{fbaids}},$fba->uuid());
					push(@{$phenoSenseAnalysis->{reconciliationSolutionSimulations}},["GG",$gg->uuid(),$j,$gg->gapgenSolutions()->[$j]->solrxn(),$gg->gapgenSolutions()->[$j]->biocpd(),[]]);
					my $subJob = $self->_queueJob({
						type => "FBA",
						jobdata => {
							postprocess_command => undef,
							postprocess_args => undef,
							fbaref => $fba->uuid()
						},
						queuecommand => "queue_reconciliation_sensitivity_analysis",
						"state" => $self->_defaultJobState()
					});
					push(@{$joblist},$subJob->{id});
				}
			}
			$solIndex++;
		}    
		#Saving job object
		#print "Saving!\n";
		#print join("\n",@{$phenoSenseAnalysis->{fbaids}})."\n";
		$output = $self->_save_msobject($phenoSenseAnalysis,"PhenoSenseAnalysis",$input->{workspace},$phenoSenseAnalysis->{id},"queue_reconciliation_sensitivity_analysis");
		$job = $self->_queueJob({
			type => "FBAJobSet",
			jobdata => {
				postprocess_command => "queue_reconciliation_sensitivity_analysis",
				postprocess_args => [$postProcArgs],
				jobs => $joblist
			},
			queuecommand => "queue_reconciliation_sensitivity_analysis",
			"state" => $self->_defaultJobState()
		});
	} else {
		my $phenoSense = $self->_get_msobject("PhenoSenseAnalysis",$input->{workspace},$input->{simPhenoID});
		foreach my $fbaid (@{$phenoSense->{fbaids}}) {
			my $fba = $self->_get_msobject("FBA","NO_WORKSPACE",$fbaid);
			my $result = $fba->fbaResults()->[0];
			if ($fba->notes() eq "WT") {
				$phenoSense->{wildtypePhenotypeSimulations} = [];
				for (my $i=0; $i < @{$result->fbaPhenotypeSimultationResults()};$i++) {
					my $simResult = $result->fbaPhenotypeSimultationResults()->[$i];
					push(@{$phenoSense->{wildtypePhenotypeSimulations}},[$simResult->simulatedGrowth(),$simResult->simulatedGrowthFraction(),$simResult->class()]);
				}
			} else {
				my $index = $fba->notes();
				$phenoSense->{reconciliationSolutionSimulations}->[$index]->[5] = [];
				for (my $i=0; $i < @{$result->fbaPhenotypeSimultationResults()};$i++) {
					my $simResult = $result->fbaPhenotypeSimultationResults()->[$i];
					push(@{$phenoSense->{reconciliationSolutionSimulations}->[$index]->[5]},[$simResult->simulatedGrowth(),$simResult->simulatedGrowthFraction(),$simResult->class()]);
				}
#				$self->_workspaceServices()->delete_object_permanently({
#					type => "Model",
#					id => $fba->model_uuid(),
#					workspace => "NO_WORKSPACE"
#				});
#				$self->_workspaceServices()->delete_object_permanently({
#					type => "FBA",
#					id => $fba->uuid(),
#					workspace => "NO_WORKSPACE"
#				});
			}
		}
		#delete $phenoSense->{fbaids};
		my $output = $self->_save_msobject($phenoSense,"PhenoSenseAnalysis",$input->{workspace},$input->{simPhenoID},"queue_reconciliation_sensitivity_analysis");
		$job = {};
	}
    #END queue_reconciliation_sensitivity_analysis
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_reconciliation_sensitivity_analysis:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_reconciliation_sensitivity_analysis');
    }
    return($job);
}




=head2 queue_combine_wildtype_phenotype_reconciliation

  $job = $obj->queue_combine_wildtype_phenotype_reconciliation($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a combine_wildtype_phenotype_reconciliation_params
$job is a JobObject
combine_wildtype_phenotype_reconciliation_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	fba_formulation has a value which is an FBAFormulation
	gapfill_formulation has a value which is a GapfillingFormulation
	gapgen_formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFills has a value which is a reference to a list where each element is a gapfill_id
	gapGens has a value which is a reference to a list where each element is a gapgen_id
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
compartment_id is a string
probanno_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
phenotype_set_id is a string
gapfill_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a combine_wildtype_phenotype_reconciliation_params
$job is a JobObject
combine_wildtype_phenotype_reconciliation_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_workspace has a value which is a workspace_id
	fba_formulation has a value which is an FBAFormulation
	gapfill_formulation has a value which is a GapfillingFormulation
	gapgen_formulation has a value which is a GapgenFormulation
	phenotypeSet has a value which is a phenotype_set_id
	phenotypeSet_workspace has a value which is a workspace_id
	out_model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	gapFills has a value which is a reference to a list where each element is a gapfill_id
	gapGens has a value which is a reference to a list where each element is a gapgen_id
	auth has a value which is a string
	overwrite has a value which is a bool
fbamodel_id is a string
workspace_id is a string
FBAFormulation is a reference to a hash where the following keys are defined:
	media has a value which is a media_id
	additionalcpds has a value which is a reference to a list where each element is a compound_id
	promconstraint has a value which is a promconstraint_id
	promconstraint_workspace has a value which is a workspace_id
	eflux_sample has a value which is a sample_id
	eflux_series has a value which is a series_id
	eflux_workspace has a value which is a workspace_id
	media_workspace has a value which is a workspace_id
	objfraction has a value which is a float
	allreversible has a value which is a bool
	maximizeObjective has a value which is a bool
	objectiveTerms has a value which is a reference to a list where each element is a term
	geneko has a value which is a reference to a list where each element is a feature_id
	rxnko has a value which is a reference to a list where each element is a reaction_id
	bounds has a value which is a reference to a list where each element is a bound
	constraints has a value which is a reference to a list where each element is a constraint
	uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
	defaultmaxflux has a value which is a float
	defaultminuptake has a value which is a float
	defaultmaxuptake has a value which is a float
	simplethermoconst has a value which is a bool
	thermoconst has a value which is a bool
	nothermoerror has a value which is a bool
	minthermoerror has a value which is a bool
media_id is a string
compound_id is a string
promconstraint_id is a string
sample_id is a string
series_id is a string
bool is an int
term is a reference to a list containing 3 items:
	0: (coefficient) a float
	1: (varType) a string
	2: (variable) a string
feature_id is a string
reaction_id is a string
bound is a reference to a list containing 4 items:
	0: (min) a float
	1: (max) a float
	2: (varType) a string
	3: (variable) a string
constraint is a reference to a list containing 4 items:
	0: (rhs) a float
	1: (sign) a string
	2: (terms) a reference to a list where each element is a term
	3: (name) a string
GapfillingFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
	allowunbalanced has a value which is a bool
	activitybonus has a value which is a float
	drainpen has a value which is a float
	directionpen has a value which is a float
	nostructpen has a value which is a float
	unfavorablepen has a value which is a float
	nodeltagpen has a value which is a float
	biomasstranspen has a value which is a float
	singletranspen has a value which is a float
	transpen has a value which is a float
	blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
	gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
	allowedcmps has a value which is a reference to a list where each element is a compartment_id
	probabilisticAnnotation has a value which is a probanno_id
	probabilisticAnnotation_workspace has a value which is a workspace_id
compartment_id is a string
probanno_id is a string
GapgenFormulation is a reference to a hash where the following keys are defined:
	formulation has a value which is an FBAFormulation
	refmedia has a value which is a media_id
	refmedia_workspace has a value which is a workspace_id
	num_solutions has a value which is an int
	nomediahyp has a value which is a bool
	nobiomasshyp has a value which is a bool
	nogprhyp has a value which is a bool
	nopathwayhyp has a value which is a bool
phenotype_set_id is a string
gapfill_id is a string
gapgen_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues an FBAModel reconciliation job

=back

=cut

sub queue_combine_wildtype_phenotype_reconciliation
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_combine_wildtype_phenotype_reconciliation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_combine_wildtype_phenotype_reconciliation');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_combine_wildtype_phenotype_reconciliation
    #CombinedReconciliation
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["PhenoSensitivityAnalysis","workspace"],{
		out_model => undef,
		numsolutions => 1,
		intsolution => 1,
		timePerSolution => 3600,
		totalTimeLimit => 18000,
		donot_submit_job => 0,
		overwrite => 0,
		fbaid =>undef
	});
	my $classTrans = {
		"CP" => 0,
		"CN" => 1,
		"FP" => 2,
		"FN" => 3
	};
	my $phenoSense = $self->_get_msobject("PhenoSenseAnalysis",$input->{workspace},$input->{PhenoSensitivityAnalysis});
	my $model = $self->_get_msobject("FBAModel",$phenoSense->{model_workspace},$phenoSense->{model});
	if (!defined($input->{out_model})) {
		$input->{out_model} = $phenoSense->{model};
	}
	if (!defined($input->{fbaid})) {
		my $origerrors = [];
		my $errorCount = 0;
		for (my $i=0; $i < @{$phenoSense->{wildtypePhenotypeSimulations}};$i++) {
			$origerrors->[$i] = $classTrans->{$phenoSense->{wildtypePhenotypeSimulations}->[$i]->[2]};
			if ($classTrans->{$phenoSense->{wildtypePhenotypeSimulations}->[$i]->[2]} eq "FP" || $classTrans->{$phenoSense->{wildtypePhenotypeSimulations}->[$i]->[2]} eq "FN") {
				$errorCount++;
			}		
		}
		my $formulation = $self->_setDefaultFBAFormulation({});
		my $fba = $self->_buildFBAObject($formulation,$model,"NO_WORKSPACE",Data::UUID->new()->create_str());
		$fba->inputfiles()->{"OPEM.txt"} = [join(";",@{$origerrors})];
		my $ggem = [];
		my $gfem = [];
		for (my $i=0; $i < @{$phenoSense->{reconciliationSolutionSimulations}}; $i++) {
			my $rxns = "";
			for (my $j=0; $j < @{$phenoSense->{reconciliationSolutionSimulations}->[$i]->[3]}; $j++) {
				if (length($rxns) > 0) {
					$rxns .= ",";
				}
				if ($phenoSense->{reconciliationSolutionSimulations}->[$i]->[3]->[$j]->[0] eq "<") {
					$rxns .= "-";
				} elsif ($phenoSense->{reconciliationSolutionSimulations}->[$i]->[3]->[$j]->[0] eq ">") {
					$rxns .= "+";
				}
				$rxns .= $phenoSense->{reconciliationSolutionSimulations}->[$i]->[3]->[$j]->[1];
			}
			my $solutionArray = [$phenoSense->{reconciliationSolutionSimulations}->[$i]->[1],$phenoSense->{reconciliationSolutionSimulations}->[$i]->[2],"",$rxns,""];
			$errorCount = 0;
			for (my $j=0; $j < @{$phenoSense->{reconciliationSolutionSimulations}->[$i]->[5]}; $j++) {
				push(@{$solutionArray},$classTrans->{$phenoSense->{reconciliationSolutionSimulations}->[$i]->[5]->[$j]});
				if ($classTrans->{$phenoSense->{reconciliationSolutionSimulations}->[$i]->[5]->[$j]} eq "FP" || $classTrans->{$phenoSense->{reconciliationSolutionSimulations}->[$i]->[5]->[$j]} eq "FN") {
					$errorCount++;
				}
			}
			$solutionArray->[4] = $errorCount."/".@{$phenoSense->{reconciliationSolutionSimulations}->[$i]->[5]};
			if ($phenoSense->{reconciliationSolutionSimulations}->[$i]->[0] eq "GG") {
				push(@{$ggem},join(";",@{$solutionArray}));
			} else {
				push(@{$gfem},join(";",@{$solutionArray}));
			}
		}
		$fba->inputfiles()->{"GGEM.txt"} = [join("\n",@{$ggem})];
		$fba->inputfiles()->{"GFEM.txt"} = [join("\n",@{$gfem})];
		$fba->parameters()->{"Perform solution reconciliation"} = 1;
		$fba->outputfiles()->[0] = "ReconciliationSolutions.txt";
		$self->_save_msobject($fba,"FBA","NO_WORKSPACE",$fba->uuid(),"queue_combine_wildtype_phenotype_reconciliation",1,$fba->uuid());
		$job = $self->_queueJob({
			type => "FBA",
			jobdata => {
				postprocess_command => "queue_combine_wildtype_phenotype_reconciliation",
				postprocess_args => [{
					fbaid => $fba->uuid(),
					PhenoSensitivityAnalysis => $input->{PhenoSensitivityAnalysis},
					out_model => $input->{out_model},
					workspace => $input->{workspace},
				}],
				fbaref => $fba->uuid()
			},
			queuecommand => "queue_combine_wildtype_phenotype_reconciliation",
			"state" => $self->_defaultJobState()
		});
	} else {
		my $fba = $self->_get_msobject("FBA","NO_WORKSPACE",$input->{fbaid});
		my $data;
		$job = {};
		#$output = $self->_save_msobject($data,"CombinedReconciliation",$input->{workspace},$data->{id},"queue_combine_wildtype_phenotype_reconciliation");
	}
	$self->_clearContext();
    #END queue_combine_wildtype_phenotype_reconciliation
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_combine_wildtype_phenotype_reconciliation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_combine_wildtype_phenotype_reconciliation');
    }
    return($job);
}




=head2 run_job

  $job = $obj->run_job($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a run_job_params
$job is a JobObject
run_job_params is a reference to a hash where the following keys are defined:
	job has a value which is a job_id
	auth has a value which is a string
job_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string

</pre>

=end html

=begin text

$input is a run_job_params
$job is a JobObject
run_job_params is a reference to a hash where the following keys are defined:
	job has a value which is a job_id
	auth has a value which is a string
job_id is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string


=end text



=item Description

Runs specified job

=back

=cut

sub run_job
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to run_job:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'run_job');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN run_job
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["job"],{usecpx => 0,overrideauth => 0});
    $job = $self->_getJob($input->{job});
    Bio::KBase::ObjectAPI::utilities::CurrentJobID($input->{job});
    eval {
	    $self->_jobserv()->set_job_status({
		   	jobid => $job->{id},
		   	status => "running",
		   	auth => $self->_authentication(),
		   	currentStatus => $job->{status},
		   	jobdata => {error => "None"}
	    });
    };
    my $params = $job->{jobdata};
    $params->{auth} = $job->{auth};
    if (defined($input->{overrideauth}) && $input->{overrideauth} == 1) {
    	$params->{auth} = $self->_authentication();
    }
    my $command = $job->{queuecommand};
    $self->$command($params);
    eval {
	    $job = $self->_jobserv()->set_job_status({
	    	jobid => $input->{job},
	    	status => "done",
	    	auth => $self->_authentication(),
	    	currentStatus => "running",
	    	jobdata => {error => "None"}
	    });
    };
    $self->_clearContext();
    #END run_job
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to run_job:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'run_job');
    }
    return($job);
}




=head2 queue_job

  $job = $obj->queue_job($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a queue_job_params
$job is a JobObject
queue_job_params is a reference to a hash where the following keys are defined:
	method has a value which is a string
	parameters has a value which is a reference to a hash where the key is a string and the value is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string

</pre>

=end html

=begin text

$input is a queue_job_params
$job is a JobObject
queue_job_params is a reference to a hash where the following keys are defined:
	method has a value which is a string
	parameters has a value which is a reference to a hash where the key is a string and the value is a string
JobObject is a reference to a hash where the following keys are defined:
	id has a value which is a job_id
	type has a value which is a string
	auth has a value which is a string
	status has a value which is a string
	jobdata has a value which is a reference to a hash where the key is a string and the value is a string
	queuetime has a value which is a string
	starttime has a value which is a string
	completetime has a value which is a string
	owner has a value which is a string
	queuecommand has a value which is a string
job_id is a string


=end text



=item Description

Queues the specified command to run as a job

=back

=cut

sub queue_job
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to queue_job:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_job');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($job);
    #BEGIN queue_job
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["method","parameters"],{});
	$job = $self->_queueJob({
		type => "KBaseFBAModeling",
		jobdata => $input->{parameters},
		queuecommand => $input->{method},
		"state" => "queued",
		auth => $self->_authentication(),
	});
	$self->_clearContext();
    #END queue_job
    my @_bad_returns;
    (ref($job) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"job\" (value was \"$job\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to queue_job:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'queue_job');
    }
    return($job);
}




=head2 set_cofactors

  $output = $obj->set_cofactors($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a set_cofactors_params
$output is an object_metadata
set_cofactors_params is a reference to a hash where the following keys are defined:
	cofactors has a value which is a reference to a list where each element is a compound_id
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	reset has a value which is a bool
	overwrite has a value which is a bool
	auth has a value which is a string
compound_id is a string
biochemistry_id is a string
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a set_cofactors_params
$output is an object_metadata
set_cofactors_params is a reference to a hash where the following keys are defined:
	cofactors has a value which is a reference to a list where each element is a compound_id
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	reset has a value which is a bool
	overwrite has a value which is a bool
	auth has a value which is a string
compound_id is a string
biochemistry_id is a string
workspace_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub set_cofactors
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to set_cofactors:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'set_cofactors');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN set_cofactors
    $self->_setContext($ctx,$input);

	# Get the biochemistry from the workspace.
	my $biochem = $self->_get_msobject("Biochemistry", $input->{biochemistry_workspace}, $input->{biochemistry});
	
	# Set the value for the isCofactor flag.
	my $value = 1;
	if ($input->{reset}) {
		$value = 0;
	}
	
	# Find each compound and set the isCofactor flag.
	foreach my $cpdid (@{$input->{cofactors}}) {
		my $cpd = $biochem->searchForCompound($cpdid);
		if (defined($cpd)) {
			$cpd->isCofactor($value);
		} else {
			my $msg = "Compound ".$cpdid." was not found in biochemistry database ".$input->{biochemistry_workspace}."/".$input->{biochemistry};
			$self->_error($msg);
		}
	}
	
	# Save the updated biochemistry to the workspace.
   	$output = $self->_save_msobject($biochem,"Biochemistry",$input->{biochemistry_workspace},$input->{biochemistry});
	
    $self->_clearContext();
    #END set_cofactors
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to set_cofactors:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'set_cofactors');
    }
    return($output);
}




=head2 find_reaction_synonyms

  $output = $obj->find_reaction_synonyms($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a find_reaction_synonyms_params
$output is an object_metadata
find_reaction_synonyms_params is a reference to a hash where the following keys are defined:
	reaction_synonyms has a value which is a reaction_synonyms_id
	workspace has a value which is a workspace_id
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	overwrite has a value which is a bool
	auth has a value which is a string
reaction_synonyms_id is a string
workspace_id is a string
biochemistry_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a find_reaction_synonyms_params
$output is an object_metadata
find_reaction_synonyms_params is a reference to a hash where the following keys are defined:
	reaction_synonyms has a value which is a reaction_synonyms_id
	workspace has a value which is a workspace_id
	biochemistry has a value which is a biochemistry_id
	biochemistry_workspace has a value which is a workspace_id
	overwrite has a value which is a bool
	auth has a value which is a string
reaction_synonyms_id is a string
workspace_id is a string
biochemistry_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub find_reaction_synonyms
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to find_reaction_synonyms:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'find_reaction_synonyms');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN find_reaction_synonyms
    $self->_setContext($ctx,$input);

	# Get the biochemistry from the workspace.
	my $biochem = $self->_get_msobject("Biochemistry", $input->{biochemistry_workspace}, $input->{biochemistry});
	
	# Build a hash of compounds that are cofactors.
	my $cofactors = { };
	my $compoundList = $biochem->compounds();
	foreach my $cpd (@{$compoundList}) {
		if ($cpd->isCofactor()) {
			$cofactors->{$cpd->id()} = 1;
		}
	}
	
	# Iterate over the list of reactions and identify the net reaction for each one.
	my $netReactions = { };
	my $excludedReactions = [ ];
	my $reactionList = $biochem->reactions();
	my $moreCofactors = { };
	foreach my $rxn (@{$reactionList}) {
		my $nonCofactorCompounds = [ ];
		my $numReagents = @{$rxn->reagents()};
		foreach my $reagent (@{$rxn->reagents()}) {
			# Skip if compound is a cofactor within reaction.
			next if ($reagent->isCofactor());
	
			# Skip if compound is a cofactor within cofactor list.
			my $cpd = $reagent->compound();
			next if (exists($cofactors->{$cpd->id()}));
	
			# Add the compound to the list of non-cofactor compounds for this reaction.
			push(@$nonCofactorCompounds, $cpd->id());
		}
		
		# Only add to the net reaction hash if there is at least one non-cofactor compound.
		my $numcpds = @$nonCofactorCompounds;
		if ($numcpds > 0) {
			$netReactions->{$rxn->id()} = { compounds => $nonCofactorCompounds, reaction => $rxn };
		} else {
			my $excludedrxn = { id => $rxn->id(), name => $rxn->name, definition => $rxn->createEquation( { format => "formula" } ) };
			push(@$excludedReactions, $excludedrxn);	
		}
	}
	my $numExcluded = @$excludedReactions;
	
	# Iterate over the list of reactions and identify the reaction synonyms.
	# Two reactions are synonyms if the net reaction compound lists are the same.
	my $reactionSynonyms = [ ];
	foreach my $rxn (@{$reactionList}) {
		# Skip if reaction is not in the net reaction hash.
		my $found = $netReactions->{$rxn->id()}->{compounds};
		next if (!defined($found));
		
		# Check each net reaction and see if the compound list matches this reaction.
		# The synonyms will at least include this reaction.  Maybe should exclude the same reaction from the list???
		my $rxnsyn = { primary => $rxn->id(), synonyms => [] };	
		foreach my $key (keys %$netReactions) {
			my $cpds = $netReactions->{$key}->{compounds};
			if (@$cpds ~~ @$found) {
				my $synrxn = $netReactions->{$key}->{reaction};
				my $rxndef = { id => $synrxn->id(), name => $synrxn->name, definition => $synrxn->createEquation( { format => "formula" } ) };
				push(@{$rxnsyn->{synonyms}}, $rxndef);
			}
		}
		push(@$reactionSynonyms, $rxnsyn);
	}
	my $numSynonyms = @$reactionSynonyms;
	
	# Create the reaction synonyms object and save it to the workspace.
	my $object = { 
		version => 1,
		biochemistry => $input->{biochemistry},
		biochemistry_workspace => $input->{biochemistry_workspace},
		synonym_list => $reactionSynonyms,
		excluded_list => $excludedReactions
	};
	my $metadata = {
		number_synonyms => $numSynonyms,
		number_excluded => $numExcluded,
		biochemistry_ref => $biochem->_reference()
	};
	$output = $self->_save_msobject($object,"ReactionSynonyms",$input->{workspace},$input->{reaction_synonyms},{meta => $metadata});
    $self->_clearContext();
    #END find_reaction_synonyms
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to find_reaction_synonyms:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'find_reaction_synonyms');
    }
    return($output);
}




=head2 role_to_reactions

  $output = $obj->role_to_reactions($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a role_to_reactions_params
$output is a reference to a list where each element is a RoleComplexReactions
role_to_reactions_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
template_id is a string
workspace_id is a string
RoleComplexReactions is a reference to a hash where the following keys are defined:
	role has a value which is a role_id
	name has a value which is a string
	complexes has a value which is a reference to a list where each element is a ComplexReactions
role_id is a string
ComplexReactions is a reference to a hash where the following keys are defined:
	complex has a value which is a complex_id
	name has a value which is a string
	reactions has a value which is a reference to a list where each element is a TemplateReactions
complex_id is a string
TemplateReactions is a reference to a hash where the following keys are defined:
	reaction has a value which is a reaction_id
	direction has a value which is a string
	equation has a value which is a string
	compartment has a value which is a compartment_id
reaction_id is a string
compartment_id is a string

</pre>

=end html

=begin text

$params is a role_to_reactions_params
$output is a reference to a list where each element is a RoleComplexReactions
role_to_reactions_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
template_id is a string
workspace_id is a string
RoleComplexReactions is a reference to a hash where the following keys are defined:
	role has a value which is a role_id
	name has a value which is a string
	complexes has a value which is a reference to a list where each element is a ComplexReactions
role_id is a string
ComplexReactions is a reference to a hash where the following keys are defined:
	complex has a value which is a complex_id
	name has a value which is a string
	reactions has a value which is a reference to a list where each element is a TemplateReactions
complex_id is a string
TemplateReactions is a reference to a hash where the following keys are defined:
	reaction has a value which is a reaction_id
	direction has a value which is a string
	equation has a value which is a string
	compartment has a value which is a compartment_id
reaction_id is a string
compartment_id is a string


=end text



=item Description

Retrieves a list of roles mapped to reactions based on input template model

=back

=cut

sub role_to_reactions
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to role_to_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'role_to_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN role_to_reactions
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["templateModel","workspace"],{});
	my $template = $self->_get_msobject("ModelTemplate",$params->{workspace},$params->{templateModel});
	$output = $template->roleToReactions();
	$self->_clearContext();
    #END role_to_reactions
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to role_to_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'role_to_reactions');
    }
    return($output);
}




=head2 reaction_sensitivity_analysis

  $output = $obj->reaction_sensitivity_analysis($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a reaction_sensitivity_analysis_params
$output is an object_metadata
reaction_sensitivity_analysis_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_ws has a value which is a workspace_id
	rxnsens_uid has a value which is a string
	workspace has a value which is a workspace_id
	reactions_to_delete has a value which is a reference to a list where each element is a reaction_id
	gapfill_solution_id has a value which is a gapfillsolution_id
	delete_noncontributing_reactions has a value which is a bool
	rxnprobs_id has a value which is a rxnprob_id
	rxnprobs_ws has a value which is a workspace_id
	type has a value which is a string
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
reaction_id is a string
gapfillsolution_id is a string
bool is an int
rxnprob_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a reaction_sensitivity_analysis_params
$output is an object_metadata
reaction_sensitivity_analysis_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	model_ws has a value which is a workspace_id
	rxnsens_uid has a value which is a string
	workspace has a value which is a workspace_id
	reactions_to_delete has a value which is a reference to a list where each element is a reaction_id
	gapfill_solution_id has a value which is a gapfillsolution_id
	delete_noncontributing_reactions has a value which is a bool
	rxnprobs_id has a value which is a rxnprob_id
	rxnprobs_ws has a value which is a workspace_id
	type has a value which is a string
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
reaction_id is a string
gapfillsolution_id is a string
bool is an int
rxnprob_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Queues a sensitivity analysis on the knockout of model reactions

=back

=cut

sub reaction_sensitivity_analysis
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to reaction_sensitivity_analysis:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'reaction_sensitivity_analysis');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN reaction_sensitivity_analysis
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["model","workspace"],{
		objective_fraction => 0.1,
		objective_reaction => "bio1",
		media => "Complete",
		media_ws => "KBaseMedia",
		model_ws => $input->{workspace},
		rxnsens_uid => undef,
		type => "unknown",
		delete_noncontributing_reactions => 0,
		fba_ref => undef,
		delete_essential_reactions => 0,
		objective_sensitivity_only => 0,
		reactions_to_delete => undef,
		gapfill_ws => $input->{workspace},
		gapfill_solution_id => undef,
		rxnprobs_id => undef,
		rxnprobs_ws => $input->{workspace},
		solver => undef
	});
	print "Delete essential result:".$input->{delete_essential_reactions}."\n";
    if ($input->{delete_essential_reactions} == 0 && !defined($input->{reactions_to_delete}) && !defined($input->{gapfill_solution_id})) {
		my $msg = "Must specify either reactions_to_delete or a gapfill solution ID (if both are specified the gapfill solution is attemtped first)";
		$self->_error($msg);
    }
    # If the user does not specify a sign we add both directions to the list of things to delete.
    my $processedReactions = [];
    if ( defined($input->{reactions_to_delete}) ) {
		for ( my $i=0; $i<@{$input->{reactions_to_delete}}; $i++) { 
		    my $rxn = $input->{reactions_to_delete}->[$i];
		    if ( $rxn =~ /^[+-]/ ) {
				push(@$processedReactions, $rxn);
		    } else {
				push(@$processedReactions, "+".$rxn);
				push(@$processedReactions, "-".$rxn);
		    }
		}
    }
    $input->{reactions_to_delete} = $processedReactions;
    # If gapfill solution is defined we need to get the reactions associated with it.
    # We only try to get reactions that are acutally in the model.
    my $model = $self->_get_msobject("FBAModel",$input->{model_ws},$input->{model});
    if ( defined($input->{gapfill_solution_id}) ) {
	        # Note - this automatically changes the names to '+-' stuff
		my $rxnlist = $self->_get_gapfill_solution_reactions($input->{gapfill_solution_id}, $input->{gapfill_ws}, $model);
		if ( @{$rxnlist} == 0 ) {
		    my $msg = "No reactions in the specified gapfill solution were found in the model (did you integrate the gapfill solution first?)";
		    $self->_error($msg, "reaction_sensitivity_analysis");
		}
		if ( defined($input->{rxnprobs_id}) ) {
		    $rxnlist = $self->_sort_gapfill_solution_reactions($rxnlist, $input->{rxnprobs_id}, $input->{rxnprobs_ws});
		}
		if ( defined($input->{reactions_to_delete}) ) {
		    push(  @{$input->{reactions_to_delete}}, @{$rxnlist} );
		} else {
		    $input->{reactions_to_delete} = $rxnlist;
		}
    }
    my $objrxn = $model->searchForBiomass($input->{objective_reaction});
    my $type = "biomassflux";
    if (!defined($objrxn)) {
    	$type = "flux";
    	$objrxn = $model->searchForReaction($input->{objective_reaction});
    }
    if (!defined($objrxn)) {
    	$self->_error("Could not find objective reaction ".$input->{objective_reaction}." in model!");
    }
    $input->{objective_reaction} = $objrxn->id();
	my $formulation = $self->_setDefaultFBAFormulation({
		media => $input->{media},
		media_workspace => $input->{media_ws},
		objfraction => $input->{objective_fraction},
		objectiveTerms => [
			[1,$type,$input->{objective_reaction}]
		]
	});	
	#Creating FBAFormulation Object
	my $fba = $self->_buildFBAObject($formulation,$model);
	if ($input->{objective_sensitivity_only} == 1) {
		$fba->fva(0);
	}
	if (defined($input->{solver})) {
		$fba->parameters()->{MFASolver} = uc($input->{solver});
	}
	$fba->outputfiles()->{"FBAExperimentOutput.txt"} = [];
	$fba->parameters()->{"deletion experiments"} = "";
	my $media = $input->{media};
	if ($input->{delete_essential_reactions} == 1) {
		$fba->parameters()->{"deletion experiments"} = "essentialreactions:".$media.":essentialreactions";
	} else {
		for (my $i=0; $i < @{$input->{reactions_to_delete}}; $i++) {
			if (length($fba->parameters()->{"deletion experiments"}) > 0) {
				$fba->parameters()->{"deletion experiments"} .= ";";
			}
			$fba->parameters()->{"deletion experiments"} .= $input->{reactions_to_delete}->[$i].":".$media.":".$input->{reactions_to_delete}->[$i];
		}
	}
	if ($input->{delete_noncontributing_reactions} == 1) {
		$fba->parameters()->{"delete noncontributing reactions"} = 1;
	}
	$fba->parameters()->{"optimize metabolite production if objective is zero"} = 1;
	my $objective;
#    eval {
#		local $SIG{ALRM} = sub { die "FBA timed out! Model likely contains numerical instability!" };
#		alarm 600;
		$objective = $fba->runFBA();
#		alarm 0;
#	};
#	if ($@) {
#		$self->_error($@);
#    }
    if (!defined($objective)) {
    	$self->_error("FBA failed with no solution returned!");
    }
	my $fbameta = $self->_save_msobject($fba,"FBA",$input->{workspace},$fba->id(),{hidden => 1});
	my $kbid = $self->_get_new_id($model->id().".rxnsens.");
	if (!defined($input->{rxnsens_uid})) {
		$input->{rxnsens_uid} = $kbid;
	}
	my $object = Bio::KBase::ObjectAPI::KBaseFBA::ReactionSensitivityAnalysis->new({
		id => $kbid,
		fbamodel_ref => $model->_reference(),
		type => $input->{type},
		deleted_noncontributing_reactions => $input->{delete_noncontributing_reactions},
		integrated_deletions_in_model => 0,
		reactions => [],
		corrected_reactions => []
	});
	$object->parent($self->_KBaseStore());

	my $deletehash = {};
	for (my $j=0; $j < @{$input->{reactions_to_delete}}; $j++ ) {
	    $deletehash->{$input->{reactions_to_delete}->[$j]} = 1;
	}

	my $array = $fba->outputfiles()->{"FBAExperimentOutput.txt"};
	my $inactiveRxns = {};
	for (my $i=1; $i < @{$array}; $i++) {
		my $row = [split(/\t/,$array->[$i])];
		my ($direction, $rxnid);
		($rxnid = $row->[0]) =~ s/[+-]//;
		if ( $row->[0] =~ /^\+/ ) {
		    $direction = ">";
		} elsif ( $row->[0] =~ /^-/ ) {
		    $direction = "<";
		}
		my $sensrxn = {
			id => $object->id().".rxn.".($i-1),
			modelreaction_ref => $model->_reference()."/modelreactions/id/".$rxnid,
			growth_fraction => $row->[5],
			"delete" => 0,
			deleted => 0,
			direction => $direction,
			biomass_compounds => [],
			new_inactive_rxns => [],
			new_essentials => [split(/;/,$row->[8])]
		};
		if ($row->[7] eq "DELETED") {
		    $sensrxn->{"delete"} = 1;
		} else {
		    my $growth_fraction = $row->[5];
		    my $inactive_rxns = [split(/;/,$row->[7])];
		    my $ok_rxns = [];
		    for ( my $k=0; $k < @{$inactive_rxns}; $k++ ) {
			# Eliminate reactions that were tested for deletion from the list of inactive reactions
			if ( ! defined( $deletehash->{$inactive_rxns->[$k]} ) ) {
			    $inactiveRxns->{$inactive_rxns->[$k]}->{required}->{$row->[0]} = 1;
			    push(@{$ok_rxns}, $inactive_rxns->[$k]);
			}
		    }
		    # TODO - this cutoff should match the one in the MFA toolkit.
		    if ( @{$ok_rxns} == 0 && $growth_fraction > 0.00001) {
			$sensrxn->{"delete"} = 1;
		    } elsif ( @{$ok_rxns} > 0 ) {
			$sensrxn->{"new_inactive_rxns"} = $ok_rxns;
		    }
		}
		if ($row->[6] ne "NA") {
		    $sensrxn->{"biomass_compounds"} = [split(/;/,$row->[6])];
		}
		$object->add("reactions",$sensrxn);
	}
	foreach my $rxn (keys(%{$inactiveRxns})) {
	    # Collect a list of reactions inactivated by removing each particular tested reaction
		$inactiveRxns->{$rxn} = $object->add("corrected_reactions",{
		    id => $rxn,
			modelreaction_ref => $model->_reference()."/modelreactions/id/".$rxn."_c0",
			normalized_required_reaction_count => 0,
			required_reactions => [keys(%{$inactiveRxns->{$rxn}->{required}})]
		});
	}
	my $rxns = $object->reactions();
	for (my $i=0; $i < @{$rxns}; $i++) {
		# How many model reactions were inactivated by removing this reaction?
		my $rxn = $rxns->[$i];
		if ( @{$rxn->new_inactive_rxns()} == 0 ) {
		    $object->reactions()->[$i]->normalized_activated_reaction_count(0);
		    next;
		}
		# Calculate a weighted sum of reactions activated by each tested reaction (number 'activated' reactions)
		# and of the number of tested reactions that are required for each model reaction to be activated (number of 'required' reactions)
		my $value = 1/@{$rxn->new_inactive_rxns()};
		my $normalized_activated_reaction_count = 0;
		for (my $j=0; $j < @{$rxn->new_inactive_rxns()}; $j++) {
			my $inactiveRxn = $inactiveRxns->{$rxn->new_inactive_rxns()->[$j]};
			$normalized_activated_reaction_count += 1/@{$inactiveRxn->required_reactions()};
			$inactiveRxn->normalized_required_reaction_count($inactiveRxn->normalized_required_reaction_count()+$value);
		}
		# Save the value back to our object
		$object->reactions()->[$i]->normalized_activated_reaction_count($normalized_activated_reaction_count);
	}
	$output = $self->_save_msobject($object,"RxnSensitivity",$input->{workspace},$input->{rxnsens_uid});
	$self->_clearContext();
    #END reaction_sensitivity_analysis
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to reaction_sensitivity_analysis:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'reaction_sensitivity_analysis');
    }
    return($output);
}




=head2 filter_iterative_solutions

  $output = $obj->filter_iterative_solutions($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a filter_iterative_solutions_params
$output is an object_metadata
filter_iterative_solutions_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	outmodel has a value which is a fbamodel_id
	cutoff has a value which is a float
	gapfillsln has a value which is a gapfillsolution_id
	workspace has a value which is a workspace_id
	input_model_ws has a value which is a workspace_id
	auth has a value which is a string
fbamodel_id is a string
gapfillsolution_id is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a filter_iterative_solutions_params
$output is an object_metadata
filter_iterative_solutions_params is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	outmodel has a value which is a fbamodel_id
	cutoff has a value which is a float
	gapfillsln has a value which is a gapfillsolution_id
	workspace has a value which is a workspace_id
	input_model_ws has a value which is a workspace_id
	auth has a value which is a string
fbamodel_id is a string
gapfillsolution_id is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Apply a cutoff to remove high-cost iterations from an iterative gapfill run.

=back

=cut

sub filter_iterative_solutions
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to filter_iterative_solutions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'filter_iterative_solutions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN filter_iterative_solutions
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["model","workspace", "cutoff", "gapfillsln"],{
		input_model_ws => $input->{workspace},
		outmodel => $input->{model}	
    });

    my $model = $self->_get_msobject("FBAModel",$input->{input_model_ws},$input->{model});
    my $parsedid = $self->_parse_gapfillsolution_id($input->{gapfillsln});
    my $gapfill = $self->_get_msobject("Gapfilling", $input->{input_model_ws}, $parsedid->[0]);
    my $problemReport = $gapfill->fba()->outputfiles()->{"ProblemReport.txt"};
    # Map from reaction ID to the direction to delete in the model...
    my $deleteDirections = {};
    # Parse the ProblemReport.txt to get a list of reactions aded to the model to actiave each inactive reaction.
    # Start at 1 to skip the header
    # Apply the cutoff and flag reactions for deletion if they are part of a too-costly solution.
    for (my $i=1; $i<@{$problemReport}; $i++) {
	my $prString = $problemReport->[$i];
	my $spl = [];
	@$spl = split(/;/, $prString);
	my $obj = $spl->[1];
	my $solution = $spl->[2];
	# This should contain an array of (reactionID, direction) pairs.
	# Direction should be > or <
	my $slnrxnarray = $self->_parse_problem_report_solution($solution);
	my $numrxns = @{$slnrxnarray};
	my $norm = $obj/$numrxns;
	# Remove high-cost pathways.
	if ( $norm > $input->{cutoff} ) {
	    for (my $j=0; $j<@{$slnrxnarray}; $j++) {
		my $rxnid = $slnrxnarray->[$j]->[0];
		my $dir = $slnrxnarray->[$j]->[1];
		if ( defined($deleteDirections->{$rxnid} )) {
		    if ( ( $deleteDirections->{$rxnid} eq  $dir ) ) {
			next;
		    } else {
			$deleteDirections->{$rxnid} = "=";
		    }
		} else {
		    $deleteDirections->{$rxnid} = $dir;
		}
	    }
	}
    }

    foreach my $key ( keys(%{$deleteDirections}) ) {
	my $modelrxn = $model->searchForReaction($key);
	if ( ! defined($modelrxn) ) {
	    # This could happen because of previous filtering (e.g. a normal reaction_sensitivity_analysis)
#	    print STDERR "WARNING: Reaction $key flagged for deletion but not found in model";
	    next;
	}
	if ( $deleteDirections->{$key} eq "=" ) {
	    # Both directions were flagged for deletion, so we just delete the reaction.
	    $model->removeModelReaction({reaction => $key});
	} else {
	    # What is the direction in the model?
	    my $modelrxndir = $modelrxn->direction();
	    # Is the direction the same as deleteDirections?
	    if ( $modelrxndir eq $deleteDirections->{$key} ) {
		# If YES, delete the reaction.
		$model->removeModelReaction({reaction => $key});
	    } elsif ( $modelrxndir eq "=" ) {
			# If the model reaction is reversible we assume this means
			# that gapfilling changed the reversibility of that reaction.
			my($newdir);
			if ( $deleteDirections->{$key} eq ">" ) {
				$newdir = "<";
		    } else { $newdir = ">"; }
				$model->adjustModelReaction({
					reaction => $key,
					direction => $newdir 
				});
		    }
		}
    }
    
    $output = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{outmodel});

    #END filter_iterative_solutions
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to filter_iterative_solutions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'filter_iterative_solutions');
    }
    return($output);
}




=head2 delete_noncontributing_reactions

  $output = $obj->delete_noncontributing_reactions($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is a delete_noncontributing_reactions_params
$output is an object_metadata
delete_noncontributing_reactions_params is a reference to a hash where the following keys are defined:
	rxn_sensitivity_ws has a value which is a workspace_id
	rxn_sensitivity has a value which is a string
	workspace has a value which is a workspace_id
	new_model_uid has a value which is a fbamodel_id
	new_rxn_sensitivity_uid has a value which is a string
	auth has a value which is a string
workspace_id is a string
fbamodel_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is a delete_noncontributing_reactions_params
$output is an object_metadata
delete_noncontributing_reactions_params is a reference to a hash where the following keys are defined:
	rxn_sensitivity_ws has a value which is a workspace_id
	rxn_sensitivity has a value which is a string
	workspace has a value which is a workspace_id
	new_model_uid has a value which is a fbamodel_id
	new_rxn_sensitivity_uid has a value which is a string
	auth has a value which is a string
workspace_id is a string
fbamodel_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Deleted flagged reactions from a RxnSensitivity object

=back

=cut

sub delete_noncontributing_reactions
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to delete_noncontributing_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'delete_noncontributing_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN delete_noncontributing_reactions
    $self->_setContext($ctx,$input);
	$input = $self->_validateargs($input,["rxn_sensitivity","workspace"],{
		rxn_sensitivity_ws => $input->{workspace},
		new_model_uid => undef,
		new_rxn_sensitivity_uid => undef
	});
	my $rxnsens = $self->_get_msobject("RxnSensitivity",$input->{rxn_sensitivity_ws},$input->{rxn_sensitivity});
	$rxnsens->integrated_deletions_in_model(1);
	my $model = $rxnsens->fbamodel();
    $model->parent($self->_KBaseStore());
	for (my $i=0; $i < @{$rxnsens->reactions()}; $i++) {
		if ($rxnsens->reactions()->[$i]->delete() eq "1") {
			my $rxn = $model->getLinkedObject($rxnsens->reactions()->[$i]->modelreaction_ref());
			if (defined($rxn)) {
			    my $rxnid = $rxn->reaction()->id();
			    if ( ! defined($rxnsens->reactions()->[$i]->direction() ) ) {
				# For reverse compatibility with old RxnSensitivity objects
					$model->remove("modelreactions", $rxn);
			    } elsif ($rxn->direction() eq $rxnsens->reactions()->[$i]->direction()) {
					$model->remove("modelreactions",$rxn);
			    } else {
				my $dir = $rxnsens->reactions()->[$i]->direction();
				# Change from a reversible reaction to an irreversible one
				# (if model has < and rxnsensitivity had > or vice versa we just ignore it, maybe it was just already deleted somewhere else)
				if ( $rxn->direction() eq "=" ) {
				    # This should never happen but just in case
				    if ( $dir eq "=" ) {
						$model->remove("modelreactions", $rxn);
				    } elsif ( $dir eq ">" ) {
						$model->adjustModelReaction({
							reaction => $rxnid,
							direction => "<" 
						});
				    } elsif ( $dir eq "<" ) {
				    	$model->adjustModelReaction({
							reaction => $rxnid,
							direction => ">" 
						});
				    }
				}
			    }
			}
			$rxnsens->reactions()->[$i]->deleted(1);
		}
	}
	if (defined($input->{new_model_uid})) {
		$output = $self->_save_msobject($model,"FBAModel",$input->{workspace},$input->{new_model_uid});
	} else {
		$output = $self->_save_msobject($model,"FBAModel",$model->_wsworkspace(),$model->_wsname());
	}
    # This is one alternative fix to the problem that modelreaction references automatically update when re-saving the model to the workspace.
    # I here update the model ref to match it...
    $rxnsens->fbamodel_ref($model->_reference());
    if (defined($input->{new_rxn_sensitivity_uid})) {
	$self->_save_msobject($rxnsens,"RxnSensitivity",$input->{workspace},$input->{new_rxn_sensitivity_uid});
    } else {
	$self->_save_msobject($rxnsens,"RxnSensitivity",$rxnsens->_wsworkspace(),$rxnsens->_wsname());
    }
    $self->_clearContext();
    #END delete_noncontributing_reactions
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to delete_noncontributing_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'delete_noncontributing_reactions');
    }
    return($output);
}




=head2 annotate_workspace_Genome

  $output = $obj->annotate_workspace_Genome($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an annotate_workspace_Genome_params
$output is an object_metadata
annotate_workspace_Genome_params is a reference to a hash where the following keys are defined:
	Genome_uid has a value which is a string
	Genome_ws has a value which is a string
	new_uid has a value which is a string
	workspace has a value which is a workspace_id
	annotation_parameters has a value which is an AnnotationParameters
	auth has a value which is a string
workspace_id is a string
AnnotationParameters is a reference to a hash where the following keys are defined:
	call_genes has a value which is a bool
	annotate_genes has a value which is a bool
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an annotate_workspace_Genome_params
$output is an object_metadata
annotate_workspace_Genome_params is a reference to a hash where the following keys are defined:
	Genome_uid has a value which is a string
	Genome_ws has a value which is a string
	new_uid has a value which is a string
	workspace has a value which is a workspace_id
	annotation_parameters has a value which is an AnnotationParameters
	auth has a value which is a string
workspace_id is a string
AnnotationParameters is a reference to a hash where the following keys are defined:
	call_genes has a value which is a bool
	annotate_genes has a value which is a bool
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Create a job that runs the genome annotation pipeline on a genome object in a workspace

=back

=cut

sub annotate_workspace_Genome
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to annotate_workspace_Genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'annotate_workspace_Genome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN annotate_workspace_Genome
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["Genome_uid","workspace"],{
		Genome_ws => $params->{workspace},
		new_uid => $params->{Genome_uid},
		annotation_parameters => {}
	});
	my $genomeObj = $self->_get_msobject("Genome",$params->{Genome_ws},$params->{Genome_uid});
	$self->_annotate_genome($genomeObj,$params->{annotation_parameters});
  	$output = $self->_save_msobject($genomeObj,"Genome",$params->{workspace},$params->{new_uid});
	$self->_clearContext();
    #END annotate_workspace_Genome
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to annotate_workspace_Genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'annotate_workspace_Genome');
    }
    return($output);
}




=head2 gtf_to_genome

  $output = $obj->gtf_to_genome($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a gtf_to_genome_params
$output is an object_metadata
gtf_to_genome_params is a reference to a hash where the following keys are defined:
	contigset has a value which is a string
	contigset_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	genome_uid has a value which is a string
	source_id has a value which is a string
	source has a value which is a string
	scientific_name has a value which is a string
	domain has a value which is a string
	genetic_code has a value which is an int
	taxonomy has a value which is a string
	gtf_file has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a gtf_to_genome_params
$output is an object_metadata
gtf_to_genome_params is a reference to a hash where the following keys are defined:
	contigset has a value which is a string
	contigset_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	genome_uid has a value which is a string
	source_id has a value which is a string
	source has a value which is a string
	scientific_name has a value which is a string
	domain has a value which is a string
	genetic_code has a value which is an int
	taxonomy has a value which is a string
	gtf_file has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Loads a gtf file to a genome typed object in the workspace

=back

=cut

sub gtf_to_genome
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to gtf_to_genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'gtf_to_genome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN gtf_to_genome
     $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["gtf_file","workspace"],{
		contigset => undef,
		contigset_ws => $params->{workspace},
		genome_uid => undef,
		source_id => undef,
		source => "kbase",
		scientific_name => "Unknown species",
		domain => "Bacteria",
		genetic_code => 11,
		taxonomy => "Bacteria",
	});
	my $kbid = $self->_get_new_id("kb|g");
	if (!defined($params->{source_id})) {
		$params->{source_id} = $kbid;
		$params->{source} = "kbase";
	}
	if (!defined($params->{genome_uid})) {
		$params->{genome_uid} = $params->{source_id};
	}
	my $genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new({
		id => $kbid,
		scientific_name => $params->{scientific_name},
		domain => $params->{domain},
		genetic_code => $params->{genetic_code},
		dna_size => 0,
		num_contigs => 0,
		contig_lengths => [],
		contig_ids => [],
		source => $params->{source},
		source_id => $params->{source_id},
		taxonomy => $params->{taxonomy},
		gc_content => 0.5,
		complete => 0,
		publications => [],
		features => []
	});
	$genomeObj->gtf_to_features({gtffile => $params->{gtf_file}});
	if (defined($params->{contigset})) {
		my $contigObj = $self->_get_msobject("ContigSet",$params->{contigset_ws},$params->{contigset});
		$genomeObj->integrate_contigs({contigobj => $contigObj,update_features => 1});
	}
	$output = $self->_save_msobject($genomeObj,"Genome",$params->{workspace},$params->{genome_uid});
    $self->_clearContext();
    #END gtf_to_genome
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to gtf_to_genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'gtf_to_genome');
    }
    return($output);
}




=head2 fasta_to_ProteinSet

  $output = $obj->fasta_to_ProteinSet($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a fasta_to_ProteinSet_params
$output is an object_metadata
fasta_to_ProteinSet_params is a reference to a hash where the following keys are defined:
	uid has a value which is a string
	fasta has a value which is a string
	workspace has a value which is a workspace_id
	auth has a value which is a string
	name has a value which is a string
	sourceid has a value which is a string
	source has a value which is a string
	type has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a fasta_to_ProteinSet_params
$output is an object_metadata
fasta_to_ProteinSet_params is a reference to a hash where the following keys are defined:
	uid has a value which is a string
	fasta has a value which is a string
	workspace has a value which is a workspace_id
	auth has a value which is a string
	name has a value which is a string
	sourceid has a value which is a string
	source has a value which is a string
	type has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Loads a fasta file as a ProteinSet object in the workspace

=back

=cut

sub fasta_to_ProteinSet
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to fasta_to_ProteinSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'fasta_to_ProteinSet');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN fasta_to_ProteinSet
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["fasta","workspace"],{
		uid => undef,
		name => undef,
		sourceid => undef,
		source => undef,
		type => "Organism"
	});
	$output = $self->_build_sequence_object("ProteinSet",$params);
    $self->_clearContext();
    #END fasta_to_ProteinSet
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to fasta_to_ProteinSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'fasta_to_ProteinSet');
    }
    return($output);
}




=head2 ProteinSet_to_Genome

  $output = $obj->ProteinSet_to_Genome($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a ProteinSet_to_Genome_params
$output is an object_metadata
ProteinSet_to_Genome_params is a reference to a hash where the following keys are defined:
	ProteinSet_uid has a value which is a string
	ProteinSet_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	uid has a value which is a string
	auth has a value which is a string
	scientific_name has a value which is a string
	domain has a value which is a string
	annotation_parameters has a value which is an AnnotationParameters
workspace_id is a string
AnnotationParameters is a reference to a hash where the following keys are defined:
	call_genes has a value which is a bool
	annotate_genes has a value which is a bool
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a ProteinSet_to_Genome_params
$output is an object_metadata
ProteinSet_to_Genome_params is a reference to a hash where the following keys are defined:
	ProteinSet_uid has a value which is a string
	ProteinSet_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	uid has a value which is a string
	auth has a value which is a string
	scientific_name has a value which is a string
	domain has a value which is a string
	annotation_parameters has a value which is an AnnotationParameters
workspace_id is a string
AnnotationParameters is a reference to a hash where the following keys are defined:
	call_genes has a value which is a bool
	annotate_genes has a value which is a bool
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Creates a Genome associated with the ProteinSet object. You cannot recall genes on this genome.

=back

=cut

sub ProteinSet_to_Genome
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to ProteinSet_to_Genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'ProteinSet_to_Genome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN ProteinSet_to_Genome
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["ProteinSet_uid","workspace"],{
		ProteinSet_ws => $params->{workspace},
		uid => undef,
		taxonomy => undef,
		scientific_name => "Unknown sample",
		domain => "Bacteria",
		genetic_code => "11",
		source => undef,
		source_id => undef,
		annotation_parameters => {}
	});
	my $kbid = $self->_get_new_id("kb|g");
	if (!defined($params->{source_id})) {
		$params->{source} = "KBase";
		$params->{source_id} = $kbid;
	}
	if (!defined($params->{uid})) {
		$params->{uid} = $kbid;
	}
	my $size = 0;
	my $protObj = $self->_get_msobject("ProteinSet",$params->{ProteinSet_ws},$params->{ProteinSet_uid});
	my $proteins = $protObj->proteins();
	my $sequences = [];
	for (my $i=0; $i < @{$proteins}; $i++) {
		$size += length($proteins->[$i]->sequence());
		push(@{$sequences},$proteins->[$i]->sequence());
	}
	@{$sequences} = sort(@{$sequences});
	$size = 3*$size;
	my $genomeObj = {
		id => $kbid,
		scientific_name => $params->{scientific_name},
		domain => $params->{domain},
		genetic_code => $params->{genetic_code},
		dna_size => $size,
		num_contigs => 0,
		contig_lengths => [],
		contig_ids => [],
		source => $params->{source},
		source_id => $params->{source_id},
		md5 => Digest::MD5::md5_hex(join(";",@{$sequences})),
		taxonomy => $params->{taxonomy},
		gc_content => 0,
		complete => 1,
		publications => [],
		features => [],
    };
	for (my $i=0; $i < @{$proteins}; $i++) {
		push(@{$genomeObj->{features}},{
			id => $proteins->[$i]->id(),
			location => [],
			type => "peg",
			function => $proteins->[$i]->function(),
			md5 => $proteins->[$i]->md5(),
			protein_translation => $proteins->[$i]->sequence(),
			protein_translation_length => $proteins->[$i]->length(),
			dna_sequence_length => 3*$proteins->[$i]->length(),
			publications => [],
			subsystems => [],
			protein_families => $proteins->[$i]->protein_families(),
			aliases => $proteins->[$i]->aliases(),
			annotations => $proteins->[$i]->annotations(),
			subsystem_data => [],
			regulon_data => [],
			atomic_regulons => [],
			coexpressed_fids => [],
			co_occurring_fids => []
		});
	}
	foreach my $param (keys(%{$params->{annotation_parameters}})) {
		if ($param =~ m/^call/) {
			delete $params->{annotation_parameters}->{$param};
		}
	}
	$genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new($genomeObj);
	$genomeObj->parent($self->_KBaseStore());
	$self->_annotate_genome($genomeObj,$params->{annotation_parameters});
  	$output = $self->_save_msobject($genomeObj,"Genome",$params->{workspace},$params->{uid});
	$self->_clearContext();
    #END ProteinSet_to_Genome
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to ProteinSet_to_Genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'ProteinSet_to_Genome');
    }
    return($output);
}




=head2 fasta_to_ContigSet

  $output = $obj->fasta_to_ContigSet($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a fasta_to_ContigSet_params
$output is an object_metadata
fasta_to_ContigSet_params is a reference to a hash where the following keys are defined:
	uid has a value which is a string
	fasta has a value which is a string
	workspace has a value which is a workspace_id
	auth has a value which is a string
	name has a value which is a string
	sourceid has a value which is a string
	source has a value which is a string
	type has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a fasta_to_ContigSet_params
$output is an object_metadata
fasta_to_ContigSet_params is a reference to a hash where the following keys are defined:
	uid has a value which is a string
	fasta has a value which is a string
	workspace has a value which is a workspace_id
	auth has a value which is a string
	name has a value which is a string
	sourceid has a value which is a string
	source has a value which is a string
	type has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Loads a fasta file as a ContigSet object in the workspace

=back

=cut

sub fasta_to_ContigSet
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to fasta_to_ContigSet:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'fasta_to_ContigSet');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN fasta_to_ContigSet
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["fasta","workspace"],{
		uid => undef,
		name => undef,
		sourceid => undef,
		source => undef,
		type => "Organism",
		shockurl => undef
	});
	$output = $self->_build_sequence_object("ContigSet",$params);
    $self->_clearContext();
    #END fasta_to_ContigSet
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to fasta_to_ContigSet:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'fasta_to_ContigSet');
    }
    return($output);
}




=head2 ContigSet_to_Genome

  $output = $obj->ContigSet_to_Genome($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a ContigSet_to_Genome_params
$output is an object_metadata
ContigSet_to_Genome_params is a reference to a hash where the following keys are defined:
	ContigSet_uid has a value which is a string
	ContigSet_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	uid has a value which is a string
	auth has a value which is a string
	scientific_name has a value which is a string
	domain has a value which is a string
	genetic_code has a value which is an int
	annotation_parameters has a value which is an AnnotationParameters
workspace_id is a string
AnnotationParameters is a reference to a hash where the following keys are defined:
	call_genes has a value which is a bool
	annotate_genes has a value which is a bool
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a ContigSet_to_Genome_params
$output is an object_metadata
ContigSet_to_Genome_params is a reference to a hash where the following keys are defined:
	ContigSet_uid has a value which is a string
	ContigSet_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	uid has a value which is a string
	auth has a value which is a string
	scientific_name has a value which is a string
	domain has a value which is a string
	genetic_code has a value which is an int
	annotation_parameters has a value which is an AnnotationParameters
workspace_id is a string
AnnotationParameters is a reference to a hash where the following keys are defined:
	call_genes has a value which is a bool
	annotate_genes has a value which is a bool
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Creates a genome associated with the ContigSet object

=back

=cut

sub ContigSet_to_Genome
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to ContigSet_to_Genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'ContigSet_to_Genome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN ContigSet_to_Genome
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["ContigSet_uid","workspace"],{
		ContigSet_ws => $params->{workspace},
		uid => undef,
		taxonomy => "Bacteria",
		scientific_name => "Unknown sample",
		domain => "Bacteria",
		genetic_code => "11",
		source => undef,
		source_id => undef,
		annotation_parameters => {}
	});
	my $kbid = $self->_get_new_id("kb|g");
	if (!defined($params->{source_id})) {
		$params->{source} = "KBase";
		$params->{source_id} = $kbid;
	}
	if (!defined($params->{uid})) {
		$params->{uid} = $kbid;
	}
	my $size = 0;
	my $gc = 0;
	my $contigObj = $self->_get_msobject("ContigSet",$params->{ContigSet_ws},$params->{ContigSet_uid});
	my $contigs = $contigObj->contigs();
	for (my $i=0; $i < @{$contigs}; $i++) {
		my $seq = $contigs->[$i]->sequence();
		$size += length($seq);
		for ( my $j = 0 ; $j < length($seq) ; $j++ ) {
			if ( substr( $seq, $j, 1 ) =~ m/[gcGC]/ ) {
				$gc++;
			}
		}
	}
	$gc = $gc/$size;
	my $numcontigs = @{$contigs};
	my $genomeObj = {
		id => $kbid,
		scientific_name => $params->{scientific_name},
		domain => $params->{domain},
		genetic_code => $params->{genetic_code},
		dna_size => $size,
		num_contigs => $numcontigs,
		contig_lengths => [],
		contig_ids => [],
		source => $params->{source},
		source_id => $params->{source_id},
		md5 => $contigObj->md5(),
		taxonomy => $params->{taxonomy},
		contigset_ref => $contigObj->_reference(),
		gc_content => $gc,
		complete => 1,
		publications => [],
		features => [],
    };
	for (my $i=0; $i < @{$contigs}; $i++) {
		push(@{$genomeObj->{contig_ids}},$contigs->[$i]->id());
		push(@{$genomeObj->{contig_lengths}},$contigs->[$i]->length());
	}
	$genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new($genomeObj);
	$genomeObj->parent($self->_KBaseStore());
	$self->_annotate_genome($genomeObj,$params->{annotation_parameters});
  	$output = $self->_save_msobject($genomeObj,"Genome",$params->{workspace},$params->{uid});
	$self->_clearContext();
    #END ContigSet_to_Genome
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to ContigSet_to_Genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'ContigSet_to_Genome');
    }
    return($output);
}




=head2 probanno_to_genome

  $output = $obj->probanno_to_genome($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a probanno_to_genome_params
$output is an object_metadata
probanno_to_genome_params is a reference to a hash where the following keys are defined:
	pa_id has a value which is a probanno_id
	pa_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	g_id has a value which is a genome_id
	threshold has a value which is a float
	auth has a value which is a string
probanno_id is a string
workspace_id is a string
genome_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a probanno_to_genome_params
$output is an object_metadata
probanno_to_genome_params is a reference to a hash where the following keys are defined:
	pa_id has a value which is a probanno_id
	pa_ws has a value which is a workspace_id
	workspace has a value which is a workspace_id
	g_id has a value which is a genome_id
	threshold has a value which is a float
	auth has a value which is a string
probanno_id is a string
workspace_id is a string
genome_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Converts a probabilistic annotation into a genome with the same annotations

=back

=cut

sub probanno_to_genome
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to probanno_to_genome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'probanno_to_genome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN probanno_to_genome
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["pa_id","workspace"],{
		g_id => undef,
		pa_ws => $params->{workspace},
		threshold => undef,
	});
	if (!defined($params->{g_id})) {
		$params->{g_id} = $self->_get_new_id("kb|g.");
	}
	my $pa = $self->_get_msobject("ProbabilisticAnnotation",$params->{pa_ws},$params->{pa_id});
	my $gn = $self->_get_msobject("Genome",$pa->{genome_workspace},$pa->{genome});
	if (!defined($pa->roleset_probabilities())) {
		$self->_error("No annotations in probanno!","probanno_to_genome");
	}
	my $ftrs = $gn->features();
	for (my $i=0; $i < @{$ftrs};$i++) {
		my $ftr = $ftrs->[$i];
		if (defined($pa->roleset_probabilities()->{$ftr->id()})) {
			my $function = "";
			for (my $j=0; $j < @{$pa->roleset_probabilities()->{$ftr->id()}};$j++) {
				my $func = $pa->roleset_probabilities()->{$ftr->id()}->[$j];
				if (!defined($params->{threshold}) || $func->[1] > $params->{threshold}) {
					if (length($function) > 0) {
						$function .= " @ ";
					}
					$function .= $func->[0];
				}
			}
			$ftr->function($function);
		} 
	}
	$output = $self->_save_msobject($gn,"Genome",$params->{workspace},$params->{g_id});
	$self->_clearContext();
    #END probanno_to_genome
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to probanno_to_genome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'probanno_to_genome');
    }
    return($output);
}




=head2 get_mapping

  $output = $obj->get_mapping($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a get_mapping_params
$output is a Mapping
get_mapping_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
Mapping is a reference to a hash where the following keys are defined:
	id has a value which is a mapping_id
	name has a value which is a string
	subsystems has a value which is a reference to a list where each element is a Subsystem
	roles has a value which is a reference to a list where each element is a FunctionalRole
	complexes has a value which is a reference to a list where each element is a Complex
Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a subsystem_id
	name has a value which is a string
	phenoclass has a value which is a string
	subclass has a value which is a string
	type has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a role_id
subsystem_id is a string
role_id is a string
FunctionalRole is a reference to a hash where the following keys are defined:
	id has a value which is a role_id
	name has a value which is a string
	feature has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	complexes has a value which is a reference to a list where each element is a complex_id
complex_id is a string
Complex is a reference to a hash where the following keys are defined:
	id has a value which is a complex_id
	name has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a ComplexRole
ComplexRole is a reference to a list containing 4 items:
	0: (id) a role_id
	1: (roleType) a string
	2: (optional_role) a bool
	3: (triggering) a bool
bool is an int

</pre>

=end html

=begin text

$params is a get_mapping_params
$output is a Mapping
get_mapping_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
Mapping is a reference to a hash where the following keys are defined:
	id has a value which is a mapping_id
	name has a value which is a string
	subsystems has a value which is a reference to a list where each element is a Subsystem
	roles has a value which is a reference to a list where each element is a FunctionalRole
	complexes has a value which is a reference to a list where each element is a Complex
Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a subsystem_id
	name has a value which is a string
	phenoclass has a value which is a string
	subclass has a value which is a string
	type has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a role_id
subsystem_id is a string
role_id is a string
FunctionalRole is a reference to a hash where the following keys are defined:
	id has a value which is a role_id
	name has a value which is a string
	feature has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	complexes has a value which is a reference to a list where each element is a complex_id
complex_id is a string
Complex is a reference to a hash where the following keys are defined:
	id has a value which is a complex_id
	name has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a ComplexRole
ComplexRole is a reference to a list containing 4 items:
	0: (id) a role_id
	1: (roleType) a string
	2: (optional_role) a bool
	3: (triggering) a bool
bool is an int


=end text



=item Description

Annotates contigs object creating a genome object

=back

=cut

sub get_mapping
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_mapping:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_mapping');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN get_mapping
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,[],{
		"map" => "default-mapping",
		workspace => "kbase",
	});
    my $map = $self->_get_msobject("Mapping",$input->{workspace},$input->{"map"});
    $output = {
    	id => $input->{workspace}."/".$input->{"map"},
    	name => $map->name(),
    	subsystems => [],
    	roles => [],
    	complexes => []
    };
    my $roles = $map->roles();
    for (my $i=0; $i < @{$roles}; $i++) {
    	my $role = $roles->[$i];
    	push(@{$output->{roles}},{
    		id => $role->id(),
    		name => $role->name(),
    		feature => $role->seedfeature(),
    		aliases => $role->allAliases(),
    		complexes => $role->complexIDs()
    	});
    }
    my $sss = $map->subsystems();
    for (my $i=0; $i < @{$sss}; $i++) {
    	my $ss = $sss->[$i];
    	push(@{$output->{subsystems}},{
    		id => $ss->id(),
    		name => $ss->name(),
    		primclass => $ss->class(),
    		subclass => $ss->subclass(),
    		type => $ss->type(),
    		aliases => $ss->allAliases(),
    		roles => $ss->roleIDs()
    	});
    }
    my $complexes = $map->complexes();
    for (my $i=0; $i < @{$complexes}; $i++) {
    	my $complex = $complexes->[$i];
    	push(@{$output->{complexes}},{
    		id => $complex->id(),
    		name => $complex->name(),
    		aliases => $complex->allAliases(),
    		roles => $complex->roleTuples()
    	});
    }
    #END get_mapping
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_mapping:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_mapping');
    }
    return($output);
}




=head2 subsystem_of_roles

  $output = $obj->subsystem_of_roles($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a subsystem_of_roles_params
$output is a reference to a hash where the key is a string and the value is a subsysclasses
subsystem_of_roles_params is a reference to a hash where the following keys are defined:
	roles has a value which is a reference to a list where each element is a string
	map has a value which is a string
	map_workspace has a value which is a string
subsysclasses is a reference to a hash where the key is a string and the value is a subsysclass
subsysclass is a reference to a list containing 2 items:
	0: a string
	1: a string

</pre>

=end html

=begin text

$params is a subsystem_of_roles_params
$output is a reference to a hash where the key is a string and the value is a subsysclasses
subsystem_of_roles_params is a reference to a hash where the following keys are defined:
	roles has a value which is a reference to a list where each element is a string
	map has a value which is a string
	map_workspace has a value which is a string
subsysclasses is a reference to a hash where the key is a string and the value is a subsysclass
subsysclass is a reference to a list containing 2 items:
	0: a string
	1: a string


=end text



=item Description

Returns subsystems for list roles

=back

=cut

sub subsystem_of_roles
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to subsystem_of_roles:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'subsystem_of_roles');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN subsystem_of_roles
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["roles"],{
		"map" => "default-mapping",
		"map_workspace" => "kbase",
	});
    my $map = $self->_get_msobject("Mapping",$input->{workspace},$input->{"map"});
    my $sshash = $map->roleSubsystemHash();
    my $output = {};
    for (my $i=0; $i < @{$input->{roles}}; $i++) {
    	my $role = $map->queryObject("roles",{searchname => Bio::KBase::ObjectAPI::utilities::convertRoleToSearchRole($input->{roles}->[$i])});
   		if (defined($role) && defined($sshash->{$role->id()})) {
   			foreach my $key (keys(%{$sshash->{$role->id()}})) {
   				my $ss = $sshash->{$role->id()}->{$key};
   				$output->{$input->{roles}->[$i]}->{$ss->name()} = [$ss->primclass(),$ss->subclass()];
   			}
   		}
    }
    #END subsystem_of_roles
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to subsystem_of_roles:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'subsystem_of_roles');
    }
    return($output);
}




=head2 adjust_mapping_role

  $output = $obj->adjust_mapping_role($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an adjust_mapping_role_params
$output is a FunctionalRole
adjust_mapping_role_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	role has a value which is a string
	new has a value which is a bool
	name has a value which is a string
	feature has a value which is a string
	aliasesToAdd has a value which is a reference to a list where each element is a string
	aliasesToRemove has a value which is a reference to a list where each element is a string
	delete has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
bool is an int
FunctionalRole is a reference to a hash where the following keys are defined:
	id has a value which is a role_id
	name has a value which is a string
	feature has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	complexes has a value which is a reference to a list where each element is a complex_id
role_id is a string
complex_id is a string

</pre>

=end html

=begin text

$params is an adjust_mapping_role_params
$output is a FunctionalRole
adjust_mapping_role_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	role has a value which is a string
	new has a value which is a bool
	name has a value which is a string
	feature has a value which is a string
	aliasesToAdd has a value which is a reference to a list where each element is a string
	aliasesToRemove has a value which is a reference to a list where each element is a string
	delete has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
bool is an int
FunctionalRole is a reference to a hash where the following keys are defined:
	id has a value which is a role_id
	name has a value which is a string
	feature has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	complexes has a value which is a reference to a list where each element is a complex_id
role_id is a string
complex_id is a string


=end text



=item Description

An API function supporting the curation of functional roles in a mapping object

=back

=cut

sub adjust_mapping_role
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_mapping_role:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_mapping_role');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN adjust_mapping_role
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["map","workspace"],{
		role => undef,
		"new" => undef,
		name => undef,
		feature => undef,
		aliasesToAdd => [],
		aliasesToRemove => [],
		"delete" => undef
	});
    my $map = $self->_get_msobject("Mapping",$input->{workspace},$input->{"map"});
    my $arguments = {};
    if (defined($input->{"new"})) {
    	$arguments->{id} = "new";
    } else {
    	$arguments->{id} = $input->{role};
    }
	if (defined($input->{name})) {
		$arguments->{name} = $input->{name};
	}
	if (defined($input->{feature})) {
		$arguments->{seedfeature} = $input->{feature};
	}
	if (defined($input->{"delete"})) {
		$arguments->{"delete"} = $input->{"delete"};
	}
	if (defined($input->{aliasesToAdd})) {
		$arguments->{aliasToAdd} = $input->{aliasesToAdd};
	}
	if (defined($input->{aliasesToRemove})) {
		$arguments->{aliasToRemove} = $input->{aliasesToRemove};
	}
	my $role = $map->adjustRole($arguments);
	$output = $self->_save_msobject($map,"Mapping",$input->{workspace},$input->{"map"});
    #END adjust_mapping_role
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_mapping_role:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_mapping_role');
    }
    return($output);
}




=head2 adjust_mapping_complex

  $output = $obj->adjust_mapping_complex($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an adjust_mapping_complex_params
$output is a Complex
adjust_mapping_complex_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	complex has a value which is a string
	new has a value which is a bool
	name has a value which is a string
	rolesToAdd has a value which is a reference to a list where each element is a string
	rolesToRemove has a value which is a reference to a list where each element is a string
	delete has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
bool is an int
Complex is a reference to a hash where the following keys are defined:
	id has a value which is a complex_id
	name has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a ComplexRole
complex_id is a string
ComplexRole is a reference to a list containing 4 items:
	0: (id) a role_id
	1: (roleType) a string
	2: (optional_role) a bool
	3: (triggering) a bool
role_id is a string

</pre>

=end html

=begin text

$params is an adjust_mapping_complex_params
$output is a Complex
adjust_mapping_complex_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	complex has a value which is a string
	new has a value which is a bool
	name has a value which is a string
	rolesToAdd has a value which is a reference to a list where each element is a string
	rolesToRemove has a value which is a reference to a list where each element is a string
	delete has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
bool is an int
Complex is a reference to a hash where the following keys are defined:
	id has a value which is a complex_id
	name has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a ComplexRole
complex_id is a string
ComplexRole is a reference to a list containing 4 items:
	0: (id) a role_id
	1: (roleType) a string
	2: (optional_role) a bool
	3: (triggering) a bool
role_id is a string


=end text



=item Description

An API function supporting the curation of complexes in a mapping object

=back

=cut

sub adjust_mapping_complex
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_mapping_complex:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_mapping_complex');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN adjust_mapping_complex
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["map","workspace"],{
		complex => undef,
		"new" => undef,
		name => undef,
		rolesToAdd => [],
		rolesToRemove => [],
		clearRoles => 0,
		"delete" => undef
	});
    my $map = $self->_get_msobject("Mapping",$input->{workspace},$input->{"map"});
    my $arguments = {};
    if (defined($input->{"new"})) {
    	$arguments->{id} = "new";
    } else {
    	$arguments->{id} = $input->{complex};
    }
    my $paramlist = [qw(clearRoles name delete rolesToAdd rolesToRemove)];
    foreach my $param (@{$paramlist}) {
    	if (defined($input->{$param})) {
    		$arguments->{$param} = $input->{$param};
    	}
    }
	my $cpx = $map->adjustComplex($arguments);
	$output = $self->_save_msobject($map,"Mapping",$input->{workspace},$input->{"map"});
    #END adjust_mapping_complex
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_mapping_complex:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_mapping_complex');
    }
    return($output);
}




=head2 adjust_mapping_subsystem

  $output = $obj->adjust_mapping_subsystem($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an adjust_mapping_subsystem_params
$output is a Subsystem
adjust_mapping_subsystem_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	subsystem has a value which is a string
	new has a value which is a bool
	name has a value which is a string
	type has a value which is a string
	primclass has a value which is a string
	subclass has a value which is a string
	rolesToAdd has a value which is a reference to a list where each element is a string
	rolesToRemove has a value which is a reference to a list where each element is a string
	delete has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
bool is an int
Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a subsystem_id
	name has a value which is a string
	phenoclass has a value which is a string
	subclass has a value which is a string
	type has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a role_id
subsystem_id is a string
role_id is a string

</pre>

=end html

=begin text

$params is an adjust_mapping_subsystem_params
$output is a Subsystem
adjust_mapping_subsystem_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	workspace has a value which is a workspace_id
	subsystem has a value which is a string
	new has a value which is a bool
	name has a value which is a string
	type has a value which is a string
	primclass has a value which is a string
	subclass has a value which is a string
	rolesToAdd has a value which is a reference to a list where each element is a string
	rolesToRemove has a value which is a reference to a list where each element is a string
	delete has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
bool is an int
Subsystem is a reference to a hash where the following keys are defined:
	id has a value which is a subsystem_id
	name has a value which is a string
	phenoclass has a value which is a string
	subclass has a value which is a string
	type has a value which is a string
	aliases has a value which is a reference to a list where each element is a string
	roles has a value which is a reference to a list where each element is a role_id
subsystem_id is a string
role_id is a string


=end text



=item Description

An API function supporting the curation of subsystems in a mapping object

=back

=cut

sub adjust_mapping_subsystem
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_mapping_subsystem:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_mapping_subsystem');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN adjust_mapping_subsystem
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["map","workspace"],{
		subsystem => undef,
		"new" => undef,
		name => undef,
		type => undef,
		primclass => undef,
		subclass => undef,
		rolesToAdd => [],
		rolesToRemove => [],
		clearRoles => 0,
		"delete" => undef
	});
    my $map = $self->_get_msobject("Mapping",$input->{workspace},$input->{"map"});
    my $arguments = {};
    if (defined($input->{"new"})) {
    	$arguments->{id} = "new";
    } else {
    	$arguments->{id} = $input->{subsystem};
    }
    my $paramlist = [qw(clearRoles name primclass subclass delete type rolesToAdd rolesToRemove)];
    foreach my $param (@{$paramlist}) {
    	if (defined($input->{$param})) {
    		$arguments->{$param} = $input->{$param};
    	}
    }
	my $ss = $map->adjustSubsystem($arguments);
	$output = $self->_save_msobject($map,"Mapping",$input->{workspace},$input->{"map"});
    #END adjust_mapping_subsystem
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_mapping_subsystem:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_mapping_subsystem');
    }
    return($output);
}




=head2 get_template_model

  $output = $obj->get_template_model($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a get_template_model_params
$output is a TemplateModel
get_template_model_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
template_id is a string
workspace_id is a string
TemplateModel is a reference to a hash where the following keys are defined:
	id has a value which is a template_id
	name has a value which is a string
	type has a value which is a string
	domain has a value which is a string
	map has a value which is a mapping_id
	mappingws has a value which is a workspace_id
	reactions has a value which is a reference to a list where each element is a TemplateReaction
	biomasses has a value which is a reference to a list where each element is a TemplateBiomass
mapping_id is a string
TemplateReaction is a reference to a hash where the following keys are defined:
	id has a value which is a temprxn_id
	compartment has a value which is a compartment_id
	reaction has a value which is a reaction_id
	complexes has a value which is a reference to a list where each element is a complex_id
	direction has a value which is a string
	type has a value which is a string
temprxn_id is a string
compartment_id is a string
reaction_id is a string
complex_id is a string
TemplateBiomass is a reference to a hash where the following keys are defined:
	id has a value which is a tempbiomass_id
	name has a value which is a string
	type has a value which is a string
	other has a value which is a string
	protein has a value which is a string
	dna has a value which is a string
	rna has a value which is a string
	cofactor has a value which is a string
	energy has a value which is a string
	cellwall has a value which is a string
	lipid has a value which is a string
	compounds has a value which is a reference to a list where each element is a TemplateBiomassCompounds
tempbiomass_id is a string
TemplateBiomassCompounds is a reference to a list containing 7 items:
	0: (compound) a compound_id
	1: (compartment) a compartment_id
	2: (cpdclass) a string
	3: (universal) a string
	4: (coefficientType) a string
	5: (coefficient) a string
	6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
		0: (coeffficient) a string
		1: (compound) a compound_id

compound_id is a string

</pre>

=end html

=begin text

$params is a get_template_model_params
$output is a TemplateModel
get_template_model_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	auth has a value which is a string
template_id is a string
workspace_id is a string
TemplateModel is a reference to a hash where the following keys are defined:
	id has a value which is a template_id
	name has a value which is a string
	type has a value which is a string
	domain has a value which is a string
	map has a value which is a mapping_id
	mappingws has a value which is a workspace_id
	reactions has a value which is a reference to a list where each element is a TemplateReaction
	biomasses has a value which is a reference to a list where each element is a TemplateBiomass
mapping_id is a string
TemplateReaction is a reference to a hash where the following keys are defined:
	id has a value which is a temprxn_id
	compartment has a value which is a compartment_id
	reaction has a value which is a reaction_id
	complexes has a value which is a reference to a list where each element is a complex_id
	direction has a value which is a string
	type has a value which is a string
temprxn_id is a string
compartment_id is a string
reaction_id is a string
complex_id is a string
TemplateBiomass is a reference to a hash where the following keys are defined:
	id has a value which is a tempbiomass_id
	name has a value which is a string
	type has a value which is a string
	other has a value which is a string
	protein has a value which is a string
	dna has a value which is a string
	rna has a value which is a string
	cofactor has a value which is a string
	energy has a value which is a string
	cellwall has a value which is a string
	lipid has a value which is a string
	compounds has a value which is a reference to a list where each element is a TemplateBiomassCompounds
tempbiomass_id is a string
TemplateBiomassCompounds is a reference to a list containing 7 items:
	0: (compound) a compound_id
	1: (compartment) a compartment_id
	2: (cpdclass) a string
	3: (universal) a string
	4: (coefficientType) a string
	5: (coefficient) a string
	6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
		0: (coeffficient) a string
		1: (compound) a compound_id

compound_id is a string


=end text



=item Description

Retrieves the specified template model

=back

=cut

sub get_template_model
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to get_template_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_template_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN get_template_model
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["templateModel","workspace"],{});
    my $template = $self->_get_msobject("ModelTemplate",$input->{workspace},$input->{templateModel});
    $output = {
    	id => $input->{workspace}."/".$input->{templateModel},
    	name => $template->name(),
    	type => $template->modelType(),
    	domain => $template->domain(),
    	"map" => $template->{_kbaseWSMeta}->{wsid},
    	mappingws => $template->{_kbaseWSMeta}->{ws},
    	reactions => [],
    	biomasses => []
    };
    my $rxns = $template->templateReactions();
    for (my $i=0; $i < @{$rxns}; $i++) {
    	my $rxn = $rxns->[$i];
    	push(@{$output->{reactions}},{
    		id => $rxn->uuid(),
    		compartment => $rxn->compartment()->id(),
    		reaction => $rxn->reaction()->id(),
    		complexes => $rxn->complexIDs(),
    		direction => $rxn->direction(),
    		type => $rxn->type()
    	});
    }
    my $bios = $template->templateBiomasses();
    for (my $i=0; $i < @{$bios}; $i++) {
    	my $bio = $bios->[$i];
    	push(@{$output->{biomasses}},{
    		id => $bio->uuid(),
    		name => $bio->name(),
    		type => $bio->type(),
    		other => $bio->other(),
    		protein => $bio->protein(),
    		dna => $bio->dna(),
    		rna => $bio->rna(),
    		cofactor => $bio->cofactor(),
    		energy => $bio->energy(),
    		cellwall => $bio->cellwall(),
    		lipid => $bio->lipid(),
    		compounds => $bio->compoundTuples()
    	});
    }
    #END get_template_model
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to get_template_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'get_template_model');
    }
    return($output);
}




=head2 import_template_fbamodel

  $modelMeta = $obj->import_template_fbamodel($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an import_template_fbamodel_params
$modelMeta is an object_metadata
import_template_fbamodel_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	mapping_workspace has a value which is a workspace_id
	templateReactions has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: (id) a string
	1: (compartment) a string
	2: (direction) a string
	3: (type) a string
	4: (complexes) a reference to a list where each element is a string

	templateBiomass has a value which is a reference to a list where each element is a reference to a list containing 11 items:
	0: (name) a string
	1: (type) a string
	2: (dna) a float
	3: (rna) a float
	4: (protein) a float
	5: (lipid) a float
	6: (cellwall) a float
	7: (cofactor) a float
	8: (energy) a float
	9: (other) a float
	10: (compounds) a reference to a list where each element is a reference to a list containing 6 items:
		0: (id) a string
		1: (compartment) a string
		2: (cpdclass) a string
		3: (coefficientType) a string
		4: (coefficient) a float
		5: (conditions) a string


	name has a value which is a string
	modelType has a value which is a string
	domain has a value which is a string
	id has a value which is a template_id
	workspace has a value which is a workspace_id
	ignore_errors has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
template_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an import_template_fbamodel_params
$modelMeta is an object_metadata
import_template_fbamodel_params is a reference to a hash where the following keys are defined:
	map has a value which is a mapping_id
	mapping_workspace has a value which is a workspace_id
	templateReactions has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: (id) a string
	1: (compartment) a string
	2: (direction) a string
	3: (type) a string
	4: (complexes) a reference to a list where each element is a string

	templateBiomass has a value which is a reference to a list where each element is a reference to a list containing 11 items:
	0: (name) a string
	1: (type) a string
	2: (dna) a float
	3: (rna) a float
	4: (protein) a float
	5: (lipid) a float
	6: (cellwall) a float
	7: (cofactor) a float
	8: (energy) a float
	9: (other) a float
	10: (compounds) a reference to a list where each element is a reference to a list containing 6 items:
		0: (id) a string
		1: (compartment) a string
		2: (cpdclass) a string
		3: (coefficientType) a string
		4: (coefficient) a float
		5: (conditions) a string


	name has a value which is a string
	modelType has a value which is a string
	domain has a value which is a string
	id has a value which is a template_id
	workspace has a value which is a workspace_id
	ignore_errors has a value which is a bool
	auth has a value which is a string
mapping_id is a string
workspace_id is a string
template_id is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Import a template model from an input table of template reactions and biomass components

=back

=cut

sub import_template_fbamodel
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_template_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_template_fbamodel');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN import_template_fbamodel
    $self->_setContext($ctx,$input);
    $input = $self->_validateargs($input,["workspace"],{
    	"map" => "default-mapping",
    	mapping_workspace => "kbase",
    	biochem => "default",
    	biochem_workspace => "kbase",
    	templateReactions => [],
    	templateBiomass => [],
    	name => undef,
    	modelType => "GenomeScale",
    	domain => "Bacteria",
    	uid => undef,
    	ignore_errors => 0
    });
    my $kbid = $self->_get_new_id("kb|template.");
    my $map = $self->_get_msobject("Mapping",$input->{mapping_workspace},$input->{"map"});
	my $bio = $self->_get_msobject("Biochemistry",$input->{biochem_workspace},$input->{biochem});
	if (!defined($input->{uid})) {
    	$input->{uid} = $kbid;
    }
    if (!defined($input->{name})) {
    	$input->{name} = $input->{uid};	
    }
	my $mdlTmp = Bio::KBase::ObjectAPI::KBaseFBA::ModelTemplate->new({
		id => $kbid,
    	name => $input->{name},
		modelType => $input->{modelType},
		domain => $input->{domain},
		mapping_ref => $map->_reference(),
		biochemistry_ref => $bio->_reference(),
    	templateReactions => [],
    	templateBiomasses => []
	});
	$mdlTmp->parent($self->_KBaseStore());
	for (my $i=0; $i < @{$input->{templateReactions}}; $i++) {
		my $row = $input->{templateReactions}->[$i];
		my $rxn = $bio->searchForReaction($row->[0]);
		if (!defined($rxn)) {
			$self->_error("Reaction ".$row->[0]." not found!");
		}
		my $cmp = $bio->searchForCompartment($row->[1]);
		if (!defined($cmp)) {
			$self->_error("Compartment ".$row->[1]." not found!");
		}
		my $cpxs = [];
		for (my $j=0; $j < @{$row->[4]}; $j++) {
			my $cpx = $map->searchForComplex($row->[4]->[$j]);
			if (!defined($cpx)) {
				$self->_error("Complex ".$row->[4]->[$j]." not found!");
			}
			push(@{$cpxs},$cpx->_reference());
		}
		if (!defined($row->[2]) || length($row->[2]) == 0) {
			$row->[2] = $rxn->direction();
		}
		if (!defined($row->[3]) || length($row->[3]) == 0) {
			$row->[3] = "conditional";
		}
		$mdlTmp->add("templateReactions",{
			id => $kbid.".rxn.".$i,
			reaction_ref => $rxn->_reference(),
			compartment_ref => $cmp->_reference(),
			direction => $row->[2],
			type => $row->[3],
			complex_refs => $cpxs
		});
	}
	for (my $i=0; $i < @{$input->{templateBiomass}}; $i++) {
		my $row = $input->{templateBiomass}->[$i];
		my $comps = [];
		my $tmpBio = $mdlTmp->add("templateBiomasses",{
			id => $kbid.".bio.".$i,
			name => $row->[0],
			type => $row->[1],
			dna => $row->[2],
			rna => $row->[3],
			protein => $row->[4],
			lipid => $row->[5],
			cellwall => $row->[6],
			cofactor => $row->[7],
			energy => $row->[8],
			other => $row->[9],
			templateBiomassComponents => []
		});
		for (my $j=0; $j < @{$row->[10]}; $j++) {
			my $comprow = $row->[10]->[$j];
			my $cmp = $bio->searchForCompartment($comprow->[1]);
			if (!defined($cmp)) {
				$self->_error("Compartment ".$comprow->[1]." not found!");
			}
			my $cpd = $bio->searchForCompound($comprow->[0]);
			if (!defined($cpd)) {
				$self->_error("Compound ".$comprow->[0]." not found!");
			}
			my $comp = Bio::KBase::ObjectAPI::KBaseFBA::TemplateBiomassComponent->new({
				id => $tmpBio->id().".cpd.".$j,
				class => $comprow->[2],
				compound_ref => $cpd->_reference(),
				compartment_ref => $cmp->_reference(),
				coefficientType => $comprow->[3],
				coefficient => $comprow->[4]+0,
				linked_compound_refs => [],
				link_coefficients => []
			});
			if (@{$comprow->[6]} > 0) {
				my $linkuuids = [];
				my $linkcoefs = [];
				for (my $k=0; $k < @{$comprow->[6]}; $k++) {
					$cpd = $bio->searchForCompound($comprow->[6]->[$k]->[0]);
					if (!defined($cpd)) {
						$self->_error("Compound ".$comprow->[6]->[$k]->[0]." not found!");
					}
					push(@{$linkuuids},$cpd->uuid());
					push(@{$linkcoefs},$comprow->[6]->[$k]->[1]+0);
				}
				$comp->linked_compound_refs($linkuuids);
				$comp->link_coefficients($linkcoefs);
			}
			$tmpBio->add("templateBiomassComponents",$comp);
		}
	}
    $modelMeta = $self->_save_msobject($mdlTmp,"ModelTemplate",$input->{workspace},$input->{uid});
    $self->_clearContext();
    #END import_template_fbamodel
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_template_fbamodel:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_template_fbamodel');
    }
    return($modelMeta);
}




=head2 adjust_template_reaction

  $modelMeta = $obj->adjust_template_reaction($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an adjust_template_reaction_params
$modelMeta is an object_metadata
adjust_template_reaction_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	reaction has a value which is a string
	clearComplexes has a value which is a bool
	new has a value which is a bool
	delete has a value which is a bool
	compartment has a value which is a compartment_id
	complexesToAdd has a value which is a reference to a list where each element is a complex_id
	complexesToRemove has a value which is a reference to a list where each element is a complex_id
	direction has a value which is a string
	type has a value which is a string
	auth has a value which is a string
template_id is a string
workspace_id is a string
bool is an int
compartment_id is a string
complex_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an adjust_template_reaction_params
$modelMeta is an object_metadata
adjust_template_reaction_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	reaction has a value which is a string
	clearComplexes has a value which is a bool
	new has a value which is a bool
	delete has a value which is a bool
	compartment has a value which is a compartment_id
	complexesToAdd has a value which is a reference to a list where each element is a complex_id
	complexesToRemove has a value which is a reference to a list where each element is a complex_id
	direction has a value which is a string
	type has a value which is a string
	auth has a value which is a string
template_id is a string
workspace_id is a string
bool is an int
compartment_id is a string
complex_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Modifies a reaction of a template model

=back

=cut

sub adjust_template_reaction
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_template_reaction:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_template_reaction');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN adjust_template_reaction
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["templateModel","workspace","reaction"],{
		compartment => "c",
		"new" => 0,
		direction => undef,
		type => "conditional",
		complexesToAdd => [],
		complexesToRemove => [],
		clearComplexes => 0,
		"delete" => 0,
		output_id => $params->{templateModel}
	});
    my $tempmdl = $self->_get_msobject("ModelTemplate",$input->{workspace},$input->{templateModel});
    my $arguments = {reaction => $input->{reaction}};
    my $paramlist = [qw(compartment new delete clearComplexes direction type complexesToAdd complexesToRemove)];
    foreach my $param (@{$paramlist}) {
    	if (defined($input->{$param})) {
    		$arguments->{$param} = $input->{$param};
    	}
    }
	my $rxn = $tempmdl->adjustReaction($arguments);
	$modelMeta = $self->_save_msobject($tempmdl,"ModelTemplate",$input->{workspace},$input->{output_id});
    #END adjust_template_reaction
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_template_reaction:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_template_reaction');
    }
    return($modelMeta);
}




=head2 adjust_template_biomass

  $modelMeta = $obj->adjust_template_biomass($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an adjust_template_biomass_params
$modelMeta is an object_metadata
adjust_template_biomass_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	biomass has a value which is a string
	new has a value which is a bool
	delete has a value which is a bool
	clearBiomassCompounds has a value which is a bool
	name has a value which is a string
	type has a value which is a string
	other has a value which is a string
	protein has a value which is a string
	dna has a value which is a string
	rna has a value which is a string
	cofactor has a value which is a string
	energy has a value which is a string
	cellwall has a value which is a string
	lipid has a value which is a string
	compoundsToRemove has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (compartment) a compartment_id

	compoundsToAdd has a value which is a reference to a list where each element is a reference to a list containing 7 items:
	0: (compound) a compound_id
	1: (compartment) a compartment_id
	2: (cpdclass) a string
	3: (universal) a string
	4: (coefficientType) a string
	5: (coefficient) a string
	6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
		0: (coeffficient) a string
		1: (compound) a compound_id


	auth has a value which is a string
template_id is a string
workspace_id is a string
bool is an int
compound_id is a string
compartment_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an adjust_template_biomass_params
$modelMeta is an object_metadata
adjust_template_biomass_params is a reference to a hash where the following keys are defined:
	templateModel has a value which is a template_id
	workspace has a value which is a workspace_id
	biomass has a value which is a string
	new has a value which is a bool
	delete has a value which is a bool
	clearBiomassCompounds has a value which is a bool
	name has a value which is a string
	type has a value which is a string
	other has a value which is a string
	protein has a value which is a string
	dna has a value which is a string
	rna has a value which is a string
	cofactor has a value which is a string
	energy has a value which is a string
	cellwall has a value which is a string
	lipid has a value which is a string
	compoundsToRemove has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (compound) a compound_id
	1: (compartment) a compartment_id

	compoundsToAdd has a value which is a reference to a list where each element is a reference to a list containing 7 items:
	0: (compound) a compound_id
	1: (compartment) a compartment_id
	2: (cpdclass) a string
	3: (universal) a string
	4: (coefficientType) a string
	5: (coefficient) a string
	6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
		0: (coeffficient) a string
		1: (compound) a compound_id


	auth has a value which is a string
template_id is a string
workspace_id is a string
bool is an int
compound_id is a string
compartment_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Modifies the biomass of a template model

=back

=cut

sub adjust_template_biomass
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to adjust_template_biomass:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_template_biomass');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($modelMeta);
    #BEGIN adjust_template_biomass
    $self->_setContext($ctx,$params);
    my $input = $self->_validateargs($params,["templateModel","workspace"],{
		biomass => undef,
		"new" => 0,
		"delete" => 0,
		clearBiomassCompounds => 0,
		name => undef,
		type => undef,
		other => undef,
		protein => undef,
		dna => undef,
		rna => undef,
		cofactor => undef,
		energy => undef,
		cellwall => undef,
		lipid => undef,
		compoundsToAdd => [],
		compoundsToRemove => [],
		output_id => $params->{templateModel}
	});
    my $tempmdl = $self->_get_msobject("ModelTemplate",$input->{workspace},$input->{templateModel});
    my $arguments = {};
    my $paramlist = [qw(biomass new delete clearBiomassCompounds name type other protein dna rna cofactor energy cellwall lipid compoundsToRemove compoundsToAdd)];
    foreach my $param (@{$paramlist}) {
    	if (defined($input->{$param})) {
    		$arguments->{$param} = $input->{$param};
    	}
    }
	my $bio = $tempmdl->adjustBiomass($arguments);
    $modelMeta = $self->_save_msobject($tempmdl,"ModelTemplate",$input->{workspace},$input->{output_id});
    #END adjust_template_biomass
    my @_bad_returns;
    (ref($modelMeta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"modelMeta\" (value was \"$modelMeta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to adjust_template_biomass:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'adjust_template_biomass');
    }
    return($modelMeta);
}




=head2 add_stimuli

  $output = $obj->add_stimuli($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an add_stimuli_params
$output is an object_metadata
add_stimuli_params is a reference to a hash where the following keys are defined:
	biochemid has a value which is a string
	biochem_workspace has a value which is a string
	stimuliid has a value which is a string
	name has a value which is a string
	abbreviation has a value which is a string
	type has a value which is a string
	description has a value which is a string
	compounds has a value which is a reference to a list where each element is a string
	workspace has a value which is a string
	auth has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an add_stimuli_params
$output is an object_metadata
add_stimuli_params is a reference to a hash where the following keys are defined:
	biochemid has a value which is a string
	biochem_workspace has a value which is a string
	stimuliid has a value which is a string
	name has a value which is a string
	abbreviation has a value which is a string
	type has a value which is a string
	description has a value which is a string
	compounds has a value which is a reference to a list where each element is a string
	workspace has a value which is a string
	auth has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Adds a stimuli either to the central database or as an object in a workspace

=back

=cut

sub add_stimuli
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to add_stimuli:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_stimuli');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN add_stimuli
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["name","workspace"],{
		biochemid => "default",
		biochem_workspace => "kbase",
		stimuliid => undef,
		abbreviation => $params->{name},
		description => "",
		compounds => [],
		type => undef
	});
	if (!defined($params->{type})) {
		$params->{type} = "environmental";
		if (@{$params->{compounds}} > 0) {
			$params->{type} = "chemical";
		}
	}
	my $allowableTypes = {
		chemical => 1,environmental => 1
	};
	if (!defined($allowableTypes->{$params->{type}})) {
		$self->_error("Input type ".$params->{type}." not recognized!","add_stimuli");
	}
	if (!defined($params->{stimuliid})) {
		$params->{stimuliid} = $self->_get_new_id("stim.");
	}
	my $biochem = $self->_get_msobject("Biochemistry",$params->{biochem_workspace},$params->{biochemid});
	my $obj = {
		description => $params->{stimuliid},
		id => $params->{stimuliid},
		name => $params->{name},
		type => $params->{type},
		abbreviation => $params->{abbreviation},
		description => $params->{description},
		compound_uuids => []
	};
	my $missingCpd;
	if (defined($params->{compounds})) {
		for (my $i=0; $i < @{$params->{compounds}}; $i++) {
			my $cpd = $params->{compounds}->[$i];
			my $cpdobj = $biochem->searchForCompound($cpd);
			if (!defined($cpdobj)) {
				push(@{$missingCpd},$cpd);
			} else {
				push(@{$obj->{compound_uuids}},$cpdobj->uuid());
			}
		}
	}
	if (defined($params->{biochemid})) {
		$biochem->add("stimuli",$obj);
		$output = $self->_save_msobject($biochem,"Biochemistry",$params->{biochem_workspace},$params->{biochemid},"add_stimuli");	
	} else {
		$output = $self->_save_msobject($obj,"Stimuli",$params->{workspace},$params->{stimuliid},"add_stimuli");
	}
	$self->_clearContext();
    #END add_stimuli
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to add_stimuli:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_stimuli');
    }
    return($output);
}




=head2 import_regulatory_model

  $output = $obj->import_regulatory_model($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an import_regulatory_model_params
$output is an object_metadata
import_regulatory_model_params is a reference to a hash where the following keys are defined:
	regmodel_uid has a value which is a string
	workspace has a value which is a workspace_id
	genome has a value which is a string
	genome_ws has a value which is a workspace_id
	name has a value which is a string
	type has a value which is a string
	regulons has a value which is a reference to a list where each element is a reference to a list containing 3 items:
	0: (name) a string
	1: (features) a reference to a list where each element is a string
	2: (stimuli) a reference to a list where each element is a reference to a list containing 6 items:
		0: (stimuli) a string
		1: (in_inhibitor) a bool
		2: (strength) a float
		3: (min_conc) a float
		4: (max_conc) a float
		5: (regulators) a reference to a list where each element is a kbase_id


	auth has a value which is a string
workspace_id is a string
bool is an int
kbase_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an import_regulatory_model_params
$output is an object_metadata
import_regulatory_model_params is a reference to a hash where the following keys are defined:
	regmodel_uid has a value which is a string
	workspace has a value which is a workspace_id
	genome has a value which is a string
	genome_ws has a value which is a workspace_id
	name has a value which is a string
	type has a value which is a string
	regulons has a value which is a reference to a list where each element is a reference to a list containing 3 items:
	0: (name) a string
	1: (features) a reference to a list where each element is a string
	2: (stimuli) a reference to a list where each element is a reference to a list containing 6 items:
		0: (stimuli) a string
		1: (in_inhibitor) a bool
		2: (strength) a float
		3: (min_conc) a float
		4: (max_conc) a float
		5: (regulators) a reference to a list where each element is a kbase_id


	auth has a value which is a string
workspace_id is a string
bool is an int
kbase_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Imports a regulatory model into the KBase workspace

=back

=cut

sub import_regulatory_model
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_regulatory_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_regulatory_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN import_regulatory_model
     $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["genome","workspace","regulators"],{
		biochemid => "default",
		biochem_workspace => "kbase",
		regmodel_uid => undef,
		genome_ws => $params->{workspace},
		name => undef,
		type => undef
	});
	if (!defined($params->{type})) {
		$params->{type} = "environmental";
		if (@{$params->{compounds}} > 0) {
			$params->{type} = "chemical";
		}
	}
	my $allowableTypes = {
		chemical => 1,environmental => 1
	};
	if (!defined($allowableTypes->{$params->{type}})) {
		$self->_error("Input type ".$params->{type}." not recognized!","add_stimuli");
	}
	if (!defined($params->{stimuliid})) {
		$params->{stimuliid} = $self->_get_new_id("stim.");
	}
	my $biochem = $self->_get_msobject("Biochemistry",$params->{biochem_workspace},$params->{biochemid});
	my $obj = {
		description => $params->{stimuliid},
		id => $params->{stimuliid},
		name => $params->{name},
		type => $params->{type},
		abbreviation => $params->{abbreviation},
		description => $params->{description},
		compound_uuids => []
	};
	my $missingCpd;
	if (defined($params->{compounds})) {
		for (my $i=0; $i < @{$params->{compounds}}; $i++) {
			my $cpd = $params->{compounds}->[$i];
			my $cpdobj = $biochem->searchForCompound($cpd);
			if (!defined($cpdobj)) {
				push(@{$missingCpd},$cpd);
			} else {
				push(@{$obj->{compound_uuids}},$cpdobj->uuid());
			}
		}
	}
	if (defined($params->{biochemid})) {
		$biochem->add("stimuli",$obj);
		$output = $self->_save_msobject($biochem,"Biochemistry",$params->{biochem_workspace},$params->{biochemid},"add_stimuli");	
	} else {
			}
	
	$output = $self->_save_msobject($obj,"Stimuli",$params->{workspace},$params->{stimuliid},"add_stimuli");
	$self->_clearContext();
    #END import_regulatory_model
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_regulatory_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_regulatory_model');
    }
    return($output);
}




=head2 compare_models

  $output = $obj->compare_models($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a compare_models_params
$output is a ModelComparisonData
compare_models_params is a reference to a hash where the following keys are defined:
	models has a value which is a reference to a list where each element is a fbamodel_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
ModelComparisonData is a reference to a hash where the following keys are defined:
	model_comparisons has a value which is a reference to a list where each element is a ModelComparisonModel
	reaction_comparisons has a value which is a reference to a list where each element is a ModelCompareReaction
	auth has a value which is a string
ModelComparisonModel is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	model_name has a value which is a string
	genome has a value which is a genome_id
	genome_name has a value which is a string
	gapfilled_reactions has a value which is an int
	core_reactions has a value which is an int
	noncore_reactions has a value which is an int
genome_id is a string
ModelCompareReaction is a reference to a hash where the following keys are defined:
	reaction has a value which is a reaction_id
	compartment has a value which is a string
	equation has a value which is a string
	core has a value which is a bool
	model_features has a value which is a reference to a hash where the key is a fbamodel_id and the value is a reference to a list where each element is a feature_id
	role has a value which is a string
	subsystem has a value which is a string
	primclass has a value which is a string
	subclass has a value which is a string
	number_models has a value which is an int
	fraction_models has a value which is a float
reaction_id is a string
bool is an int
feature_id is a string

</pre>

=end html

=begin text

$params is a compare_models_params
$output is a ModelComparisonData
compare_models_params is a reference to a hash where the following keys are defined:
	models has a value which is a reference to a list where each element is a fbamodel_id
	workspaces has a value which is a reference to a list where each element is a workspace_id
	auth has a value which is a string
fbamodel_id is a string
workspace_id is a string
ModelComparisonData is a reference to a hash where the following keys are defined:
	model_comparisons has a value which is a reference to a list where each element is a ModelComparisonModel
	reaction_comparisons has a value which is a reference to a list where each element is a ModelCompareReaction
	auth has a value which is a string
ModelComparisonModel is a reference to a hash where the following keys are defined:
	model has a value which is a fbamodel_id
	workspace has a value which is a workspace_id
	model_name has a value which is a string
	genome has a value which is a genome_id
	genome_name has a value which is a string
	gapfilled_reactions has a value which is an int
	core_reactions has a value which is an int
	noncore_reactions has a value which is an int
genome_id is a string
ModelCompareReaction is a reference to a hash where the following keys are defined:
	reaction has a value which is a reaction_id
	compartment has a value which is a string
	equation has a value which is a string
	core has a value which is a bool
	model_features has a value which is a reference to a hash where the key is a fbamodel_id and the value is a reference to a list where each element is a feature_id
	role has a value which is a string
	subsystem has a value which is a string
	primclass has a value which is a string
	subclass has a value which is a string
	number_models has a value which is an int
	fraction_models has a value which is a float
reaction_id is a string
bool is an int
feature_id is a string


=end text



=item Description

Compares the specified models and computes unique reactions and core reactions

=back

=cut

sub compare_models
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to compare_models:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'compare_models');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN compare_models
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["models","workspaces"],{});
	$output = {
		model_comparisons => [],
		reaction_comparisons => []
	};
	my $universal = {
		rxn05651 => 1,
		rxn10473 => 1,
		rxn10571 => 1,
		rxn05195 => 1,
		rxn05555 => 1
	};
	my $spontaneous = {
		rxn00062 => 1,
		rxn01208 => 1,
		rxn04132 => 1,
		rxn04133 => 1,
		rxn05319 => 1,
		rxn05467 => 1,
		rxn05468 => 1,
		rxn02374 => 1,
		rxn05116 => 1,
		rxn03012 => 1,
		rxn05064 => 1,
		rxn02666 => 1,
		rxn04457 => 1,
		rxn04456 => 1,
		rxn01664 => 1,
		rxn02916 => 1,
		rxn05667 => 1
	};
	my $modelhash = {};
	my $rxnhash = {};
	my $SubsysRoles = {};
	my $template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramNegModelTemplate");
	my $map = $template->mapping();
	my $rxnroles = {};
	my $rxns = $template->templateReactions();
	for (my $k=0; $k < @{$rxns}; $k++) {
		my $rxn = $rxns->[$k];
		for (my $m=0; $m < @{$rxn->complexs()}; $m++) {
			my $cpx = $rxn->complexs()->[$m];
			my $cpxroles = $cpx->complexroles();
			for (my $j=0; $j < @{$cpxroles}; $j++) {
				my $role = $cpxroles->[$j]->role();
				if (defined($role)) {
					push(@{$rxnroles->{$rxn->reaction()->id()}},$role);
				}
			}
		}
	}
	my $rolesets = $map->subsystems();
	for (my $i=0; $i < @{$rolesets}; $i++) {
		my $roleset = $rolesets->[$i];
		my $roles = $roleset->roles();
		for (my $j=0; $j < @{$roles}; $j++) {
			$SubsysRoles->{$roles->[$j]->name()} = $roleset;
		}
	}
	for (my $i=0; $i < @{$params->{models}}; $i++) {
		my $mdl = $params->{models}->[$i];
		my $ws = $params->{workspaces}->[$i];
		my $model = $self->_get_msobject("FBAModel",$ws,$mdl);
		if (defined($model)) {
			$modelhash->{$ws."/".$mdl} = @{$output->{model_comparisons}};
			my $modelcomp = {
				model => $mdl,
				workspace => $ws,
				model_name => $model->name(),
				genome => "None",
				genome_name => "None",
				gapfilled_reactions => 0,
				core_reactions => 0,
				noncore_reactions => 0
			};
			if (defined($model->genome_ref())) {
				$modelcomp->{genome} = $model->genome()->id();
				$modelcomp->{genome} = $model->genome()->scientific_name();
			}
			my $mdlrxns = $model->modelreactions();
			for (my $j=0; $j < @{$mdlrxns}; $j++) {
				my $mdlrxn = $mdlrxns->[$j];
				if (!defined($rxnhash->{$mdlrxn->reaction()->id()}->{$mdlrxn->modelcompartment()->compartment()->id()})) {
					$rxnhash->{$mdlrxn->reaction()->id()}->{$mdlrxn->modelcompartment()->compartment()->id()} = @{$output->{reaction_comparisons}};
					my $roles = [];
					if (defined($rxnroles->{$mdlrxn->reaction()->id()})) {
						$roles = $rxnroles->{$mdlrxn->reaction()->id()};
					}
					my $rolenames = [];
					my $subsystems = [];
					my $classes = [];
					my $subclasses = [];
					for (my $k=0; $k < @{$roles}; $k++) {
						push(@{$rolenames},$roles->[$k]->name());
						if (defined($SubsysRoles->{$roles->[$k]->name()})) {
							push(@{$subsystems},$SubsysRoles->{$roles->[$k]->name()}->name());
							push(@{$classes},$SubsysRoles->{$roles->[$k]->name()}->class());
							push(@{$subclasses},$SubsysRoles->{$roles->[$k]->name()}->subclass());
						}
						push(@{$subsystems},"None");
						push(@{$classes},"None");
						push(@{$subclasses},"None");						
					}
					push(@{$output->{reaction_comparisons}},{
						reaction => $mdlrxn->reaction()->id(),
						compartment => $mdlrxn->modelcompartment()->compartment()->id(),
						equation => $mdlrxn->definition(),
						core => 1,
						model_features => {},
						role => join(";",@{$rolenames}),
						subsytem => join(";",@{$subsystems}),
						primclass => join(";",@{$classes}),
						subclass => join(";",@{$subclasses}),
						number_models => 0,
						fraction_models => 0
					});
				}
				my $index = $rxnhash->{$mdlrxn->reaction()->id()}->{$mdlrxn->modelcompartment()->compartment()->id()};
				my $ftrs = $mdlrxn->featureIDs();
				if (@{$ftrs} == 0) {
					if (defined($universal->{$mdlrxn->reaction()->id()})) {
						$ftrs = ["Universal"];
					} if (defined($spontaneous->{$mdlrxn->reaction()->id()})) {
						$ftrs = ["Spontaneous"];
					} else {
						$ftrs = ["Gapfilled"];
						$model->{gapfilled_reactions}++;
					}
				}
				push(@{$output->{reaction_comparisons}->[$index]->{model_features}->{$ws."/".$mdl}},@{$ftrs});
			}
			push(@{$output->{model_comparisons}},$modelcomp);
		}
	}
	my $nummodels = @{$output->{model_comparisons}};
	for (my $j=0; $j < @{$output->{reaction_comparisons}}; $j++) {
		my $rxn = $output->{reaction_comparisons}->[$j];
		$rxn->{number_models} = keys(%{$rxn->{model_features}});
		$rxn->{fraction_models} = $rxn->{number_models}/$nummodels;
		if ($nummodels == $rxn->{number_models}) {
			foreach my $key (keys(%{$rxn->{model_features}})) {
				$output->{model_comparisons}->[$modelhash->{$key}]->{core_reactions}++;
			}
		} else {
			foreach my $key (keys(%{$rxn->{model_features}})) {
				$output->{model_comparisons}->[$modelhash->{$key}]->{noncore_reactions}++;
			}
			$rxn->{core} = 0;
		}
	}
	$self->_clearContext();
    #END compare_models
    my @_bad_returns;
    (ref($output) eq 'HASH') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to compare_models:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'compare_models');
    }
    return($output);
}




=head2 compare_genomes

  $output = $obj->compare_genomes($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a compare_genomes_params
$output is an object_metadata
compare_genomes_params is a reference to a hash where the following keys are defined:
	pangenome_id has a value which is a string
	pangenome_ws has a value which is a string
	protcomp_id has a value which is a string
	protcomp_ws has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a compare_genomes_params
$output is an object_metadata
compare_genomes_params is a reference to a hash where the following keys are defined:
	pangenome_id has a value which is a string
	pangenome_ws has a value which is a string
	protcomp_id has a value which is a string
	protcomp_ws has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Compares the specified genomes and computes unique features and core features

=back

=cut

sub compare_genomes
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to compare_genomes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'compare_genomes');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN compare_genomes
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["workspace"],{
		pangenome_id => undef,
		pangenome_ws => $params->{workspace},
		protcomp_id => undef,
		protcomp_ws => $params->{workspace},
		mapping => "default-mapping",
		mapping_workspace => "kbase",
		output_id => undef,
	});
	my $orthos;
	my $members = {};
	my $genome_ids;
	my $genome_wwss;
	my $genome_refs;
	my $gc = {
		genomes => [],
		families => [],
		functions => [],
		core_functions => 0,
		core_families => 0
	};
	if (defined($params->{pangenome_id})) {
		if (!defined($params->{output_id})) {
			$params->{output_id} = $params->{pangenome_id}."_comparison";
		}
		my $pg = $self->_get_msobject("Pangenome",$params->{pangenome_ws},$params->{pangenome_id});
		$gc->{pangenome_ref} = $pg->_reference();
		$genome_refs = $pg->genome_refs();
		my $refhash;
		for (my $i=0; $i < @{$genome_refs}; $i++) {
			if (!defined($refhash->{$genome_refs->[$i]})) {
				my $array = [split(/\//,$genome_refs->[$i])];
				push(@{$genome_ids},$array->[1]);
				push(@{$genome_wwss},$array->[0]);
				$refhash->{$genome_refs->[$i]} = 1;
			}
		}
		my $orthofam = $pg->orthologs();
		for (my $i=0; $i < @{$orthofam}; $i++) {
			for (my $j=0; $j < @{$orthofam->[$i]->orthologs()}; $j++) {
				$orthos->{$orthofam->[$i]->id()}->{$orthofam->[$i]->orthologs()->[$j]->[2]}->{$orthofam->[$i]->orthologs()->[$j]->[0]} = $orthofam->[$i]->orthologs()->[$j]->[1];
				$members->{$orthofam->[$i]->orthologs()->[$j]->[2]}->{$orthofam->[$i]->orthologs()->[$j]->[0]} = $orthofam->[$i]->id();
			}
		}
	} elsif (defined($params->{protcomp_id})) {
		if (!defined($params->{output_id})) {
			$params->{output_id} = $params->{protcomp_id}."_comparison";
		}
		my $pc = $self->_get_msobject("ProteomeComparison",$params->{protcomp_ws},$params->{protcomp_id});
		$gc->{protcomp_ref} = $pc->_reference();
		$genome_refs = [$pc->genome1ws()."/".$pc->genome1id(),$pc->genome2ws()."/".$pc->genome2id()];
		$genome_ids = [$pc->genome1id(),$pc->genome2id()];
		$genome_wwss = [$pc->genome1ws(),$pc->genome2ws()];
		my $plist = $pc->proteome1names();
		my $oplist = $pc->proteome2names();
		my $d = $pc->data1();
		for (my $i=0; $i < @{$plist}; $i++) {
			my $family;
			my $sorthos;
			for (my $j=0; $j < @{$d->[$i]}; $j++) {
				if ($d->[$i]->[$j]->[2] >= 90) {
					my $gene = $oplist->[$d->[$i]->[$j]->[0]];
					$sorthos->{$gene} = $d->[$i]->[$j]->[1];
					if (defined($members->{$genome_refs->[1]}->{$gene})) {
						$family = $members->{$genome_refs->[1]}->{$gene};
					}
				}
			}
			if (!defined($family)) {
				$family = $plist->[$i];	
			}
			$orthos->{$family}->{$genome_refs->[0]}->{$plist->[$i]} = 100;
			$members->{$genome_refs->[0]}->{$plist->[$i]} = $family;
			foreach my $gene (keys(%{$sorthos})) {
				$members->{$genome_refs->[1]}->{$gene} = $family;
				$orthos->{$family}->{$genome_refs->[1]}->{$gene} = $sorthos->{$gene};
			}
		}
		$d = $pc->data2();
		for (my $i=0; $i < @{$oplist}; $i++) {
			if (!defined($members->{$genome_refs->[1]}->{$oplist->[$i]})) {
				my $family;
				my $sorthos;
				for (my $j=0; $j < @{$d->[$i]}; $j++) {
					if ($d->[$i]->[$j]->[2] >= 90) {
						my $gene = $plist->[$d->[$i]->[$j]->[0]];
						$sorthos->{$gene} = $d->[$i]->[$j]->[1];
						if (defined($members->{$genome_refs->[0]}->{$gene})) {
							$family = $members->{$genome_refs->[0]}->{$gene};
						}
					}
				}
				if (!defined($family)) {
					$family = $oplist->[$i];	
				}
				$orthos->{$family}->{$genome_refs->[1]}->{$oplist->[$i]} = 100;
				$members->{$genome_refs->[1]}->{$oplist->[$i]} = $family;
				foreach my $gene (keys(%{$sorthos})) {
					$members->{$genome_refs->[0]}->{$gene} = $family;
					$orthos->{$family}->{$genome_refs->[0]}->{$gene} = $sorthos->{$gene};
				}
			}
		}
	} else {
		$self->_error("Must provide either a pangenome or proteome comparison as input!");
	}
	$gc->{id} = $params->{workspace}."/".$params->{output_id};
	$gc->{name} = $params->{output_id};
	#Retrieving subsystem data from mapping
	my $map = $self->_get_msobject("Mapping",$params->{mapping_workspace},$params->{mapping});
	my $SubsysRoles = {};
	my $GenomeHash = {};
	my $FunctionHash = {};
	my $rolesets = $map->subsystems();
	for (my $i=0; $i < @{$rolesets}; $i++) {
		my $roleset = $rolesets->[$i];
		my $roles = $roleset->roles();
		for (my $j=0; $j < @{$roles}; $j++) {
			$SubsysRoles->{$roles->[$j]->name()} = $roleset;
		}
	}
	#Associating roles and reactions
	my $template = $self->_get_msobject("ModelTemplate","KBaseTemplateModels","GramNegModelTemplate");
	my $rolerxns = $template->simple_role_reaction_hash();
	#Building genome comparison object
	my $famkeys = [keys(%{$orthos})];
	my $famind = {};
	for (my $i=0; $i < @{$famkeys}; $i++) {
		$famind->{$famkeys->[$i]} = $i;
	}
	my $funcind = {};
	my $funccount = 0;
	my $functions;
	my $totgenomes = @{$genome_ids};
	my $genomehash;
	my $families = {};
	for (my $i=0; $i < @{$genome_ids}; $i++) {
		my $g = $self->_get_msobject("Genome",$genome_wwss->[$i],$genome_ids->[$i]);
		print $g->_reference()."\t".$i."\n";
		my $ftrs = $g->features();
		my $genfam = {};
		my $genfun = {};
		for (my $j=0; $j < @{$ftrs}; $j++) {
			my $ftr = $ftrs->[$j];
			my $fam = $members->{$g->_reference()}->{$ftr->id()};
			my $score = $orthos->{$fam}->{$g->_reference()}->{$ftr->id()};
			my $roles = $ftr->roles();
			my $funind = [];
			for (my $k=0; $k < @{$roles}; $k++) {
				if (!defined($functions->{$roles->[$k]})) {
					$functions->{$roles->[$k]} = {
						core => 0,
						genome_features => {},
						id => $roles->[$k],
						reactions => [],
						subsystem => "none",
						primclass => "none",
						subclass => "none",
						number_genomes => 0,
						fraction_genomes => 0,
						fraction_consistent_families => 0,
						most_consistent_family => "none",
					};
					$funcind->{$roles->[$k]} = $funccount;
					$funccount++;
					if (defined($SubsysRoles->{$roles->[$k]})) {
						$functions->{$roles->[$k]}->{subsystem} = $SubsysRoles->{$roles->[$k]}->name();
						$functions->{$roles->[$k]}->{primclass} = $SubsysRoles->{$roles->[$k]}->class();
						$functions->{$roles->[$k]}->{subclass} = $SubsysRoles->{$roles->[$k]}->subclass();
					}
					if (defined($rolerxns->{$roles->[$k]})) {
						foreach my $rxn (keys(%{$rolerxns->{$roles->[$k]}})) {
							foreach my $comp (keys(%{$rolerxns->{$roles->[$k]}->{$rxn}})) {
								push(@{$functions->{$roles->[$k]}->{reactions}},[$rxn."_".$comp,$rolerxns->{$roles->[$k]}->{$rxn}->{$comp}->[1]]);
							}
						}
					}
				}
				push(@{$funind},$funcind->{$roles->[$k]});
				push(@{$functions->{$roles->[$k]}->{genome_features}->{$g->_reference()}},[$ftr->id(),$famind->{$fam},$score]);
				$genfun->{$roles->[$k]} = 1;
			}
			if (!defined($families->{$fam})) {
				$families->{$fam} = {
					core => 0,
					genome_features => {},
					id => $fam,
					type => $ftr->type(),
					protein_translation => "none",
					number_genomes => 0,
					fraction_genomes => 0,
					fraction_consistent_annotations => 0,
					most_consistent_role => "none",
				};
			}
			$genfam->{$fam} = 1;
			push(@{$families->{$fam}->{genome_features}->{$g->_reference()}},[$ftr->id(),$funind,$score]);
		}
		my $taxonomy = "Unknown";
		if (defined($g->taxonomy())) {
			$taxonomy = $g->taxonomy();
		}
		my $numftrs = @{$ftrs};
		my $numfams = keys(%{$genfam});
		my $numfuns = keys(%{$genfun});
		$genomehash->{$g->_reference()} = {
			id => $g->_wsworkspace()."/".$g->_wsname(),
			name => $g->scientific_name(),
			taxonomy => $taxonomy,
			genome_ref => $g->_reference(),
			genome_similarity => {},
			features => $numftrs,
			families => $numfams+0,
			functions => $numfuns+0,
		};
		$gc->{genomes}->[$i] = $genomehash->{$g->_reference()};
	}
	foreach my $function (keys(%{$funcind})) {
		foreach my $genone (keys(%{$functions->{$function}->{genome_features}})) {
			foreach my $gentwo (keys(%{$functions->{$function}->{genome_features}})) {
				if ($genone ne $gentwo) {
					$genomehash->{$genone}->{genome_similarity}->{$gentwo}->[1]++;
				}
			}
		}
		$functions->{$function}->{number_genomes} = keys(%{$functions->{$function}->{genome_features}});
		$functions->{$function}->{fraction_genomes} = $functions->{$function}->{number_genomes}/$totgenomes;
		if ($functions->{$function}->{fraction_genomes} == 1) {
			$functions->{$function}->{core} = 1;
			$gc->{core_functions}++;
		}
		$gc->{functions}->[$funcind->{$function}] = $functions->{$function};
	}
	foreach my $fam (keys(%{$famind})) {
		foreach my $genone (keys(%{$families->{$fam}->{genome_features}})) {
			foreach my $gentwo (keys(%{$families->{$fam}->{genome_features}})) {
				if ($genone ne $gentwo) {
					$genomehash->{$genone}->{genome_similarity}->{$gentwo}->[0]++;
				}
			}
		}
		$families->{$fam}->{number_genomes} = keys(%{$families->{$fam}->{genome_features}});
		$families->{$fam}->{fraction_genomes} = $families->{$fam}->{number_genomes}/$totgenomes;
		if ($families->{$fam}->{fraction_genomes} == 1) {
			$families->{$fam}->{core} = 1;
			$gc->{core_families}++;
		}
		$gc->{families}->[$famind->{$fam}] = $families->{$fam};
	}
	$gc = Bio::KBase::ObjectAPI::KBaseGenomes::GenomeComparison->new($gc);
	$output = $self->_save_msobject($gc,"GenomeComparison",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END compare_genomes
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to compare_genomes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'compare_genomes');
    }
    return($output);
}




=head2 import_metagenome_annotation

  $output = $obj->import_metagenome_annotation($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an import_metagenome_annotation_params
$output is an object_metadata
import_metagenome_annotation_params is a reference to a hash where the following keys are defined:
	metaanno_uid has a value which is a string
	workspace has a value which is a workspace_id
	source_id has a value which is a string
	source has a value which is a string
	type has a value which is a string
	confidence_type has a value which is a string
	name has a value which is a string
	annotations has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: (genes) a reference to a list where each element is a string
	1: (functional_role) a string
	2: (otu) a string
	3: (abundance) an int
	4: (confidence) a float

	auth has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an import_metagenome_annotation_params
$output is an object_metadata
import_metagenome_annotation_params is a reference to a hash where the following keys are defined:
	metaanno_uid has a value which is a string
	workspace has a value which is a workspace_id
	source_id has a value which is a string
	source has a value which is a string
	type has a value which is a string
	confidence_type has a value which is a string
	name has a value which is a string
	annotations has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: (genes) a reference to a list where each element is a string
	1: (functional_role) a string
	2: (otu) a string
	3: (abundance) an int
	4: (confidence) a float

	auth has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Imports metagenome annotation data into a metagenome annotation object

=back

=cut

sub import_metagenome_annotation
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_metagenome_annotation:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_metagenome_annotation');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN import_metagenome_annotation
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["workspace"],{
		annotations => undef,
		metaprofile_id => undef,
		metaprofile_ws => $params->{workspace},
		metaanno_uid => undef,
		source_id => undef,
		source => "KBase",
		type => "unknown",
		name => undef,
		confidence_type => "blast"
	});
	#Obtaining kbase ID
	if (defined($params->{metaprofile_id})) {
		my $input = {};
		if ($params->{metaprofile_ws} =~ m/^\d+$/) {
			$input->{wsid} = $params->{metaprofile_ws};
		} else {
			$input->{workspace} = $params->{metaprofile_ws};
		}
		if ($params->{metaprofile_id} =~ m/^\d+$/) {
			$input->{objid} = $params->{metaprofile_id};
		} else {
			$input->{name} = $params->{metaprofile_id};
		}
		my $objs = $self->_KBaseStore()->workspace()->get_objects([$input]);
		my $lines = [split(/\n/,$objs->[0]->{data}->{data})];
		for (my $i=0; $i < @{$lines}; $i++) {
			push(@{$params->{annotations}},[split(/\t/,$lines->[$i])]);
		}
		
	}
	if (!defined($params->{annotations})) {
		$self->_error("Must have annotations to import!");
	}
	my $kbid = $self->_get_new_id("kb|mganno");
	if (!defined($params->{source_id}) || $params->{source} eq "KBase") {
		$params->{source_id} = $kbid;
	}
	if (!defined($params->{metaanno_uid})) {
		$params->{metaanno_uid} = $kbid;
	}
	if (!defined($params->{name})) {
		$params->{name} = $params->{metaanno_uid};
	}
	#Creating object
	my $mgobj = Bio::KBase::ObjectAPI::KBaseGenomes::MetagenomeAnnotation->new({
		id => $kbid,
		source_id => $params->{source_id},
		source => $params->{source},
		type => $params->{type},
		name => $params->{name},
		confidence_type => $params->{confidence_type},
		otus => []
	});
	#Organizing annotations by OTU
	my $otus = {};
	my $otuAverages = {};
	for (my $i=0; $i < @{$params->{annotations}}; $i++) {
		if (!defined($otuAverages->{$params->{annotations}->[$i]->[4]})) {
			$otuAverages->{$params->{annotations}->[$i]->[4]}->{coverage} = 0;
			$otuAverages->{$params->{annotations}->[$i]->[4]}->{confidence} = 0;
		}
		$otuAverages->{$params->{annotations}->[$i]->[4]}->{coverage} += $params->{annotations}->[$i]->[2];
		$otuAverages->{$params->{annotations}->[$i]->[4]}->{confidence} += $params->{annotations}->[$i]->[3];
		push(@{$otus->{$params->{annotations}->[$i]->[4]}},{
			reference_genes => [split(/,/,$params->{annotations}->[$i]->[0])],
			functional_role => $params->{annotations}->[$i]->[1],
			abundance => $params->{annotations}->[$i]->[2]+0,
			confidence => $params->{annotations}->[$i]->[3]+0,
		}); 
	}
	my $counter = 0;
	foreach my $otu (keys(%{$otus})) {
		$counter++;
		my $numfunc = @{$otus->{$otu}};
		my $otuobj = {
			ave_confidence => $otuAverages->{$otu}->{confidence}/$numfunc,
			ave_coverage => $otuAverages->{$otu}->{coverage}/$numfunc,
			id => $kbid.".otu.".$counter,
			name => $otu,
			source_id => $otu,
			source => $params->{source},
			functions => [@{$otus->{$otu}}]
		};
		my $fcounter = 0;
		for (my $i=0; $i < @{$otuobj->{functions}}; $i++) {
			$fcounter++;
			$otuobj->{functions}->[$i]->{id} = $kbid.".otu.".$counter.".func.".$fcounter;
		}
		$mgobj->add("otus",$otuobj);
	}
	#Saving object
	$mgobj->parent($self->_KBaseStore());
	$output = $self->_save_msobject($mgobj,"MetagenomeAnnotation",$params->{workspace},$params->{metaanno_uid});
    $self->_clearContext();
    #END import_metagenome_annotation
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_metagenome_annotation:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_metagenome_annotation');
    }
    return($output);
}




=head2 models_to_community_model

  $output = $obj->models_to_community_model($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an import_metagenome_annotation_params
$output is an object_metadata
import_metagenome_annotation_params is a reference to a hash where the following keys are defined:
	metaanno_uid has a value which is a string
	workspace has a value which is a workspace_id
	source_id has a value which is a string
	source has a value which is a string
	type has a value which is a string
	confidence_type has a value which is a string
	name has a value which is a string
	annotations has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: (genes) a reference to a list where each element is a string
	1: (functional_role) a string
	2: (otu) a string
	3: (abundance) an int
	4: (confidence) a float

	auth has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an import_metagenome_annotation_params
$output is an object_metadata
import_metagenome_annotation_params is a reference to a hash where the following keys are defined:
	metaanno_uid has a value which is a string
	workspace has a value which is a workspace_id
	source_id has a value which is a string
	source has a value which is a string
	type has a value which is a string
	confidence_type has a value which is a string
	name has a value which is a string
	annotations has a value which is a reference to a list where each element is a reference to a list containing 5 items:
	0: (genes) a reference to a list where each element is a string
	1: (functional_role) a string
	2: (otu) a string
	3: (abundance) an int
	4: (confidence) a float

	auth has a value which is a string
workspace_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Combines multiple single genome models into a single community model

=back

=cut

sub models_to_community_model
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to models_to_community_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'models_to_community_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN models_to_community_model
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["models","workspace"],{
		model_uid => undef,
		name => undef
	});
	my $kbid = $self->_get_new_id("kb|fbamdl");
	if (!defined($params->{model_uid})) {
		$params->{model_uid} = $kbid;
	}
	if (!defined($params->{name})) {
		$params->{name} = $params->{model_uid};
	}
	#Pulling first model to obtain biochemistry ID
	my $model = $self->_get_msobject("FBAModel",$params->{models}->[0]->[1],$params->{models}->[0]->[0]);
	my $gid = $self->_get_new_id("kb|g.");
	my $genomeObj = Bio::KBase::ObjectAPI::KBaseGenomes::Genome->new({
		id => $gid,
		scientific_name => $params->{name}."Genome",
		domain => "Community",
		genetic_code => 11,
		dna_size => 0,
		num_contigs => 0,
		contig_lengths => [],
		contig_ids => [],
		source => "KBase",
		source_id => $gid,
		md5 => "",
		taxonomy => "Community",
		gc_content => 0,
		complete => 0,
		publications => [],
		features => [],
    });
    $genomeObj->parent($self->_KBaseStore());
	#Creating new community model
	my $commdl = Bio::KBase::ObjectAPI::KBaseFBA::FBAModel->new({
		source_id => $kbid,
		source => "KBase",
		id => $kbid,
		type => "CommunityModel",
		name => $params->{name},
		template_ref => $model->template_ref(),
		modelreactions => [],
		modelcompounds => [],
		modelcompartments => [],
		biomasses => [],
		gapgens => [],
		gapfillings => [],
	});
	$commdl->parent($self->_KBaseStore());
	my $cmpsHash = {
		e => $commdl->addCompartmentToModel({
			compartment => $model->template()->biochemistry()->getObject("compartments","e"),
			pH => 7,
			potential => 0,
			compartmentIndex => 0
		}),
		c => $commdl->addCompartmentToModel({
			compartment => $model->template()->biochemistry()->getObject("compartments","c"),
			pH => 7,
			potential => 0,
			compartmentIndex => 0
		})
	};
	my $totalAbundance = 0;
	for (my $i=0; $i < @{$params->{models}}; $i++) {
		$totalAbundance += $params->{models}->[$i]->[2];
	}
	my $biocount = 1;
	my $primbio = $commdl->add("biomasses",{
		id => "bio1",
		name => "bio1",
		other => 1,
		dna => 0,
		rna => 0,
		protein => 0,
		cellwall => 0,
		lipid => 0,
		cofactor => 0,
		energy => 0
	});
	my $biomassCompound = $model->template()->biochemistry()->getObject("compounds","cpd11416");
	my $biocpd = $commdl->add("modelcompounds",{
		id => $biomassCompound->id()."_".$cmpsHash->{c}->id(),
		compound_ref => $biomassCompound->_reference(),
		charge => 0,
		modelcompartment_ref => "~/modelcompartments/id/".$cmpsHash->{c}->id()
	});
	$primbio->add("biomasscompounds",{
		modelcompound_ref => "~/modelcompounds/id/".$biocpd->id(),
		coefficient => 1
	});
	for (my $i=0; $i < @{$params->{models}}; $i++) {
		print "Loading model ".$params->{models}->[$i]->[0]."\n";
		if ($i > 0) {
			$model = $self->_get_msobject("FBAModel",$params->{models}->[$i]->[1],$params->{models}->[$i]->[0]);
		}
		my $biomassCpd = $model->getObject("modelcompounds","cpd11416_c0");
		#Adding genome, features, and roles to master mapping and annotation
		my $mdlgenome = $model->genome();
		$genomeObj->dna_size($genomeObj->dna_size()+$mdlgenome->dna_size());
		$genomeObj->num_contigs($genomeObj->num_contigs()+$mdlgenome->num_contigs());
		$genomeObj->gc_content($genomeObj->gc_content()+$mdlgenome->dna_size()*$mdlgenome->gc_content());
		push(@{$genomeObj->{contig_lengths}},@{$mdlgenome->{contig_lengths}});
		push(@{$genomeObj->{contig_ids}},@{$mdlgenome->{contig_ids}});	
		print "Loading features\n";
		for (my $j=0; $j < @{$mdlgenome->features()}; $j++) {
			$genomeObj->add("features",$mdlgenome->features()->[$j]);
		}
		#Adding compartments to community model
		my $cmps = $model->modelcompartments();
		print "Loading compartments\n";
		for (my $j=0; $j < @{$cmps}; $j++) {
			if ($cmps->[$j]->compartment()->id() ne "e") {
				$cmpsHash->{$cmps->[$j]->compartment()->id()} = $commdl->addCompartmentToModel({
					compartment => $cmps->[$j]->compartment(),
					pH => 7,
					potential => 0,
					compartmentIndex => ($i+1)
				});
			}
		}
		#Adding compounds to community model
		my $translation = {};
		print "Loading compounds\n";
		my $cpds = $model->modelcompounds();
		for (my $j=0; $j < @{$cpds}; $j++) {
			my $cpd = $cpds->[$j];
			my $rootid = $cpd->compound()->id();
			if ($cpd->id() =~ m/(.+)_([a-zA-Z]\d+)/) {
				$rootid = $1;
			}
			my $comcpd = $commdl->getObject("modelcompounds",$rootid."_".$cmpsHash->{$cpd->modelcompartment()->compartment()->id()}->id());
			if (!defined($comcpd)) {
				$comcpd = $commdl->add("modelcompounds",{
					id => $rootid."_".$cmpsHash->{$cpd->modelcompartment()->compartment()->id()}->id(),
					compound_ref => $cpd->compound_ref(),
					charge => $cpd->charge(),
					formula => $cpd->formula(),
					modelcompartment_ref => "~/modelcompartments/id/".$cmpsHash->{$cpd->modelcompartment()->compartment()->id()}->id(),
				});
			}
			$translation->{$cpd->id()} = $comcpd->id();
		}
		print "Loading reactions\n";
		#Adding reactions to community model
		my $rxns = $model->modelreactions();
		for (my $j=0; $j < @{$rxns}; $j++) {
			my $rxn = $rxns->[$j];
			my $rootid = $rxn->reaction()->id();
			if ($rxn->id() =~ m/(.+)_([a-zA-Z]\d+)/) {
				$rootid = $1;
			}
			if (!defined($commdl->getObject("modelreactions",$rootid."_".$cmpsHash->{$rxn->modelcompartment()->compartment()->id()}->id()))) {
				my $comrxn = $commdl->add("modelreactions",{
					id => $rootid."_".$cmpsHash->{$rxn->modelcompartment()->compartment()->id()}->id(),
					reaction_ref => $rxn->reaction_ref(),
					direction => $rxn->direction(),
					protons => $rxn->protons(),
					modelcompartment_ref => "~/modelcompartments/id/".$cmpsHash->{$rxn->modelcompartment()->compartment()->id()}->id(),
					probability => $rxn->probability()
				});
				for (my $k=0; $k < @{$rxn->modelReactionProteins()}; $k++) {
					$comrxn->add("modelReactionProteins",$rxn->modelReactionProteins()->[$k]);
				}
				for (my $k=0; $k < @{$rxn->modelReactionReagents()}; $k++) {
					$comrxn->add("modelReactionReagents",{
						modelcompound_ref => "~/modelcompounds/id/".$translation->{$rxn->modelReactionReagents()->[$k]->modelcompound()->id()},
						coefficient => $rxn->modelReactionReagents()->[$k]->coefficient()
					});
				}
			}
		}
		print "Loading biomass\n";
		#Adding biomass to community model
		my $bios = $model->biomasses();
		for (my $j=0; $j < @{$bios}; $j++) {
			my $bio = $bios->[$j]->cloneObject();
			$bio->parent($commdl);
			for (my $k=0; $k < @{$bio->biomasscompounds()}; $k++) {
				$bio->biomasscompounds()->[$k]->modelcompound_ref("~/modelcompounds/id/".$translation->{$bios->[$j]->biomasscompounds()->[$k]->modelcompound()->id()});
			}
			$bio = $commdl->add("biomasses",$bio);
			$biocount++;
			$bio->id("bio".$biocount);
			$bio->name("bio".$biocount);
		}
		print "Loading primary biomass\n";
		#Adding biomass component to primary composite biomass reaction
		$primbio->add("biomasscompounds",{
			modelcompound_ref => "~/modelcompounds/id/".$translation->{$biomassCpd->id()},
			coefficient => -1*$params->{models}->[$i]->[2]/$totalAbundance
		});
	}
	print "Merged model complete!\n";
	#Saving object
	$output = $self->_save_msobject($genomeObj,"Genome",$params->{workspace},$genomeObj->id());
	$commdl->genome_ref($genomeObj->_reference());
	$output = $self->_save_msobject($commdl,"FBAModel",$params->{workspace},$params->{model_uid});
    $self->_clearContext();
    #END models_to_community_model
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to models_to_community_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'models_to_community_model');
    }
    return($output);
}




=head2 metagenome_to_fbamodels

  $outputs = $obj->metagenome_to_fbamodels($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a metagenome_to_fbamodels_params
$outputs is a reference to a list where each element is an object_metadata
metagenome_to_fbamodels_params is a reference to a hash where the following keys are defined:
	model_uids has a value which is a reference to a hash where the key is a string and the value is a string
	workspace has a value which is a workspace_id
	metaanno_uid has a value which is a string
	metaanno_ws has a value which is a workspace_id
	min_abundance has a value which is a float
	confidence_threshold has a value which is a float
	max_otu_models has a value which is an int
	min_reactions has a value which is an int
	templates has a value which is a reference to a hash where the key is a string and the value is a reference to a list containing 2 items:
	0: (template_ws) a workspace_id
	1: (template_uid) a template_id

	auth has a value which is a string
workspace_id is a string
template_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a metagenome_to_fbamodels_params
$outputs is a reference to a list where each element is an object_metadata
metagenome_to_fbamodels_params is a reference to a hash where the following keys are defined:
	model_uids has a value which is a reference to a hash where the key is a string and the value is a string
	workspace has a value which is a workspace_id
	metaanno_uid has a value which is a string
	metaanno_ws has a value which is a workspace_id
	min_abundance has a value which is a float
	confidence_threshold has a value which is a float
	max_otu_models has a value which is an int
	min_reactions has a value which is an int
	templates has a value which is a reference to a hash where the key is a string and the value is a reference to a list containing 2 items:
	0: (template_ws) a workspace_id
	1: (template_uid) a template_id

	auth has a value which is a string
workspace_id is a string
template_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Constructs models from metagenome annotation OTUs

=back

=cut

sub metagenome_to_fbamodels
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to metagenome_to_fbamodels:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'metagenome_to_fbamodels');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($outputs);
    #BEGIN metagenome_to_fbamodels
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["metaanno_uid","workspace"],{
		model_uids => {},
		metaanno_ws => $params->{workspace},
		min_abundance => 1,
		confidence_threshold => 0,
		max_otu_models => 2,
		min_reactions => 100,
		templates => {}
	});
	my $metaanno = $self->_get_msobject("MetagenomeAnnotation",$params->{metaanno_ws},$params->{metaanno_uid});
	#Sorting OTUs by coverage, placing highest coverage OTU first
	my $otus = $metaanno->otus();
	my $sortedOtus = [sort { $b->ave_coverage() <=> $a->ave_coverage() } @{$otus}];
	my $functions;
	my $nummodels = 0;
	for (my $i=0; $i < @{$sortedOtus}; $i++) {
		my $otu = $sortedOtus->[$i];
		my $built = 0;
		#Building OTU model if appropriate
		if ($otu->name() ne "tail" && $nummodels < $params->{max_otu_models} && $otu->ave_coverage() >= $params->{min_abundance}) {
			my $mdlfunc = {};
			my $functions = $otu->functions();
			for (my $j=0; $j < @{$functions}; $j++) {
				my $func = $functions->[$j];
				if ($self->_assess_confidence($metaanno->confidence_type(),$params->{confidence_threshold},$func->confidence()) == 1) {
					if (!defined($mdlfunc->{$func->functional_role()})) {
						$mdlfunc->{$func->functional_role()} = 0;
					}
					$mdlfunc->{$func->functional_role()} += $func->abundance();
				}
			}
			my $genome = $self->_buildGenomeFromFunctions($otu->id().".g.0",$mdlfunc,$otu->name());
			my $genomeMeta = $self->_save_msobject($genome,"Genome",$params->{workspace},$genome->id(),{hidden=>1});
			my $mdl = $self->_genome_to_model($genome,$genome->id().".fbamdl.0");
			print $otu->name()."\t".$otu->ave_coverage()."\t".@{$otu->functions()}."\t".@{$mdl->modelreactions()}."\n";
			#Saving OTU model if it's large enough
			if (@{$mdl->modelreactions()} > $params->{min_reactions}) {
				$nummodels++;
				$built = 1;
				my $ids = ["name","kbid","source_id"];
				my $modelid;
				for (my $j=0; $j < @{$ids}; $j++) {
					if (defined($params->{model_uids}->{$otu->{$ids->[$j]}})) {
						$modelid = $params->{model_uids}->{$otu->{$ids->[$j]}};
					}
				}
				if (!defined($modelid)) {
					$modelid = $mdl->id();
				}
				$mdl->name($otu->name());
				$mdl->source("KBase");
				$mdl->source_id($mdl->id());
				$mdl->metagenome_ref($metaanno->_reference());
				$mdl->metagenome_otu_ref($otu->_reference());
				push(@{$outputs},$self->_save_msobject($mdl,"FBAModel",$params->{workspace},$modelid));
			}
		}
		#Adding OTU functions to functions in tail
		if ($built == 0) {
			my $funcs = $otu->functions();
			for (my $j=0; $j < @{$otu->functions()}; $j++) {
				my $func = $funcs->[$j];
				if ($self->_assess_confidence($metaanno->confidence_type(),$params->{confidence_threshold},$func->confidence()) == 1) {
					if (!defined($functions->{$func->functional_role()})) {
						$functions->{$func->functional_role()} = {
							abundance => 0,
							confidence => 0,
							reference_genes => []
						};
					}
					$functions->{$func->functional_role()}->{abundance} += $func->abundance();
					$functions->{$func->functional_role()}->{confidence} += $func->abundance()*$func->confidence();
					push(@{$functions->{$func->{functional_role}}->{reference_genes}},@{$func->reference_genes()});
				}
			}
		}
	}
	#Building ensemble model
	my $mdlfunc = {};
	foreach my $function (keys(%{$functions})) {
		if ($self->_assess_confidence($metaanno->confidence_type(),$params->{confidence_threshold},$functions->{$function}->{confidence}) == 1) {
			if (!defined($mdlfunc->{$function})) {
				$mdlfunc->{$function} = 0;
			}
			$mdlfunc->{$function} += $functions->{$function}->{abundance};
		}
	}
	my $genome = $self->_buildGenomeFromFunctions($metaanno->id().".tail.0.g.0",$mdlfunc,$metaanno->id().".tail.0.g.0");
	my $genomeMeta = $self->_save_msobject($genome,"Genome",$params->{workspace},$genome->id(),{hidden=>1});
	my $mdl = $self->_genome_to_model($genome,$genome->id().".fbamdl.0");
	my $modelid;
	if (defined($params->{model_uids}->{tail})) {
		$modelid = $params->{model_uids}->{tail};
	}
	if (!defined($modelid)) {
		$modelid = $mdl->id();
	}
	$mdl->name("tailmodel");
	$mdl->source("KBase");
	$mdl->source_id($mdl->id());
	push(@{$outputs},$self->_save_msobject($mdl,"FBAModel",$params->{workspace},$modelid));
	$self->_clearContext();
    #END metagenome_to_fbamodels
    my @_bad_returns;
    (ref($outputs) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"outputs\" (value was \"$outputs\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to metagenome_to_fbamodels:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'metagenome_to_fbamodels');
    }
    return($outputs);
}




=head2 import_expression

  $expression_meta = $obj->import_expression($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an import_expression_params
$expression_meta is an object_metadata
import_expression_params is a reference to a hash where the following keys are defined:
	expression_data_sample_series has a value which is a reference to a hash where the key is a sample_id and the value is an ExpressionDataSample
	series has a value which is a series_id
	source_id has a value which is a string
	source_date has a value which is a string
	description has a value which is a string
	processing_comments has a value which is a string
	workspace has a value which is a workspace_id
	genome_id has a value which is a genome_id
	numerical_interpretation has a value which is a string
sample_id is a string
ExpressionDataSample is a reference to a hash where the following keys are defined:
	sample_id has a value which is a string
	data_expression_levels_for_sample has a value which is a reference to a hash where the key is a feature_id and the value is a measurement
feature_id is a string
measurement is a float
series_id is a string
workspace_id is a string
genome_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an import_expression_params
$expression_meta is an object_metadata
import_expression_params is a reference to a hash where the following keys are defined:
	expression_data_sample_series has a value which is a reference to a hash where the key is a sample_id and the value is an ExpressionDataSample
	series has a value which is a series_id
	source_id has a value which is a string
	source_date has a value which is a string
	description has a value which is a string
	processing_comments has a value which is a string
	workspace has a value which is a workspace_id
	genome_id has a value which is a genome_id
	numerical_interpretation has a value which is a string
sample_id is a string
ExpressionDataSample is a reference to a hash where the following keys are defined:
	sample_id has a value which is a string
	data_expression_levels_for_sample has a value which is a reference to a hash where the key is a feature_id and the value is a measurement
feature_id is a string
measurement is a float
series_id is a string
workspace_id is a string
genome_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description

Import gene expression.

=back

=cut

sub import_expression
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_expression:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_expression');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($expression_meta);
    #BEGIN import_expression
    $self->_setContext($ctx,$input);    
    $input = $self->_validateargs($input,["expression_data_sample_series","series","workspace","source_date"],
				  {source_id => $input->{"series"},
				   numerical_interpretation => "Log2 level intensities",});

    my $genome_id;
    if (exists $input->{"genome_id"}) {
	$genome_id = $input->{"genome_id"};
    } else {
	my $feature_id = (keys $input->{"expression_data_sample_series"}->{(keys $input->{"expression_data_sample_series"})[0]}->{"data_expression_levels_for_sample"})[0];
	if ( $feature_id =~ /^(kb\|g\.\d+)/) {
	    $genome_id = $1;
	} else {
	    die("Unexpected feature ID format $feature_id\n");
	}
    }
    my $old_series = {
	id => $input->{"series"},
	source_id => $input->{"source_id"},
	genome_expression_sample_ids_map => {},
	external_source_date => $input->{"source_date"},
    };

    my $ws = $self->_KBaseStore()->workspace();
    while (my ($series_id, $sample) = each %{$input->{"expression_data_sample_series"}}) {
	my $old_sample = {
	    id => $sample->{"sample_id"},
	    type => "microarray",
	    expression_levels => $sample->{"data_expression_levels_for_sample"},
	    source_id => $input->{"source_id"}, # What source?
	    genome_id => $genome_id,
	    external_source_date => $input->{"source_date"}, # Which data?
	    numerical_interpretation => $input->{"numerical_interpretation"},
	    processing_comments => $input->{"processing_comments"},
	    description => $input->{"description"}
	};
	
	my $workspace_save_obj_params = {
	    id => $sample->{"sample_id"},
	    type => "KBaseExpression.ExpressionSample", # ExpressionDataSample",
	    data => $old_sample, 
	    workspace => $input->{"workspace"},
	    auth => $self->_authentication(),
	    json => 0,
	    compressed => 0,
	    retrieveFromURL => 0,
	};
	my $result = $ws->save_object($workspace_save_obj_params);
	my $sample_ref = $input->{"workspace"}."/".$sample->{"sample_id"}."/".$result->[3];
	print STDERR "sample ref: $sample_ref\n";
	push(@{$old_series->{"genome_expression_sample_ids_map"}->{$old_sample->{"genome_id"}}}, $sample_ref);
    }
    #end debug

    my $workspace_save_obj_params = {
	id => $old_series->{"id"},
	type => "KBaseExpression.ExpressionSeries", 
	data => $old_series, 
	workspace => $input->{"workspace"},
	auth => $self->_authentication(),
	json => 0,
	compressed => 0,
	retrieveFromURL => 0,
    };

    my $expression_meta = $ws->save_object($workspace_save_obj_params);
    #END import_expression
    my @_bad_returns;
    (ref($expression_meta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"expression_meta\" (value was \"$expression_meta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_expression:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_expression');
    }
    return($expression_meta);
}




=head2 import_regulome

  $regulome_meta = $obj->import_regulome($input)

=over 4

=item Parameter and return types

=begin html

<pre>
$input is an import_regulome_params
$regulome_meta is an object_metadata
import_regulome_params is a reference to a hash where the following keys are defined:
	regulons has a value which is a reference to a list where each element is a regulon
	workspace has a value which is a workspace_id
	genome_workspace has a value which is a workspace_id
	genome_id has a value which is a genome_id
regulon is a reference to a hash where the following keys are defined:
	operons has a value which is a reference to a list where each element is an operon
	transcription_factor has a value which is a locus
	effectors has a value which is a reference to a list where each element is an effector
	sign has a value which is a string
operon is a reference to a list where each element is a locus
locus is a reference to a hash where the following keys are defined:
	name has a value which is a string
	locus has a value which is a string
effector is a reference to a hash where the following keys are defined:
	name has a value which is a string
	class has a value which is a string
workspace_id is a string
genome_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string

</pre>

=end html

=begin text

$input is an import_regulome_params
$regulome_meta is an object_metadata
import_regulome_params is a reference to a hash where the following keys are defined:
	regulons has a value which is a reference to a list where each element is a regulon
	workspace has a value which is a workspace_id
	genome_workspace has a value which is a workspace_id
	genome_id has a value which is a genome_id
regulon is a reference to a hash where the following keys are defined:
	operons has a value which is a reference to a list where each element is an operon
	transcription_factor has a value which is a locus
	effectors has a value which is a reference to a list where each element is an effector
	sign has a value which is a string
operon is a reference to a list where each element is a locus
locus is a reference to a hash where the following keys are defined:
	name has a value which is a string
	locus has a value which is a string
effector is a reference to a hash where the following keys are defined:
	name has a value which is a string
	class has a value which is a string
workspace_id is a string
genome_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub import_regulome
{
    my $self = shift;
    my($input) = @_;

    my @_bad_arguments;
    (ref($input) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"input\" (value was \"$input\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_regulome:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_regulome');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($regulome_meta);
    #BEGIN import_regulome
    $self->_setContext($ctx,$input);    
    $input = $self->_validateargs($input,["regulons","workspace"],{genome_workspace => $input->{workspace}});
    my $genome_id = $input->{"genome_id"};
    my $genome = $self->_get_msobject("Genome",$input->{"genome_workspace"},$genome_id);
    my $ws = $self->_KBaseStore()->workspace();

    my $genomeObj = Bio::KBase::ObjectAPI::KBaseRegulation::RGenome->new({ "genome_name" => "", "genome_id" => $genome_id, "genome_ref" => $genome->_reference() });
    $genomeObj->parent($self->_KBaseStore());
    my $regulome_id = (defined $input->{"regulome"}) ? $input->{"regulome"} : "kb|regulome.".$self->_idServer()->allocate_id_range("kb|regulome",1);
    my $regulome = Bio::KBase::ObjectAPI::KBaseRegulation::Regulome->new({
	regulome_id => $regulome_id,
	regulome_source => "",
	regulome_name => ""
    });

    $regulome->add("genome",$genomeObj);

    foreach my $regulon (@{$input->{"regulons"}}) {
	my $regulonObj = Bio::KBase::ObjectAPI::KBaseRegulation::Regulon->new({"regulon_id"=>""});
	$regulonObj->parent($self->_KBaseStore());
	my $tf_locus = $regulon->{"transcription_factor"}->{"locus"};
	my $tf_name = $regulon->{"transcription_factor"}->{"name"};
	my $tfObj = Bio::KBase::ObjectAPI::KBaseRegulation::TranscriptionFactor->new({ "transcription_factor_id" => "", "locus_tag" => $tf_locus, "name" => $tf_name });
	$tfObj->parent($self->_KBaseStore());
	$regulonObj->add("tfs", $tfObj);
	foreach my $operon (@{$regulon->{"operons"}}) {
	    my $regulatedOperonObj = Bio::KBase::ObjectAPI::KBaseRegulation::RegulatedOperon->new({ operon_id => "", sites => [] });
	    $regulatedOperonObj->parent($self->_KBaseStore());
	    foreach my $gene (@$operon) {
		my $geneObj = Bio::KBase::ObjectAPI::KBaseRegulation::Gene->new({ gene_id => "", locus_tag => $gene->{"locus"}, name => $gene->{"name"} });
		$geneObj->parent($self->_KBaseStore());
		$regulatedOperonObj->add("genes",$geneObj);
	    }

	    # dummy site to hold mechanism
	    my $regsiteObj = Bio::KBase::ObjectAPI::KBaseRegulation::RegulatorySite->new({"regulatory_site_id" => "", "sequence" => "",  parent => $self->_KBaseStore(), regulatory_mechanism => $regulon->{"sign"}});
	    $regulatedOperonObj->add("sites",$regsiteObj);

	    $regulonObj->add("operons",$regulatedOperonObj);
	}
	foreach my $effector (@{$regulon->{"effectors"}}) {
	    my $effectorObj = Bio::KBase::ObjectAPI::KBaseRegulation::Effector->new({ "effector_id" => "", "effector_name" => $effector->{"name"}, "effector_class" => $effector->{"class"}, "parent" => $self->_KBaseStore() });
	    $regulonObj->add("effectors", $effectorObj);	    
	}

	$regulome->add("regulons",$regulonObj);
    }

    #Saving regulome in database
    $regulome->parent($self->_KBaseStore());
    $regulome_meta = $self->_save_msobject($regulome,"Regulome",$input->{workspace},$regulome_id);
    $self->_clearContext();

    #END import_regulome
    my @_bad_returns;
    (ref($regulome_meta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"regulome_meta\" (value was \"$regulome_meta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_regulome:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_regulome');
    }
    return($regulome_meta);
}




=head2 create_promconstraint

  $promconstraint_meta = $obj->create_promconstraint($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a CreatePromConstraintParameters
$promconstraint_meta is an object_metadata
CreatePromConstraintParameters is a reference to a hash where the following keys are defined:
	genome_id has a value which is a genome_id
	series_id has a value which is a series_id
	regulome_id has a value which is a regulome_id
	promconstraint_id has a value which is a promconstraint_id
genome_id is a string
series_id is a string
regulome_id is a string
promconstraint_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a CreatePromConstraintParameters
$promconstraint_meta is an object_metadata
CreatePromConstraintParameters is a reference to a hash where the following keys are defined:
	genome_id has a value which is a genome_id
	series_id has a value which is a series_id
	regulome_id has a value which is a regulome_id
	promconstraint_id has a value which is a promconstraint_id
genome_id is a string
series_id is a string
regulome_id is a string
promconstraint_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

This method creates a set of Prom constraints for a given genome annotation based on a regulatory network
and a collection of gene expression data stored on a workspace.  Parameters are specified in the
CreatePromconstraintParameters object.  
The ID of the new Prom constraints object is returned. The Prom constraints can then be used in conjunction
with an FBA model using FBA Model Services.

=back

=cut

sub create_promconstraint
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to create_promconstraint:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'create_promconstraint');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($promconstraint_meta);
    #BEGIN create_promconstraint
    
    # internal subroutine
    sub computeInteractionProbabilities {
	my ($reg_network, $expression_data) = @_;
	
	# should throw in some error checking at some point.
	
	my $status = '';
	
	# maps the numbers in the input to numbers in the output.  Here we assume that unknown expresson states
	# is mapped to ON.  But is this actually the right thing to do???
	# NOTE: empty values are mapped to 1, which means that we will NOT catch cases in which we do not find the TF or
	# target in the data
	my %isOn = (-1 => 0,0 => 1,1 => 1,''=>1); 

	## calculate P(target = ON|TF = OFF) and P(target = ON|TF = ON)
	my $tfTempMap = {};
	foreach my $i (@$reg_network) {
	    my $TF = $i->[0];
	    my $TARGET = $i->[1];
	    
	    my $TF_off_count = 0;
	    my $TF_off_TARGET_on_count = 0;
	    my $TF_on_count = 0;
	    my $TF_on_TARGET_on_count = 0;
	    
	    foreach my $experiment (@$expression_data) {
		if(!exists $experiment->{geneCalls}->{$TF}) { next; }
		if(!exists $experiment->{geneCalls}->{$TARGET}) { next; }
		if( 1==$isOn{$experiment->{geneCalls}->{$TF}}  ) {
		    $TF_on_count++;
		    if( 1==$isOn{$experiment->{geneCalls}->{$TARGET}}  ) {
			$TF_on_TARGET_on_count++;
		    } elsif( -1==$isOn{$experiment->{geneCalls}->{$TARGET}} ) {
			$status .= "  -> WARNING: could not find $TARGET in expression data ".$experiment->{label}."!\n";
		    }
		} elsif( 0==$isOn{$experiment->{geneCalls}->{$TF}} ) {
		    $TF_off_count++;
		    if( 1==$isOn{$experiment->{geneCalls}->{$TARGET}}  ) {
			$TF_off_TARGET_on_count++;
		    } elsif( -1==$isOn{$experiment->{geneCalls}->{$TARGET}} ) {
			$status .= "  -> WARNING: could not find $TARGET in expression data ".$experiment->{label}."!\n";
		    }
		} else {
		    # if we are here that we weren't able to find the TF in the experimental data list!!! What to do then!?!?!
		    $status .= "  -> WARNING: could not find $TF in expression data ".$experiment->{label}."!";
		}
	    }
	    # we need to perform a conversion once we have the genome annotation object
	    my $tfMapTarget = {"target_gene_ref" => $TARGET }; # $geneid2featureid{$TARGET}};
	    if ($TF_on_count != 0) { 
		$tfMapTarget->{"probTGonGivenTFon"} = $TF_on_TARGET_on_count / $TF_on_count;
		#print "p1:".$tfMapTarget->{"tfOnProbability"}."\n";
	    } else { $tfMapTarget->{"probTGonGivenTFon"} = 1; }
	    if ($TF_off_count != 0) {
		$tfMapTarget->{"probTGonGivenTFoff"} = $TF_off_TARGET_on_count / $TF_off_count;
		#print "p2:".$tfMapTarget->{"tfOffProbability"}."\n";
	    } else { $tfMapTarget->{"probTGonGivenTFoff"} = 1; }
	    if(exists $tfTempMap->{$TF}) {
		push @{$tfTempMap->{$TF}}, $tfMapTarget;
	    } else {
		$tfTempMap->{$TF} = [$tfMapTarget];
	    }
	}
	
	# repackage into the object that runFBA is expecting, which is not a hash, but a list of hashes
	my $tfMaps = [];
	foreach my $TF (keys %$tfTempMap) {
	    push @{$tfMaps}, {"transcriptionFactor_ref"=>$TF,"targetGeneProbs"=>$tfTempMap->{$TF}};
	}
	
	return ($status,$tfMaps);
    }


    $self->_setContext($ctx,$params);    
    $params = $self->_validateargs($params,["workspace"],{
    	expression_workspace => $params->{workspace},
    	genome_workspace => $params->{workspace},
    	regulome_workspace => $params->{workspace}
				   });

	my $e_id = $params->{series_id};
	my $r_id = $params->{regulome_id};
	my $genome_id = $params->{genome_id};

        my $ws = $self->_KBaseStore()->workspace();	
	# check if the gene expression data collection from a workspace exists
        my $exp_collection = $self->_get_msobject("ExpressionSeries",$params->{"expression_workspace"},$e_id);
	if(!defined $exp_collection) {
	    print "FAILURE - no expression data collection with ID $e_id found!\n";
	}
	# check if the regulatory network data from a workspace exists
        my $regnet = $self->_get_msobject("Regulome",$params->{"regulome_workspace"},$r_id);
	if(!defined $regnet) {
	    print "FAILURE - no regulatory network data with ID $r_id found!\n";
	}
	# check if the annotation data from a workspace exists
	my $genome = $self->_get_msobject("Genome",$params->{"genome_workspace"},$genome_id);
	# if both data sets exist, thecdn pull them down
	if(defined $exp_collection && defined $regnet && defined $genome) {
	    
	    # a regulatory network is a list where each element is a list in the form [TF, target, p1, p2]
	    my $regulatory_network = [];
	    foreach my $regulon (@{$regnet->regulons()}) {
		foreach my $tf (@{$regulon->tfs()}) {
		    foreach my $regulon (@{$regulon->operons()}) {
			foreach my $gene (@{$regulon->genes()}) {
			    push @$regulatory_network, [$tf->locus_tag(),$gene->locus_tag(),-1,-1];
			}
		    }
		}
	    }
	    
	    # now grab the expression data and store it in a parsed object
	    # Note that this does not do any sort of error checking for IDs or anything else!!!
	    # this structure is a list, where each element cooresponds to an expermental condition, as in:
	    # [
	    #    {
	    #       geneCalls => {g1 => 1, g2 => -1 ... },
	    #       description => ,
	    #       media => 'Complete',
	    #       label => 'exp1'
	    #    },
	    #    { ... }
	    #    ...
	    # ]
	    my $expression_data_on_off_calls = [];
	    #loop through each experiment
	    foreach my $sample_map (values %{$exp_collection->genome_expression_sample_ids_map()}) {
		foreach my $sample_id (@$sample_map) {
		    print "Getting sample $sample_id\n";
		    my ($sws,$sid,$sv) = split "/", $sample_id;
#		    my $sample = $self->_get_msobject("ExpressionSample",$params->{"expression_workspace"},$sample_id);
		    my $sample = $self->_get_msobject("ExpressionSample",$sws,$sid);
		    my $geneCalls = {};
		    foreach my $feature_id (keys %{$sample->expression_levels()}) {
			$geneCalls->{$feature_id} = $sample->expression_levels()->{$feature_id};
		    }
		    push @$expression_data_on_off_calls, {geneCalls => $geneCalls,,
						      media=> 'unknown',
						      description => $exp_collection->summary(),
						      label => $exp_collection->id()};
		}
	    }
	    
	    
	    # compute the interaction probability map; this is the central component of a prom model
	    my ($computation_log, $tfMap) = computeInteractionProbabilities($regulatory_network, $expression_data_on_off_calls);
	    my $prefix = $genome_id."-PromConstraint.";
	    my $promconstraint_id = (defined $params->{"promconstraint_id"}) ? $params->{"promconstraint_id"} : $prefix.$self->_idServer()->allocate_id_range($prefix,1);
		
	    my $PCObj = Bio::KBase::ObjectAPI::KBaseFBA::PromConstraint->new({id=>$promconstraint_id,genome_ref=>$genome->_reference(),transcriptionFactorMaps=>$tfMap,expression_series_ref=>$exp_collection->_reference(),regulome_ref=>$regnet->_reference()});
	    $promconstraint_meta  = $self->_save_msobject($PCObj,"PromConstraint",$params->{"workspace"},$promconstraint_id);
	    $self->_clearContext();
	}
    
    #END create_promconstraint
    my @_bad_returns;
    (ref($promconstraint_meta) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"promconstraint_meta\" (value was \"$promconstraint_meta\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to create_promconstraint:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'create_promconstraint');
    }
    return($promconstraint_meta);
}




=head2 add_biochemistry_compounds

  $output = $obj->add_biochemistry_compounds($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an add_biochemistry_compounds_params
$output is an object_metadata
add_biochemistry_compounds_params is a reference to a hash where the following keys are defined:
	compounds has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (abbreviation) a string
	1: (name) a string
	2: (aliases) a reference to a list where each element is a string
	3: (formula) a string
	4: (charge) a float
	5: (isCofactor) a bool
	6: (structureString) a string
	7: (structureType) a string
	8: (id) a string

	workspace has a value which is a string
	biochemistry has a value which is a string
	biochemistry_ws has a value which is a string
	output_id has a value which is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an add_biochemistry_compounds_params
$output is an object_metadata
add_biochemistry_compounds_params is a reference to a hash where the following keys are defined:
	compounds has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (abbreviation) a string
	1: (name) a string
	2: (aliases) a reference to a list where each element is a string
	3: (formula) a string
	4: (charge) a float
	5: (isCofactor) a bool
	6: (structureString) a string
	7: (structureType) a string
	8: (id) a string

	workspace has a value which is a string
	biochemistry has a value which is a string
	biochemistry_ws has a value which is a string
	output_id has a value which is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub add_biochemistry_compounds
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to add_biochemistry_compounds:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_biochemistry_compounds');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN add_biochemistry_compounds
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["workspace","compounds"],{
		biochemistry => "default",
		biochemistry_ws => $params->{workspace},
		output_id => $params->{biochemistry}
	});
	my $bio = $self->_get_msobject("Biochemistry",$params->{biochemistry_ws},$params->{biochemistry});
	for (my $i=0; $i < @{$params->{compounds}}; $i++) {
		my $cpd = $params->{compounds}->[$i];
		print $cpd->[1]."\n";
		$bio->add_compound({
			id => $cpd->[7],
			name => $cpd->[1],
			abbreviation => $cpd->[0],
			aliases => $cpd->[2],
			formula => $cpd->[3],
			charge => $cpd->[3],
			isCofactor => $cpd->[4],
			structureString => $cpd->[5],
			structureType => $cpd->[6],
		});
	}
	$output = $self->_save_msobject($bio,"Biochemistry",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END add_biochemistry_compounds
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to add_biochemistry_compounds:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_biochemistry_compounds');
    }
    return($output);
}




=head2 update_object_references

  $output = $obj->update_object_references($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an update_object_references_params
$output is an object_metadata
update_object_references_params is a reference to a hash where the following keys are defined:
	object has a value which is a string
	object_workspace has a value which is a string
	original_object has a value which is a string
	original_workspace has a value which is a string
	original_instance has a value which is a string
	reference_field has a value which is a string
	newobject has a value which is a string
	newobject_workspace has a value which is a string
	newobject_instance has a value which is a string
	create_newobject has a value which is a bool
	update_subrefs has a value which is a bool
	output_id has a value which is a string
	workspace has a value which is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an update_object_references_params
$output is an object_metadata
update_object_references_params is a reference to a hash where the following keys are defined:
	object has a value which is a string
	object_workspace has a value which is a string
	original_object has a value which is a string
	original_workspace has a value which is a string
	original_instance has a value which is a string
	reference_field has a value which is a string
	newobject has a value which is a string
	newobject_workspace has a value which is a string
	newobject_instance has a value which is a string
	create_newobject has a value which is a bool
	update_subrefs has a value which is a bool
	output_id has a value which is a string
	workspace has a value which is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description



=back

=cut

sub update_object_references
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to update_object_references:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'update_object_references');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN update_object_references
    #END update_object_references
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to update_object_references:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'update_object_references');
    }
    return($output);
}




=head2 add_reactions

  $output = $obj->add_reactions($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an add_reactions_params
$output is an object_metadata
add_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a string
	model_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	reactions has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (reaction_id) a string
	1: (compartment) a string
	2: (direction) a string
	3: (gpr) a string
	4: (pathway) a string
	5: (name) a string
	6: (reference) a string
	7: (enzyme) a string
	8: (equation) a string

object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an add_reactions_params
$output is an object_metadata
add_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a string
	model_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	reactions has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (reaction_id) a string
	1: (compartment) a string
	2: (direction) a string
	3: (gpr) a string
	4: (pathway) a string
	5: (name) a string
	6: (reference) a string
	7: (enzyme) a string
	8: (equation) a string

object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Add new reactions to the model from the biochemistry or custom reactions

=back

=cut

sub add_reactions
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to add_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN add_reactions
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["model","workspace","reactions"],{
    	model_workspace => $params->{workspace},
    	output_id => $params->{model},
    	compounds => []
    });
	($params->{reactions},my $compoundhash) = $self->process_reactions_list($params->{reactions},$params->{compounds});
    my $model = $self->_get_msobject("FBAModel",$params->{model_workspace},$params->{model});
    for (my $i=0; $i < @{$params->{reactions}}; $i++) {
    	$model->addModelReaction({
		    reaction => $params->{reaction}->[$i]->[0],
		    direction => $params->{reaction}->[$i]->[2],
		    compartment => $params->{reaction}->[$i]->[1],
		    gpr => $params->{reaction}->[$i]->[3],
		    compounds => $compoundhash,
		    equation => $params->{reaction}->[$i]->[8],
		    pathway => $params->{reaction}->[$i]->[4],
		    name => $params->{reaction}->[$i]->[5],
		    reference => $params->{reaction}->[$i]->[6],
		    enzyme => $params->{reaction}->[$i]->[7]
		});
    }
    $output = $self->_save_msobject($model,"FBAModel",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END add_reactions
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to add_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_reactions');
    }
    return($output);
}




=head2 remove_reactions

  $output = $obj->remove_reactions($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a remove_reactions_params
$output is an object_metadata
remove_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a string
	model_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	reactions has a value which is a reference to a list where each element is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a remove_reactions_params
$output is an object_metadata
remove_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a string
	model_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	reactions has a value which is a reference to a list where each element is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Remove reactions from the model

=back

=cut

sub remove_reactions
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to remove_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'remove_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN remove_reactions
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["model","workspace","reactions"],{
    	model_workspace => $params->{workspace},
    	output_id => $params->{model},
    });
    my $model = $self->_get_msobject("FBAModel",$params->{model_workspace},$params->{model});
    for (my $i=0; $i < @{$params->{reactions}}; $i++) {
    	my $rxn = $model->getObject("models",$params->{reactions}->[$i]);
    	if (defined($rxn)) {
    		$model->remove("modelreactions",$rxn);
    	}
    }
    $output = $self->_save_msobject($model,"FBAModel",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END remove_reactions
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to remove_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'remove_reactions');
    }
    return($output);
}




=head2 modify_reactions

  $output = $obj->modify_reactions($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a modify_reactions_params
$output is an object_metadata
modify_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a string
	model_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	reactions has a value which is a reference to a list where each element is a reference to a list containing 7 items:
	0: (reaction_id) a string
	1: (direction) a string
	2: (gpr) a string
	3: (pathway) a string
	4: (name) a string
	5: (reference) a string
	6: (enzyme) a string

object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a modify_reactions_params
$output is an object_metadata
modify_reactions_params is a reference to a hash where the following keys are defined:
	model has a value which is a string
	model_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	reactions has a value which is a reference to a list where each element is a reference to a list containing 7 items:
	0: (reaction_id) a string
	1: (direction) a string
	2: (gpr) a string
	3: (pathway) a string
	4: (name) a string
	5: (reference) a string
	6: (enzyme) a string

object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Modify reactions in the model

=back

=cut

sub modify_reactions
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to modify_reactions:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'modify_reactions');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN modify_reactions
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["model","workspace","reactions"],{
    	model_workspace => $params->{workspace},
    	output_id => $params->{model},
    });
    my $model = $self->_get_msobject("FBAModel",$params->{model_workspace},$params->{model});
    for (my $i=0; $i < @{$params->{reactions}}; $i++) { 
    	$model->adjustModelReaction({
		    reaction => $params->{reactions}->[$i]->[0],
		    direction => $params->{reactions}->[$i]->[1],
		    gpr => $params->{reactions}->[$i]->[2],
		    pathway => $params->{reactions}->[$i]->[3],
		    name => $params->{reactions}->[$i]->[4],
		    reference => $params->{reactions}->[$i]->[5],
		    enzyme => $params->{reactions}->[$i]->[6]
		});
    }
    $output = $self->_save_msobject($model,"FBAModel",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END modify_reactions
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to modify_reactions:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'modify_reactions');
    }
    return($output);
}




=head2 add_features

  $output = $obj->add_features($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an add_features_params
$output is an object_metadata
add_features_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (feature) a feature_id
	1: (function) a string
	2: (type) a string
	3: (aliases) a reference to a list where each element is a string
	4: (publications) a reference to a list where each element is a string
	5: (annotations) a reference to a list where each element is a string
	6: (protein_translation) a string
	7: (dna_sequence) a string
	8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
		0: a string
		1: an int
		2: a string
		3: an int


feature_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an add_features_params
$output is an object_metadata
add_features_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (feature) a feature_id
	1: (function) a string
	2: (type) a string
	3: (aliases) a reference to a list where each element is a string
	4: (publications) a reference to a list where each element is a string
	5: (annotations) a reference to a list where each element is a string
	6: (protein_translation) a string
	7: (dna_sequence) a string
	8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
		0: a string
		1: an int
		2: a string
		3: an int


feature_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Add new features to the genome

=back

=cut

sub add_features
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to add_features:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_features');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN add_features
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["genome","workspace","features"],{
    	genome_workspace => $params->{workspace},
    	output_id => $params->{genome},
    });
    my $genome = $self->_get_msobject("Genome",$params->{genome_workspace},$params->{genome});
    for (my $i=0; $i < @{$params->{features}}; $i++) {
    	my $ftr = $genome->getObject("features",$params->{features}->[$i]->[0]);
    	if (!defined($ftr)) {
    		$genome->add_gene({
    			id => $params->{features}->[$i]->[0],
    			function => $params->{features}->[$i]->[1],
    			type => $params->{features}->[$i]->[2],
    			aliases => $params->{features}->[$i]->[3],
    			publications => $params->{features}->[$i]->[4],
    			annotations => $params->{features}->[$i]->[5],
    			protein_translation => $params->{features}->[$i]->[6],
    			dna_sequence => $params->{features}->[$i]->[7],
    			locations => $params->{features}->[$i]->[8]
    		});
    	}
    }
    $output = $self->_save_msobject($genome,"Genome",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END add_features
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to add_features:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'add_features');
    }
    return($output);
}




=head2 remove_features

  $output = $obj->remove_features($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a remove_features_params
$output is an object_metadata
remove_features_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	features has a value which is a reference to a list where each element is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a remove_features_params
$output is an object_metadata
remove_features_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	features has a value which is a reference to a list where each element is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Remove features from the genome

=back

=cut

sub remove_features
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to remove_features:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'remove_features');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN remove_features
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["genome","workspace","features"],{
    	genome_workspace => $params->{workspace},
    	output_id => $params->{genome},
    });
    my $genome = $self->_get_msobject("Genome",$params->{genome_workspace},$params->{genome});
    for (my $i=0; $i < @{$params->{features}}; $i++) {
    	my $ftr = $genome->getObject("features",$params->{features}->[$i]);
    	if (defined($ftr)) {
    		$genome->remove("features",$ftr);
    	}
    }
    $output = $self->_save_msobject($genome,"Genome",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END remove_features
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to remove_features:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'remove_features');
    }
    return($output);
}




=head2 modify_features

  $output = $obj->modify_features($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a modify_features_params
$output is an object_metadata
modify_features_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (feature) a feature_id
	1: (function) a string
	2: (type) a string
	3: (aliases) a reference to a list where each element is a string
	4: (publications) a reference to a list where each element is a string
	5: (annotations) a reference to a list where each element is a string
	6: (protein_translation) a string
	7: (dna_sequence) a string
	8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
		0: a string
		1: an int
		2: a string
		3: an int


feature_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a modify_features_params
$output is an object_metadata
modify_features_params is a reference to a hash where the following keys are defined:
	genome has a value which is a string
	genome_workspace has a value which is a string
	output_id has a value which is a string
	workspace has a value which is a string
	genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
	0: (feature) a feature_id
	1: (function) a string
	2: (type) a string
	3: (aliases) a reference to a list where each element is a string
	4: (publications) a reference to a list where each element is a string
	5: (annotations) a reference to a list where each element is a string
	6: (protein_translation) a string
	7: (dna_sequence) a string
	8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
		0: a string
		1: an int
		2: a string
		3: an int


feature_id is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Modify features in the genome

=back

=cut

sub modify_features
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to modify_features:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'modify_features');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN modify_features
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["genome","workspace","features"],{
    	genome_workspace => $params->{workspace},
    	output_id => $params->{genome},
    });
    my $genome = $self->_get_msobject("Genome",$params->{genome_workspace},$params->{genome});
    for (my $i=0; $i < @{$params->{features}}; $i++) {
    	my $ftr = $genome->getObject("features",$params->{features}->[$i]->[0]);
    	if (defined($ftr)) {
    		$ftr->modify({
    			function => $params->{features}->[$i]->[1],
    			type => $params->{features}->[$i]->[2],
    			aliases => $params->{features}->[$i]->[3],
    			publications => $params->{features}->[$i]->[4],
    			annotations => $params->{features}->[$i]->[5],
    			protein_translation => $params->{features}->[$i]->[6],
    			dna_sequence => $params->{features}->[$i]->[7],
    			locations => $params->{features}->[$i]->[8]
    		});
    	} else {
    		$self->_error("Feature ".$params->{features}->[$i]->[0]." not found!");
    	}
    }
    $output = $self->_save_msobject($genome,"Genome",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END modify_features
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to modify_features:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'modify_features');
    }
    return($output);
}




=head2 import_trainingset

  $output = $obj->import_trainingset($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is an import_trainingset_params
$output is an object_metadata
import_trainingset_params is a reference to a hash where the following keys are defined:
	workspace_training_set has a value which is a reference to a list where each element is a reference to a list containing 3 items:
	0: (workspace_id) a string
	1: (genome_id) a string
	2: (class) a string

	external_training_set has a value which is a reference to a list where each element is a reference to a list containing 4 items:
	0: (database) a string
	1: (genome_id) a string
	2: (class) a string
	3: (attributes) a reference to a list where each element is a string

	description has a value which is a string
	class_data has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (class) a string
	1: (description) a string

	attribute_type has a value which is a string
	preload_attributes has a value which is a bool
	workspace has a value which is a string
	output_id has a value which is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is an import_trainingset_params
$output is an object_metadata
import_trainingset_params is a reference to a hash where the following keys are defined:
	workspace_training_set has a value which is a reference to a list where each element is a reference to a list containing 3 items:
	0: (workspace_id) a string
	1: (genome_id) a string
	2: (class) a string

	external_training_set has a value which is a reference to a list where each element is a reference to a list containing 4 items:
	0: (database) a string
	1: (genome_id) a string
	2: (class) a string
	3: (attributes) a reference to a list where each element is a string

	description has a value which is a string
	class_data has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (class) a string
	1: (description) a string

	attribute_type has a value which is a string
	preload_attributes has a value which is a bool
	workspace has a value which is a string
	output_id has a value which is a string
bool is an int
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Import a training set of genomes and classifications

=back

=cut

sub import_trainingset
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to import_trainingset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_trainingset');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN import_trainingset
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["workspace"],{
    	workspace_training_set => [],
    	external_training_set => [],
    	description => "",
    	source => undef,
    	class_data => [],
    	attribute_type => "functional_roles",
    	preload_attributes => 0,
    	output_id => undef
    });
    if (!defined($params->{output_id})) {
    	$params->{output_id} = $self->_get_new_id("kb|ts");;
    }
    my $ts = Bio::KBase::ObjectAPI::KBaseFBA::ClassifierTrainingSet->new({
    	id => $params->{output_id},
        description => $params->{description},
        workspace_training_set => [], 
		external_training_set => [],
		class_data => []
    });
    $ts->load_trainingset_from_input($params);
    $self->_save_msobject($ts,"ClassifierTrainingSet",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END import_trainingset
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to import_trainingset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'import_trainingset');
    }
    return($output);
}




=head2 preload_trainingset

  $output = $obj->preload_trainingset($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a preload_trainingset_params
$output is an object_metadata
preload_trainingset_params is a reference to a hash where the following keys are defined:
	trainingset has a value which is a string
	trainingset_ws has a value which is a string
	attribute_type has a value which is a string
	workspace has a value which is a string
	output_id has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a preload_trainingset_params
$output is an object_metadata
preload_trainingset_params is a reference to a hash where the following keys are defined:
	trainingset has a value which is a string
	trainingset_ws has a value which is a string
	attribute_type has a value which is a string
	workspace has a value which is a string
	output_id has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Preloads a training set with attributes, cutting time to produce distinct classifiers

=back

=cut

sub preload_trainingset
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to preload_trainingset:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'preload_trainingset');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN preload_trainingset
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["trainingset","workspace"],{
    	trainingset_ws => $params->{workspace},
    	attribute_type => "functional_roles",
    	output_id => $params->{trainingset}
    });
    my $ts = $self->_get_msobject("ClassifierTrainingSet",$params->{trainingset_ws},$params->{trainingset});
    $ts->attribute_type($params->{attribute_type});
    $ts->load_trainingset();	
    $self->_save_msobject($ts,"ClassifierTrainingSet",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END preload_trainingset
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to preload_trainingset:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'preload_trainingset');
    }
    return($output);
}




=head2 build_classifier

  $output = $obj->build_classifier($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a build_classifier_params
$output is an object_metadata
build_classifier_params is a reference to a hash where the following keys are defined:
	trainingset has a value which is a string
	trainingset_ws has a value which is a string
	attribute_type has a value which is a string
	classifier_type has a value which is a string
	workspace has a value which is a string
	output_id has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a build_classifier_params
$output is an object_metadata
build_classifier_params is a reference to a hash where the following keys are defined:
	trainingset has a value which is a string
	trainingset_ws has a value which is a string
	attribute_type has a value which is a string
	classifier_type has a value which is a string
	workspace has a value which is a string
	output_id has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Build a classifier for the input set of genomes

=back

=cut

sub build_classifier
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to build_classifier:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'build_classifier');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN build_classifier
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["trainingset","workspace"],{
    	trainingset_ws => $params->{workspace},
    	attribute_type => "functional_roles",
    	output_id => $params->{trainingset}
    });
    my $ts = $self->_get_msobject("ClassifierTrainingSet",$params->{trainingset_ws},$params->{trainingset});
    my $cf = $ts->runjob();	
    $self->_save_msobject($cf,"Classifier",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END build_classifier
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to build_classifier:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'build_classifier');
    }
    return($output);
}




=head2 classify_genomes

  $output = $obj->classify_genomes($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a classify_genomes_params
$output is an object_metadata
classify_genomes_params is a reference to a hash where the following keys are defined:
	workspace_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (workspace_id) a string
	1: (genome_id) a string

	external_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (database) a string
	1: (genome_id) a string

	workspace has a value which is a string
	output_id has a value which is a string
	classify_ws has a value which is a string
	classifier has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a classify_genomes_params
$output is an object_metadata
classify_genomes_params is a reference to a hash where the following keys are defined:
	workspace_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (workspace_id) a string
	1: (genome_id) a string

	external_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
	0: (database) a string
	1: (genome_id) a string

	workspace has a value which is a string
	output_id has a value which is a string
	classify_ws has a value which is a string
	classifier has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Build a classifier for the input set of genomes

=back

=cut

sub classify_genomes
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to classify_genomes:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'classify_genomes');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN classify_genomes
    $self->_setContext($ctx,$params);
    $params = $self->_validateargs($params,["classifier","workspace"],{
    	workspace_genomes => [],
    	external_genomes => [],
    	classifier_ws => $params->{workspace},
    	output_id => undef
    });
    if (!defined($params->{output_id})) {
    	$params->{output_id} = $self->_get_new_id("kb|cfr");;
    }
    my $ts = Bio::KBase::ObjectAPI::KBaseFBA::ClassifierTrainingSet->new({
    	id => $params->{output_id},
        description => "",
        workspace_training_set => [], 
		external_training_set => [],
		class_data => []
    });
    $params->{workspace_training_set} = $params->{workspace_genomes};
    $params->{external_training_set} = $params->{external_genomes};
    $params->{preload_attributes} = 1;
    $ts->load_trainingset_from_input($params);
    my $cf = $self->_get_msobject("Classifier",$params->{trainingset_ws},$params->{trainingset});
    my $cr = $cf->classify_genomes($ts);
    $output = $self->_save_msobject($cr,"ClassifierResult",$params->{workspace},$params->{output_id});
    $self->_clearContext();
    #END classify_genomes
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to classify_genomes:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'classify_genomes');
    }
    return($output);
}




=head2 build_tissue_model

  $output = $obj->build_tissue_model($params)

=over 4

=item Parameter and return types

=begin html

<pre>
$params is a build_tissue_model_params
$output is an object_metadata
build_tissue_model_params is a reference to a hash where the following keys are defined:
	expsample_ws has a value which is a string
	expsample has a value which is a string
	model_ws has a value which is a string
	model has a value which is a string
	workspace has a value which is a string
	output_id has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string

</pre>

=end html

=begin text

$params is a build_tissue_model_params
$output is an object_metadata
build_tissue_model_params is a reference to a hash where the following keys are defined:
	expsample_ws has a value which is a string
	expsample has a value which is a string
	model_ws has a value which is a string
	model has a value which is a string
	workspace has a value which is a string
	output_id has a value which is a string
object_metadata is a reference to a list containing 11 items:
	0: (id) an object_id
	1: (type) an object_type
	2: (moddate) a timestamp
	3: (instance) an int
	4: (command) a string
	5: (lastmodifier) a username
	6: (owner) a username
	7: (workspace) a workspace_id
	8: (ref) a workspace_ref
	9: (chsum) a string
	10: (metadata) a reference to a hash where the key is a string and the value is a string
object_id is a string
object_type is a string
timestamp is a string
username is a string
workspace_id is a string
workspace_ref is a string


=end text



=item Description

Build a tissue model based on the input expression data

=back

=cut

sub build_tissue_model
{
    my $self = shift;
    my($params) = @_;

    my @_bad_arguments;
    (ref($params) eq 'HASH') or push(@_bad_arguments, "Invalid type for argument \"params\" (value was \"$params\")");
    if (@_bad_arguments) {
	my $msg = "Invalid arguments passed to build_tissue_model:\n" . join("", map { "\t$_\n" } @_bad_arguments);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'build_tissue_model');
    }

    my $ctx = $Bio::KBase::fbaModelServices::Server::CallContext;
    my($output);
    #BEGIN build_tissue_model
    $self->_setContext($ctx,$params);
	$params = $self->_validateargs($params,["expsample","model","workspace"],{		
		model_ws => $params->{workspace},
		expsample_ws => $params->{workspace},
		output_id => $params->{model},
		solver => undef,
		activation_penalty => 0.1
	});
	my $model = $self->_get_msobject("FBAModel",$params->{model_ws},$params->{model});
	my $sample = $self->_get_msobject("ExpressionSample",$params->{expsample_ws},$params->{expsample});
	my $formulation = $self->_setDefaultGapfillFormulation({});
	$formulation->{completeGapfill} = 1;
	$formulation->{num_solutions} = 1;
	my $gfid = @{$model->gapfillings()};
	$gfid = $model->id().".gf.".$gfid;
	my ($gapfill,$fba) = $self->_buildGapfillObject($formulation,$model,$gfid);
	$fba->parameters()->{"Fast gap filling"} = $params->{fastgapfill};
	$fba->parameters()->{"Simultaneous gapfill"} = $params->{simultaneous};
	$fba->parameters()->{"Reaction activation bonus"} = $params->{activation_penalty};
	if (defined($params->{solver})) {
    	$fba->parameters()->{MFASolver} = uc($params->{solver});
    }
	$fba->runFBA();
	#Error checking the FBA and gapfilling solution
	if (!defined($fba->outputfiles()->{"CompleteGapfillingOutput.txt"}->[1] ) ) {
		$self->_error("Analysis failed to produce an output file. Check infrastructure!");
	}
	my $gfoutput = $fba->outputfiles()->{"CompleteGapfillingOutput.txt"};
	for (my $i=0; $i < @{$gfoutput}; $i++) {
		my $line = $gfoutput->[$i];
		if ($line =~ /FAILED/ && $line =~ /Prelim/ && $line =~ /bio\d+/) {
			my $array = [split(/\t/,$line)];
			if (defined($array->[6])) {
				$self->_error("Failed in preliminary feasibility determination. The following biomass compounds appear to be problematic: ".$array->[6]."!");
			} else {
				$self->_error("Failed in preliminary feasibility determination.");
			}
		} elsif ($line =~ /FAILED/ && $line =~ /bio\d+/) {
			$self->_error("Failed with no solutions!");
		}
	}
	$gapfill->parseGapfillingResults($fba);
	if (!defined($gapfill->gapfillingSolutions()->[0])) {
		$self->_error("Analysis completed, but no valid solutions found!");
	}
	my $meta = $self->_save_msobject($fba,"FBA",$params->{workspace},$fba->id(),{hidden => 1});
	$gapfill->fba_ref($fba->_reference());
	$meta = $self->_save_msobject($gapfill,"Gapfilling",$params->{workspace},$gapfill->id(),{hidden => 1});
	$model->add("gapfillings",{
		id => $gapfill->id(),
		gapfill_id => $gapfill->id(),
		gapfill_ref => $gapfill->_reference(),
		integrated => 0,
		media_ref => $fba->media()->_reference()
	});
	my $report = $model->integrateGapfillSolution({
		gapfill => $gapfill->id()
	});
	$output = $self->_save_msobject($model,"FBAModel",$params->{workspace},$params->{output_id});
	$self->_clearContext();
    #END build_tissue_model
    my @_bad_returns;
    (ref($output) eq 'ARRAY') or push(@_bad_returns, "Invalid type for return variable \"output\" (value was \"$output\")");
    if (@_bad_returns) {
	my $msg = "Invalid returns passed to build_tissue_model:\n" . join("", map { "\t$_\n" } @_bad_returns);
	Bio::KBase::Exceptions::ArgumentValidationError->throw(error => $msg,
							       method_name => 'build_tissue_model');
    }
    return($output);
}




=head2 version 

  $return = $obj->version()

=over 4

=item Parameter and return types

=begin html

<pre>
$return is a string
</pre>

=end html

=begin text

$return is a string

=end text

=item Description

Return the module version. This is a Semantic Versioning number.

=back

=cut

sub version {
    return $VERSION;
}

=head1 TYPES



=head2 bool

=over 4



=item Description

********************************************************************************
    Universal simple type definitions
   	********************************************************************************


=item Definition

=begin html

<pre>
an int
</pre>

=end html

=begin text

an int

=end text

=back



=head2 mdlrxn_kbid

=over 4



=item Description

KBase ID for a model reaction


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 ws_ref

=over 4



=item Description

A string specifying a full workspace ID


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 kbase_id

=over 4



=item Description

A string specifying a KBase ID


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 workspace_id

=over 4



=item Description

A string used as an ID for a workspace. Any string consisting of alphanumeric characters and "-" is acceptable


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 complex_id

=over 4



=item Description

A string used as an ID for a complex.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 template_id

=over 4



=item Description

A string used as an ID for a complex.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 role_id

=over 4



=item Description

A string used as an ID for a complex.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 object_type

=over 4



=item Description

A string indicating the "type" of an object stored in a workspace. Acceptable types are returned by the "get_types()" command in the workspace_service


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 object_id

=over 4



=item Description

ID of an object stored in the workspace. Any string consisting of alphanumeric characters and "-" is acceptable


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 username

=over 4



=item Description

Login name of KBase useraccount to which permissions for workspaces are mapped


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 timestamp

=over 4



=item Description

Exact time for workspace operations. e.g. 2012-12-17T23:24:06


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 compound_id

=over 4



=item Description

An identifier for compounds in the KBase biochemistry database. e.g. cpd00001


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 biochemistry_id

=over 4



=item Description

A string used to identify a particular biochemistry database object in KBase. e.g. "default" is the ID of the standard KBase biochemistry


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 genome_id

=over 4



=item Description

A string identifier for a genome in KBase. e.g. "kb|g.0" is the ID for E. coli


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 promconstraint_id

=over 4



=item Description

A string identifier for a promconstraint in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 sample_id

=over 4



=item Description

A string identifier for a gene expression sample in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 series_id

=over 4



=item Description

A string identifier for a gene expression sample series in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 contig_id

=over 4



=item Description

A string identifier for a contiguous piece of DNA in KBase, representing a chromosome or an assembled fragment


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 feature_type

=over 4



=item Description

A string specifying the type of genome features in KBase


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 modelcompartment_id

=over 4



=item Description

A string identifier used for compartments in models in KBase. Compartments could represet organelles in a eukaryotic model, or entire cells in a community model


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 modelcompound_id

=over 4



=item Description

A string identifier used for compounds in models in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 feature_id

=over 4



=item Description

A string identifier used for a feature in a genome.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 reaction_id

=over 4



=item Description

A string identifier used for a reaction in a KBase biochemistry.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 modelreaction_id

=over 4



=item Description

A string identifier used for a reaction in a model in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 biomass_id

=over 4



=item Description

A string identifier used for a biomass reaction in a KBase model.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 media_id

=over 4



=item Description

A string identifier used for a media condition in the KBase database.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 fba_id

=over 4



=item Description

A string identifier used for a flux balance analysis study in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 gapgen_id

=over 4



=item Description

A string identifier for a gap generation study in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 gapfill_id

=over 4



=item Description

A string identifier for a gap filling study in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 gapgensolution_id

=over 4



=item Description

A string identifier for a solution from a gap generation study in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 gapfillsolution_id

=over 4



=item Description

A string identifier for a solution from a gap filling study in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 fbamodel_id

=over 4



=item Description

A string identifier for a metabolic model in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 mapping_id

=over 4



=item Description

A string identifier for a Mapping object in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 regulome_id

=over 4



=item Description

A string identifier for a regulome in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 regmodel_id

=over 4



=item Description

A string identifier for a regulatory model in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 compartment_id

=over 4



=item Description

A string identifier for a compartment in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 expression_id

=over 4



=item Description

A string identifier for an expression dataset in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 phenotype_set_id

=over 4



=item Description

A string identifier used for a set of phenotype data loaded into KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 workspace_ref

=over 4



=item Description

A permanent reference to an object in a workspace.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 probanno_id

=over 4



=item Description

A string identifier used for a probabilistic annotation in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 reaction_synonyms_id

=over 4



=item Description

A string identifier for a reaction synonyms in KBase.


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 Genome_uid

=over 4



=item Description

A user ID for a genome in KBase


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 object_metadata

=over 4



=item Description

********************************************************************************
    Object type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a list containing 11 items:
0: (id) an object_id
1: (type) an object_type
2: (moddate) a timestamp
3: (instance) an int
4: (command) a string
5: (lastmodifier) a username
6: (owner) a username
7: (workspace) a workspace_id
8: (ref) a workspace_ref
9: (chsum) a string
10: (metadata) a reference to a hash where the key is a string and the value is a string

</pre>

=end html

=begin text

a reference to a list containing 11 items:
0: (id) an object_id
1: (type) an object_type
2: (moddate) a timestamp
3: (instance) an int
4: (command) a string
5: (lastmodifier) a username
6: (owner) a username
7: (workspace) a workspace_id
8: (ref) a workspace_ref
9: (chsum) a string
10: (metadata) a reference to a hash where the key is a string and the value is a string


=end text

=back



=head2 md5

=over 4



=item Description

********************************************************************************
    Probabilistic Annotation type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 md5s

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a md5
</pre>

=end html

=begin text

a reference to a list where each element is a md5

=end text

=back



=head2 region_of_dna

=over 4



=item Description

A region of DNA is maintained as a tuple of four components:

        the contig
        the beginning position (from 1)
        the strand
        the length

        We often speak of "a region".  By "location", we mean a sequence
        of regions from the same genome (perhaps from distinct contigs).


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: a contig_id
1: (begin) an int
2: (strand) a string
3: (length) an int

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: a contig_id
1: (begin) an int
2: (strand) a string
3: (length) an int


=end text

=back



=head2 location

=over 4



=item Description

a "location" refers to a sequence of regions


=item Definition

=begin html

<pre>
a reference to a list where each element is a region_of_dna
</pre>

=end html

=begin text

a reference to a list where each element is a region_of_dna

=end text

=back



=head2 annotation

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (comment) a string
1: (annotator) a string
2: (annotation_time) an int

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (comment) a string
1: (annotator) a string
2: (annotation_time) an int


=end text

=back



=head2 gene_hit

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (gene) a feature_id
1: (blast_score) a float

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (gene) a feature_id
1: (blast_score) a float


=end text

=back



=head2 alt_func

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (function) a string
1: (probability) a float
2: (gene_hits) a reference to a list where each element is a gene_hit

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (function) a string
1: (probability) a float
2: (gene_hits) a reference to a list where each element is a gene_hit


=end text

=back



=head2 feature

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a feature_id
location has a value which is a location
type has a value which is a feature_type
function has a value which is a string
alternative_functions has a value which is a reference to a list where each element is an alt_func
protein_translation has a value which is a string
aliases has a value which is a reference to a list where each element is a string
annotations has a value which is a reference to a list where each element is an annotation

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a feature_id
location has a value which is a location
type has a value which is a feature_type
function has a value which is a string
alternative_functions has a value which is a reference to a list where each element is an alt_func
protein_translation has a value which is a string
aliases has a value which is a reference to a list where each element is a string
annotations has a value which is a reference to a list where each element is an annotation


=end text

=back



=head2 contig

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a contig_id
dna has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a contig_id
dna has a value which is a string


=end text

=back



=head2 GenomeObject

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a genome_id
scientific_name has a value which is a string
domain has a value which is a string
genetic_code has a value which is an int
source has a value which is a string
source_id has a value which is a string
contigs has a value which is a reference to a list where each element is a contig
features has a value which is a reference to a list where each element is a feature

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a genome_id
scientific_name has a value which is a string
domain has a value which is a string
genetic_code has a value which is an int
source has a value which is a string
source_id has a value which is a string
contigs has a value which is a reference to a list where each element is a contig
features has a value which is a reference to a list where each element is a feature


=end text

=back



=head2 annotationProbability

=over 4



=item Description

Data structures to hold a single annotation probability for a single gene

feature_id feature - feature the annotation is associated with
string function - the name of the functional role being annotated to the feature
float probability - the probability that the functional role is associated with the feature


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (feature) a feature_id
1: (function) a string
2: (probability) a float

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (feature) a feature_id
1: (function) a string
2: (probability) a float


=end text

=back



=head2 probanno_id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 alt_func

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (function) a string
1: (probability) a float

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (function) a string
1: (probability) a float


=end text

=back



=head2 ProbAnnoFeature

=over 4



=item Description

Object to carry alternative functions for each feature
    
feature_id id
ID of the feature. Required.
    
string function
Primary annotated function of the feature in the genome annotation. Required.
    
list<alt_func> alternative_functions
List of tuples containing alternative functions and probabilities. Required.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a feature_id
alternative_functions has a value which is a reference to a list where each element is an alt_func

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a feature_id
alternative_functions has a value which is a reference to a list where each element is an alt_func


=end text

=back



=head2 ProbabilisticAnnotation

=over 4



=item Description

Object to carry alternative functions and probabilities for genes in a genome

    probanno_id id - ID of the probabilistic annotation object. Required.    
    genome_id genome - ID of the genome the probabilistic annotation was built for. Required.
    workspace_ref genome_uuid - Reference to retrieve genome from workspace service. Required.
    list<ProbAnnoFeature> featureAlternativeFunctions - List of ProbAnnoFeature objects holding alternative functions for features. Required.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a probanno_id
genome has a value which is a genome_id
genome_uuid has a value which is a workspace_ref
featureAlternativeFunctions has a value which is a reference to a list where each element is a ProbAnnoFeature

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a probanno_id
genome has a value which is a genome_id
genome_uuid has a value which is a workspace_ref
featureAlternativeFunctions has a value which is a reference to a list where each element is a ProbAnnoFeature


=end text

=back



=head2 ReactionProbability

=over 4



=item Description

Data structure to hold probability of a reaction

        reaction_id reaction - ID of the reaction
        float probability - Probability of the reaction
        string gene_list - List of genes most likely to be attached to reaction


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (reaction) a reaction_id
1: (probability) a float
2: (gene_list) a string

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (reaction) a reaction_id
1: (probability) a float
2: (gene_list) a string


=end text

=back



=head2 Biochemistry

=over 4



=item Description

********************************************************************************
    Biochemistry type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a biochemistry_id
name has a value which is a string
compounds has a value which is a reference to a list where each element is a compound_id
reactions has a value which is a reference to a list where each element is a reaction_id
media has a value which is a reference to a list where each element is a media_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a biochemistry_id
name has a value which is a string
compounds has a value which is a reference to a list where each element is a compound_id
reactions has a value which is a reference to a list where each element is a reaction_id
media has a value which is a reference to a list where each element is a media_id


=end text

=back



=head2 MediaCompound

=over 4



=item Description

Data structures for media compound formulation

compound_id compound - ID of compound in media
string name - name of compound in media
float concentration - concentration of compound in media
float maxFlux - maximum flux of compound in media
float minFlux - minimum flux of compound in media


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
compound has a value which is a compound_id
name has a value which is a string
concentration has a value which is a float
max_flux has a value which is a float
min_flux has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
compound has a value which is a compound_id
name has a value which is a string
concentration has a value which is a float
max_flux has a value which is a float
min_flux has a value which is a float


=end text

=back



=head2 Media

=over 4



=item Description

Data structures for media formulation

media_id id - ID of media formulation
string name - name of media formulaiton
list<MediaCompound> media_compounds - list of compounds in media formulation
float pH - pH of media condition
float temperature - temperature of media condition


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a media_id
name has a value which is a string
media_compounds has a value which is a reference to a list where each element is a MediaCompound
pH has a value which is a float
temperature has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a media_id
name has a value which is a string
media_compounds has a value which is a reference to a list where each element is a MediaCompound
pH has a value which is a float
temperature has a value which is a float


=end text

=back



=head2 Compound

=over 4



=item Description

Data structures for media formulation

compound_id id - ID of compound
string abbrev - abbreviated name of compound
string name - primary name of compound
list<string> aliases - list of aliases for compound
float charge - molecular charge of compound
float deltaG - estimated compound delta G
float deltaGErr - uncertainty in estimated compound delta G
string formula - molecular formula of compound


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a compound_id
abbrev has a value which is a string
name has a value which is a string
aliases has a value which is a reference to a list where each element is a string
charge has a value which is a float
deltaG has a value which is a float
deltaGErr has a value which is a float
formula has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a compound_id
abbrev has a value which is a string
name has a value which is a string
aliases has a value which is a reference to a list where each element is a string
charge has a value which is a float
deltaG has a value which is a float
deltaGErr has a value which is a float
formula has a value which is a string


=end text

=back



=head2 Reaction

=over 4



=item Description

Data structures for media formulation

reaction_id id - ID of reaction
string name - primary name of reaction
string abbrev - abbreviated name of reaction
list<string> enzymes - list of EC numbers for reaction
string direction - directionality of reaction
string reversibility - reversibility of reaction
float deltaG - estimated delta G of reaction
float deltaGErr - uncertainty in estimated delta G of reaction
string equation - reaction equation in terms of compound IDs
string definition - reaction equation in terms of compound names


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a reaction_id
name has a value which is a string
abbrev has a value which is a string
enzymes has a value which is a reference to a list where each element is a string
direction has a value which is a string
reversibility has a value which is a string
deltaG has a value which is a float
deltaGErr has a value which is a float
equation has a value which is a string
definition has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a reaction_id
name has a value which is a string
abbrev has a value which is a string
enzymes has a value which is a reference to a list where each element is a string
direction has a value which is a string
reversibility has a value which is a string
deltaG has a value which is a float
deltaGErr has a value which is a float
equation has a value which is a string
definition has a value which is a string


=end text

=back



=head2 ModelCompartment

=over 4



=item Description

********************************************************************************
    FBAModel type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a modelcompartment_id
name has a value which is a string
pH has a value which is a float
potential has a value which is a float
index has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a modelcompartment_id
name has a value which is a string
pH has a value which is a float
potential has a value which is a float
index has a value which is an int


=end text

=back



=head2 ModelCompound

=over 4



=item Description

Data structures for a compound in a model

modelcompound_id id - ID of the specific instance of the compound in the model
compound_id compound - ID of the compound associated with the model compound
string name - name of the compound associated with the model compound
modelcompartment_id compartment - ID of the compartment containing the compound


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a modelcompound_id
compound has a value which is a compound_id
name has a value which is a string
compartment has a value which is a modelcompartment_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a modelcompound_id
compound has a value which is a compound_id
name has a value which is a string
compartment has a value which is a modelcompartment_id


=end text

=back



=head2 ModelReaction

=over 4



=item Description

Data structures for a reaction in a model

modelreaction_id id - ID of the specific instance of the reaction in the model
reaction_id reaction - ID of the reaction
string name - name of the reaction
string direction - directionality of the reaction
string equation - stoichiometric equation of the reaction in terms of compound IDs
string definition - stoichiometric equation of the reaction in terms of compound names
list<feature_id> features - list of features associated with the reaction
modelcompartment_id compartment - ID of the compartment containing the reaction


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a modelreaction_id
reaction has a value which is a reaction_id
name has a value which is a string
direction has a value which is a string
equation has a value which is a string
definition has a value which is a string
gapfilled has a value which is a bool
features has a value which is a reference to a list where each element is a feature_id
compartment has a value which is a modelcompartment_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a modelreaction_id
reaction has a value which is a reaction_id
name has a value which is a string
direction has a value which is a string
equation has a value which is a string
definition has a value which is a string
gapfilled has a value which is a bool
features has a value which is a reference to a list where each element is a feature_id
compartment has a value which is a modelcompartment_id


=end text

=back



=head2 BiomassCompound

=over 4



=item Description

Data structures for a reaction in a model

modelcompound_id modelcompound - ID of model compound in biomass reaction
float coefficient - coefficient of compound in biomass reaction
string name - name of compound in biomass reaction


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (modelcompound) a modelcompound_id
1: (coefficient) a float
2: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (modelcompound) a modelcompound_id
1: (coefficient) a float
2: (name) a string


=end text

=back



=head2 ModelBiomass

=over 4



=item Description

Data structures for a reaction in a model

biomass_id id - ID of biomass reaction
string name - name of biomass reaction
string definition - stoichiometric equation of biomass reaction in terms of compound names
list<BiomassCompound> biomass_compounds - list of compounds in biomass reaction


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a biomass_id
name has a value which is a string
definition has a value which is a string
biomass_compounds has a value which is a reference to a list where each element is a BiomassCompound

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a biomass_id
name has a value which is a string
definition has a value which is a string
biomass_compounds has a value which is a reference to a list where each element is a BiomassCompound


=end text

=back



=head2 FBAMeta

=over 4



=item Description

Data structures for a reaction in a model

fba_id id - ID of the FBA object
workspace_id workspace - ID of the workspace containing the FBA object
media_id media - ID of the media the FBA was performed in
workspace_id media_workspace - ID of the workspace containing the media formulation
float objective - optimized objective value of the FBA study
list<feature_id> ko - list of genes knocked out in the FBA study


=item Definition

=begin html

<pre>
a reference to a list containing 6 items:
0: (id) a fba_id
1: (workspace) a workspace_id
2: (media) a media_id
3: (media_workspace) a workspace_id
4: (objective) a float
5: (ko) a reference to a list where each element is a feature_id

</pre>

=end html

=begin text

a reference to a list containing 6 items:
0: (id) a fba_id
1: (workspace) a workspace_id
2: (media) a media_id
3: (media_workspace) a workspace_id
4: (objective) a float
5: (ko) a reference to a list where each element is a feature_id


=end text

=back



=head2 GapGenMeta

=over 4



=item Description

Metadata object providing a summary of a gapgen simulation

gapgen_id id - ID of gapgen study object
workspace_id workspace - workspace containing gapgen study
media_id media - media formulation for gapgen study
workspace_id media_workspace - ID of the workspace containing the media formulation
bool done - boolean indicating if gapgen study is complete
list<feature_id> ko - list of genes knocked out in gapgen study


=item Definition

=begin html

<pre>
a reference to a list containing 6 items:
0: (id) a gapgen_id
1: (workspace) a workspace_id
2: (media) a media_id
3: (media_workspace) a workspace_id
4: (done) a bool
5: (ko) a reference to a list where each element is a feature_id

</pre>

=end html

=begin text

a reference to a list containing 6 items:
0: (id) a gapgen_id
1: (workspace) a workspace_id
2: (media) a media_id
3: (media_workspace) a workspace_id
4: (done) a bool
5: (ko) a reference to a list where each element is a feature_id


=end text

=back



=head2 GapFillMeta

=over 4



=item Description

Metadata object providing a summary of a gapfilling simulation

gapfill_id id - ID of gapfill study object
workspace_id workspace - workspace containing gapfill study
media_id media - media formulation for gapfill study
workspace_id media_workspace - ID of the workspace containing the media formulation
bool done - boolean indicating if gapfill study is complete
list<feature_id> ko - list of genes knocked out in gapfill study


=item Definition

=begin html

<pre>
a reference to a list containing 6 items:
0: (id) a gapfill_id
1: (workspace) a workspace_id
2: (media) a media_id
3: (media_workspace) a workspace_id
4: (done) a bool
5: (ko) a reference to a list where each element is a feature_id

</pre>

=end html

=begin text

a reference to a list containing 6 items:
0: (id) a gapfill_id
1: (workspace) a workspace_id
2: (media) a media_id
3: (media_workspace) a workspace_id
4: (done) a bool
5: (ko) a reference to a list where each element is a feature_id


=end text

=back



=head2 FBAModel

=over 4



=item Description

Data structure holding data for metabolic model

fbamodel_id id - ID of model
workspace_id workspace - workspace containing model
genome_id genome - ID of associated genome
workspace_id genome_workspace - workspace with associated genome
mapping_id map - ID of associated mapping database
workspace_id map_workspace - workspace with associated mapping database
biochemistry_id biochemistry - ID of associated biochemistry database
workspace_id biochemistry_workspace - workspace with associated biochemistry database
string name - name of the model
string type - type of model (e.g. single genome, community)
string status - status of model (e.g. under construction)
list<ModelBiomass> biomasses - list of biomass reactions in model
list<ModelCompartment> compartments - list of compartments in model
list<ModelReaction> reactions - list of reactions in model
list<ModelCompound> compounds - list of compounds in model
list<FBAMeta> fbas - list of flux balance analysis studies for model
list<GapFillMeta> integrated_gapfillings - list of integrated gapfilling solutions
list<GapFillMeta> unintegrated_gapfillings - list of unintegrated gapfilling solutions
list<GapGenMeta> integrated_gapgenerations - list of integrated gapgen solutions
list<GapGenMeta> unintegrated_gapgenerations - list of unintegrated gapgen solutions


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a fbamodel_id
workspace has a value which is a workspace_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
map has a value which is a mapping_id
map_workspace has a value which is a workspace_id
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
name has a value which is a string
type has a value which is a string
status has a value which is a string
biomasses has a value which is a reference to a list where each element is a ModelBiomass
compartments has a value which is a reference to a list where each element is a ModelCompartment
reactions has a value which is a reference to a list where each element is a ModelReaction
compounds has a value which is a reference to a list where each element is a ModelCompound
fbas has a value which is a reference to a list where each element is an FBAMeta
integrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
unintegrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
integrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta
unintegrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a fbamodel_id
workspace has a value which is a workspace_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
map has a value which is a mapping_id
map_workspace has a value which is a workspace_id
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
name has a value which is a string
type has a value which is a string
status has a value which is a string
biomasses has a value which is a reference to a list where each element is a ModelBiomass
compartments has a value which is a reference to a list where each element is a ModelCompartment
reactions has a value which is a reference to a list where each element is a ModelReaction
compounds has a value which is a reference to a list where each element is a ModelCompound
fbas has a value which is a reference to a list where each element is an FBAMeta
integrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
unintegrated_gapfillings has a value which is a reference to a list where each element is a GapFillMeta
integrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta
unintegrated_gapgenerations has a value which is a reference to a list where each element is a GapGenMeta


=end text

=back



=head2 GeneAssertion

=over 4



=item Description

********************************************************************************
    Flux Balance Analysis type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: (feature) a feature_id
1: (growthFraction) a float
2: (growth) a float
3: (isEssential) a bool

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: (feature) a feature_id
1: (growthFraction) a float
2: (growth) a float
3: (isEssential) a bool


=end text

=back



=head2 CompoundFlux

=over 4



=item Description

Compound variable in FBA solution

modelcompound_id compound - ID of compound in model in FBA solution
float value - flux uptake of compound in FBA solution
float upperBound - maximum uptake of compoundin FBA simulation
float lowerBound - minimum uptake of compoundin FBA simulation
float max - maximum uptake of compoundin FBA simulation
float min - minimum uptake of compoundin FBA simulation
string type - type of compound variable
string name - name of compound


=item Definition

=begin html

<pre>
a reference to a list containing 8 items:
0: (compound) a modelcompound_id
1: (value) a float
2: (upperBound) a float
3: (lowerBound) a float
4: (max) a float
5: (min) a float
6: (type) a string
7: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 8 items:
0: (compound) a modelcompound_id
1: (value) a float
2: (upperBound) a float
3: (lowerBound) a float
4: (max) a float
5: (min) a float
6: (type) a string
7: (name) a string


=end text

=back



=head2 ReactionFlux

=over 4



=item Description

Reaction variable in FBA solution

modelreaction_id reaction - ID of reaction in model in FBA solution
float value - flux through reaction in FBA solution
float upperBound - maximum flux through reaction in FBA simulation
float lowerBound -  minimum flux through reaction in FBA simulation
float max - maximum flux through reaction in FBA simulation
float min - minimum flux through reaction in FBA simulation
string type - type of reaction variable
string definition - stoichiometry of solution reaction in terms of compound names


=item Definition

=begin html

<pre>
a reference to a list containing 8 items:
0: (reaction) a modelreaction_id
1: (value) a float
2: (upperBound) a float
3: (lowerBound) a float
4: (max) a float
5: (min) a float
6: (type) a string
7: (definition) a string

</pre>

=end html

=begin text

a reference to a list containing 8 items:
0: (reaction) a modelreaction_id
1: (value) a float
2: (upperBound) a float
3: (lowerBound) a float
4: (max) a float
5: (min) a float
6: (type) a string
7: (definition) a string


=end text

=back



=head2 MetaboliteProduction

=over 4



=item Description

Maximum production of compound in FBA simulation

float maximumProduction - maximum production of compound
modelcompound_id modelcompound - ID of compound with production maximized
string name - name of compound with simulated production


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (maximumProduction) a float
1: (modelcompound) a modelcompound_id
2: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (maximumProduction) a float
1: (modelcompound) a modelcompound_id
2: (name) a string


=end text

=back



=head2 MinimalMediaPrediction

=over 4



=item Description

Data structures for gapfilling solution

list<compound_id> optionalNutrients - list of optional nutrients
list<compound_id> essentialNutrients - list of essential nutrients


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
optionalNutrients has a value which is a reference to a list where each element is a compound_id
essentialNutrients has a value which is a reference to a list where each element is a compound_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
optionalNutrients has a value which is a reference to a list where each element is a compound_id
essentialNutrients has a value which is a reference to a list where each element is a compound_id


=end text

=back



=head2 bound

=over 4



=item Description

Term of constraint or objective in FBA simulation

float min - minimum value of custom bound
float max - maximum value of custom bound
string varType - type of variable for custom bound
string variable - variable ID for custom bound


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: (min) a float
1: (max) a float
2: (varType) a string
3: (variable) a string

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: (min) a float
1: (max) a float
2: (varType) a string
3: (variable) a string


=end text

=back



=head2 term

=over 4



=item Description

Term of constraint or objective in FBA simulation

float coefficient - coefficient of term in objective or constraint
string varType - type of variable for term in objective or constraint
string variable - variable ID for term in objective or constraint


=item Definition

=begin html

<pre>
a reference to a list containing 3 items:
0: (coefficient) a float
1: (varType) a string
2: (variable) a string

</pre>

=end html

=begin text

a reference to a list containing 3 items:
0: (coefficient) a float
1: (varType) a string
2: (variable) a string


=end text

=back



=head2 constraint

=over 4



=item Description

Custom constraint in FBA simulation

float rhs - right hand side of custom constraint
string sign - sign of custom constraint (e.g. <, >)
list<term> terms - terms in custom constraint
string name - name of custom constraint


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: (rhs) a float
1: (sign) a string
2: (terms) a reference to a list where each element is a term
3: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: (rhs) a float
1: (sign) a string
2: (terms) a reference to a list where each element is a term
3: (name) a string


=end text

=back



=head2 FBAFormulation

=over 4



=item Description

Data structures for gapfilling solution

media_id media - ID of media formulation to be used
list<compound_id> additionalcpds - list of additional compounds to allow update
promconstraint_id promconstraint - ID of promconstraint
workspace_id promconstraint_workspace - workspace containing promconstraint
sample_id eflux_sample - ID of gene expression sample to run eflux
series_id eflux_series - ID of series that a sample belongs to.
workspace_id eflux_workspace - workspace containing gene expression sample series for eflux
workspace_id media_workspace - workspace containing media for FBA study
float objfraction - fraction of objective to use for constraints
bool allreversible - flag indicating if all reactions should be reversible
bool maximizeObjective - flag indicating if objective should be maximized
list<term> objectiveTerms - list of terms of objective function
list<feature_id> geneko - list of gene knockouts
list<reaction_id> rxnko - list of reaction knockouts
list<bound> bounds - list of custom bounds
list<constraint> constraints - list of custom constraints
mapping<string,float> uptakelim - hash of maximum uptake for elements
float defaultmaxflux - default maximum intracellular flux
float defaultminuptake - default minimum nutrient uptake
float defaultmaxuptake - default maximum nutrient uptake
bool simplethermoconst - flag indicating if simple thermodynamic constraints should be used
bool thermoconst - flag indicating if thermodynamic constraints should be used
bool nothermoerror - flag indicating if no error should be allowed in thermodynamic constraints
bool minthermoerror - flag indicating if error should be minimized in thermodynamic constraints


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
media has a value which is a media_id
additionalcpds has a value which is a reference to a list where each element is a compound_id
promconstraint has a value which is a promconstraint_id
promconstraint_workspace has a value which is a workspace_id
eflux_sample has a value which is a sample_id
eflux_series has a value which is a series_id
eflux_workspace has a value which is a workspace_id
media_workspace has a value which is a workspace_id
objfraction has a value which is a float
allreversible has a value which is a bool
maximizeObjective has a value which is a bool
objectiveTerms has a value which is a reference to a list where each element is a term
geneko has a value which is a reference to a list where each element is a feature_id
rxnko has a value which is a reference to a list where each element is a reaction_id
bounds has a value which is a reference to a list where each element is a bound
constraints has a value which is a reference to a list where each element is a constraint
uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
defaultmaxflux has a value which is a float
defaultminuptake has a value which is a float
defaultmaxuptake has a value which is a float
simplethermoconst has a value which is a bool
thermoconst has a value which is a bool
nothermoerror has a value which is a bool
minthermoerror has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
media has a value which is a media_id
additionalcpds has a value which is a reference to a list where each element is a compound_id
promconstraint has a value which is a promconstraint_id
promconstraint_workspace has a value which is a workspace_id
eflux_sample has a value which is a sample_id
eflux_series has a value which is a series_id
eflux_workspace has a value which is a workspace_id
media_workspace has a value which is a workspace_id
objfraction has a value which is a float
allreversible has a value which is a bool
maximizeObjective has a value which is a bool
objectiveTerms has a value which is a reference to a list where each element is a term
geneko has a value which is a reference to a list where each element is a feature_id
rxnko has a value which is a reference to a list where each element is a reaction_id
bounds has a value which is a reference to a list where each element is a bound
constraints has a value which is a reference to a list where each element is a constraint
uptakelim has a value which is a reference to a hash where the key is a string and the value is a float
defaultmaxflux has a value which is a float
defaultminuptake has a value which is a float
defaultmaxuptake has a value which is a float
simplethermoconst has a value which is a bool
thermoconst has a value which is a bool
nothermoerror has a value which is a bool
minthermoerror has a value which is a bool


=end text

=back



=head2 FBA

=over 4



=item Description

Data structures for gapfilling solution

fba_id id - ID of FBA study
workspace_id workspace - workspace containing FBA study
        fbamodel_id model - ID of model FBA was run on
        workspace_id model_workspace - workspace with FBA model
        float objective - objective value of FBA study
        bool isComplete - flag indicating if job is complete
FBAFormulation formulation - specs for FBA study
list<MinimalMediaPrediction> minimalMediaPredictions - list of minimal media formulation
list<MetaboliteProduction> metaboliteProductions - list of biomass component production
list<ReactionFlux> reactionFluxes - list of reaction fluxes
list<CompoundFlux> compoundFluxes - list of compound uptake fluxes
list<GeneAssertion> geneAssertions - list of gene assertions


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a fba_id
workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
objective has a value which is a float
isComplete has a value which is a bool
formulation has a value which is an FBAFormulation
minimalMediaPredictions has a value which is a reference to a list where each element is a MinimalMediaPrediction
metaboliteProductions has a value which is a reference to a list where each element is a MetaboliteProduction
reactionFluxes has a value which is a reference to a list where each element is a ReactionFlux
compoundFluxes has a value which is a reference to a list where each element is a CompoundFlux
geneAssertions has a value which is a reference to a list where each element is a GeneAssertion

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a fba_id
workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
objective has a value which is a float
isComplete has a value which is a bool
formulation has a value which is an FBAFormulation
minimalMediaPredictions has a value which is a reference to a list where each element is a MinimalMediaPrediction
metaboliteProductions has a value which is a reference to a list where each element is a MetaboliteProduction
reactionFluxes has a value which is a reference to a list where each element is a ReactionFlux
compoundFluxes has a value which is a reference to a list where each element is a CompoundFlux
geneAssertions has a value which is a reference to a list where each element is a GeneAssertion


=end text

=back



=head2 GapfillingFormulation

=over 4



=item Description

********************************************************************************
    Gapfilling type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
formulation has a value which is an FBAFormulation
num_solutions has a value which is an int
nomediahyp has a value which is a bool
nobiomasshyp has a value which is a bool
nogprhyp has a value which is a bool
nopathwayhyp has a value which is a bool
allowunbalanced has a value which is a bool
activitybonus has a value which is a float
drainpen has a value which is a float
directionpen has a value which is a float
nostructpen has a value which is a float
unfavorablepen has a value which is a float
nodeltagpen has a value which is a float
biomasstranspen has a value which is a float
singletranspen has a value which is a float
transpen has a value which is a float
blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
allowedcmps has a value which is a reference to a list where each element is a compartment_id
probabilisticAnnotation has a value which is a probanno_id
probabilisticAnnotation_workspace has a value which is a workspace_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
formulation has a value which is an FBAFormulation
num_solutions has a value which is an int
nomediahyp has a value which is a bool
nobiomasshyp has a value which is a bool
nogprhyp has a value which is a bool
nopathwayhyp has a value which is a bool
allowunbalanced has a value which is a bool
activitybonus has a value which is a float
drainpen has a value which is a float
directionpen has a value which is a float
nostructpen has a value which is a float
unfavorablepen has a value which is a float
nodeltagpen has a value which is a float
biomasstranspen has a value which is a float
singletranspen has a value which is a float
transpen has a value which is a float
blacklistedrxns has a value which is a reference to a list where each element is a reaction_id
gauranteedrxns has a value which is a reference to a list where each element is a reaction_id
allowedcmps has a value which is a reference to a list where each element is a compartment_id
probabilisticAnnotation has a value which is a probanno_id
probabilisticAnnotation_workspace has a value which is a workspace_id


=end text

=back



=head2 reactionAddition

=over 4



=item Description

Reactions removed in gapgen solution

modelreaction_id reaction - ID of the removed reaction
string direction - direction of reaction removed in gapgen solution
string equation - stoichiometry of removed reaction in terms of compound IDs
string definition - stoichiometry of removed reaction in terms of compound names


=item Definition

=begin html

<pre>
a reference to a list containing 5 items:
0: (reaction) a reaction_id
1: (direction) a string
2: (compartment_id) a string
3: (equation) a string
4: (definition) a string

</pre>

=end html

=begin text

a reference to a list containing 5 items:
0: (reaction) a reaction_id
1: (direction) a string
2: (compartment_id) a string
3: (equation) a string
4: (definition) a string


=end text

=back



=head2 biomassRemoval

=over 4



=item Description

Biomass component removed in gapfill solution

compound_id compound - ID of biomass component removed
string name - name of biomass component removed


=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string


=end text

=back



=head2 mediaAddition

=over 4



=item Description

Media component added in gapfill solution

compound_id compound - ID of media component added
string name - name of media component added


=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string


=end text

=back



=head2 GapFillSolution

=over 4



=item Description

Data structures for gapfilling solution

gapfillsolution_id id - ID of gapfilling solution
        float objective - cost of gapfilling solution
list<biomassRemoval> biomassRemovals - list of biomass components being removed
list<mediaAddition> mediaAdditions - list of media components being added
list<reactionAddition> reactionAdditions - list of reactions being added


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a gapfillsolution_id
objective has a value which is a float
integrated has a value which is a bool
biomassRemovals has a value which is a reference to a list where each element is a biomassRemoval
mediaAdditions has a value which is a reference to a list where each element is a mediaAddition
reactionAdditions has a value which is a reference to a list where each element is a reactionAddition

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a gapfillsolution_id
objective has a value which is a float
integrated has a value which is a bool
biomassRemovals has a value which is a reference to a list where each element is a biomassRemoval
mediaAdditions has a value which is a reference to a list where each element is a mediaAddition
reactionAdditions has a value which is a reference to a list where each element is a reactionAddition


=end text

=back



=head2 GapFill

=over 4



=item Description

Data structures for gapfilling analysis

gapfill_id id - ID of gapfill analysis
workspace_id workspace - workspace containing gapfill analysis
fbamodel_id model - ID of model being gapfilled
        workspace_id model_workspace - workspace containing model
        bool isComplete - indicates if gapfilling is complete
GapfillingFormulation formulation - formulation of gapfilling analysis
list<GapFillSolution> solutions - list of gapfilling solutions


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a gapfill_id
workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
isComplete has a value which is a bool
formulation has a value which is a GapfillingFormulation
solutions has a value which is a reference to a list where each element is a GapFillSolution

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a gapfill_id
workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
isComplete has a value which is a bool
formulation has a value which is a GapfillingFormulation
solutions has a value which is a reference to a list where each element is a GapFillSolution


=end text

=back



=head2 GapgenFormulation

=over 4



=item Description

********************************************************************************
    Gap Generation type definition
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
formulation has a value which is an FBAFormulation
refmedia has a value which is a media_id
refmedia_workspace has a value which is a workspace_id
num_solutions has a value which is an int
nomediahyp has a value which is a bool
nobiomasshyp has a value which is a bool
nogprhyp has a value which is a bool
nopathwayhyp has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
formulation has a value which is an FBAFormulation
refmedia has a value which is a media_id
refmedia_workspace has a value which is a workspace_id
num_solutions has a value which is an int
nomediahyp has a value which is a bool
nobiomasshyp has a value which is a bool
nogprhyp has a value which is a bool
nopathwayhyp has a value which is a bool


=end text

=back



=head2 reactionRemoval

=over 4



=item Description

Reactions removed in gapgen solution

modelreaction_id reaction - ID of the removed reaction
string direction - direction of reaction removed in gapgen solution
string equation - stoichiometry of removed reaction in terms of compound IDs
string definition - stoichiometry of removed reaction in terms of compound names


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: (reaction) a modelreaction_id
1: (direction) a string
2: (equation) a string
3: (definition) a string

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: (reaction) a modelreaction_id
1: (direction) a string
2: (equation) a string
3: (definition) a string


=end text

=back



=head2 biomassAddition

=over 4



=item Description

Compounds added to biomass in gapgen solution

compound_id compound - ID of biomass compound added
string name - name of biomass compound added


=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string


=end text

=back



=head2 mediaRemoval

=over 4



=item Description

Media components removed in gapgen solution

compound_id compound - ID of media component removed
string name - name of media component removed


=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (compound) a compound_id
1: (name) a string


=end text

=back



=head2 GapgenSolution

=over 4



=item Description

Data structures for gap generation solution

gapgensolution_id id - ID of gapgen solution
        float objective - cost of gapgen solution
list<biomassAddition> biomassAdditions - list of components added to biomass
list<mediaRemoval> mediaRemovals - list of media components removed
list<reactionRemoval> reactionRemovals - list of reactions removed


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a gapgensolution_id
objective has a value which is a float
biomassAdditions has a value which is a reference to a list where each element is a biomassAddition
mediaRemovals has a value which is a reference to a list where each element is a mediaRemoval
reactionRemovals has a value which is a reference to a list where each element is a reactionRemoval

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a gapgensolution_id
objective has a value which is a float
biomassAdditions has a value which is a reference to a list where each element is a biomassAddition
mediaRemovals has a value which is a reference to a list where each element is a mediaRemoval
reactionRemovals has a value which is a reference to a list where each element is a reactionRemoval


=end text

=back



=head2 GapGen

=over 4



=item Description

Data structures for gap generation analysis

gapgen_id id - ID of gapgen object
workspace_id workspace - workspace containing gapgen object
fbamodel_id model - ID of model being gap generated
        workspace_id model_workspace - workspace containing model
        bool isComplete - flag indicating if gap generation is complete
GapgenFormulation formulation - formulation of gap generation analysis
list<GapgenSolution> solutions - list of gap generation solutions


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a gapgen_id
workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
isComplete has a value which is a bool
formulation has a value which is a GapgenFormulation
solutions has a value which is a reference to a list where each element is a GapgenSolution

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a gapgen_id
workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
isComplete has a value which is a bool
formulation has a value which is a GapgenFormulation
solutions has a value which is a reference to a list where each element is a GapgenSolution


=end text

=back



=head2 Phenotype

=over 4



=item Description

********************************************************************************
    Phenotype type definitions
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a list containing 6 items:
0: (geneKO) a reference to a list where each element is a feature_id
1: (baseMedia) a media_id
2: (media_workspace) a workspace_id
3: (additionalCpd) a reference to a list where each element is a compound_id
4: (normalizedGrowth) a float
5: (label) a string

</pre>

=end html

=begin text

a reference to a list containing 6 items:
0: (geneKO) a reference to a list where each element is a feature_id
1: (baseMedia) a media_id
2: (media_workspace) a workspace_id
3: (additionalCpd) a reference to a list where each element is a compound_id
4: (normalizedGrowth) a float
5: (label) a string


=end text

=back



=head2 PhenotypeSet

=over 4



=item Description

Data structures for set of growth phenotype observations

phenotype_set_id id - ID of the phenotype set
genome_id genome - ID of the genome for the strain used with the growth phenotypes
workspace_id genome_workspace - workspace containing the genome object
list<Phenotype> phenotypes - list of phenotypes included in the phenotype set
string importErrors - list of errors encountered during the import of the phenotype set
string source - source of the phenotype set
string name - name of the phenotype set


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a phenotype_set_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
phenotypes has a value which is a reference to a list where each element is a Phenotype
source has a value which is a string
name has a value which is a string
importErrors has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a phenotype_set_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
phenotypes has a value which is a reference to a list where each element is a Phenotype
source has a value which is a string
name has a value which is a string
importErrors has a value which is a string


=end text

=back



=head2 phenotypeSimulationSet_id

=over 4



=item Description

ID of the phenotype simulation object


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 PhenotypeSimulation

=over 4



=item Description

Data structures for a phenotype simulation

Phenotype phenotypeData - actual phenotype data simulated
float simulatedGrowth - actual simulated growth rate
float simulatedGrowthFraction - fraction of wildtype simulated growth rate
string phenoclass - class of the phenotype simulation (i.e. 'CP' - correct positive, 'CN' - correct negative, 'FP' - false positive, 'FN' - false negative)


=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: (phenotypeData) a Phenotype
1: (simulatedGrowth) a float
2: (simulatedGrowthFraction) a float
3: (phenoclass) a string

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: (phenotypeData) a Phenotype
1: (simulatedGrowth) a float
2: (simulatedGrowthFraction) a float
3: (phenoclass) a string


=end text

=back



=head2 PhenotypeSimulationSet

=over 4



=item Description

Data structures for phenotype simulations of a set of phenotype data

phenotypeSimulationSet_id id - ID for the phenotype simulation set object
fbamodel_id model - ID of the model used to simulate all phenotypes
workspace_id model_workspace - workspace containing the model used for the simulation
phenotype_set_id phenotypeSet - set of observed phenotypes that were simulated
list<PhenotypeSimulation> phenotypeSimulations - list of simulated phenotypes


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a phenotypeSimulationSet_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
phenotypeSet has a value which is a phenotype_set_id
phenotypeSimulations has a value which is a reference to a list where each element is a PhenotypeSimulation

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a phenotypeSimulationSet_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
phenotypeSet has a value which is a phenotype_set_id
phenotypeSimulations has a value which is a reference to a list where each element is a PhenotypeSimulation


=end text

=back



=head2 reactionSpecification

=over 4



=item Description

Data structure for holding gapfill or gapgen solution reaction information

string direction - direction of gapfilled or gapgen reaction
string reactionID - ID of gapfilled or gapgen reaction


=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (direction) a string
1: (reactionID) a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (direction) a string
1: (reactionID) a string


=end text

=back



=head2 PhenotypeSensitivityAnalysis

=over 4



=item Description

list<string id, string solutionIndex, list<reactionSpecification> reactionList, list<string> biomassEdits,list<tuple<float simulatedGrowth,float simulatedGrowthFraction,string phenoclass>> PhenotypeSimulations> reconciliationSolutionSimulations;


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
phenotypes has a value which is a reference to a list where each element is a Phenotype
wildtypePhenotypeSimulations has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (simulatedGrowth) a float
1: (simulatedGrowthFraction) a float
2: (phenoclass) a string


</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
phenotypes has a value which is a reference to a list where each element is a Phenotype
wildtypePhenotypeSimulations has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (simulatedGrowth) a float
1: (simulatedGrowthFraction) a float
2: (phenoclass) a string



=end text

=back



=head2 job_id

=over 4



=item Description

********************************************************************************
    Job object type definitions
   	********************************************************************************


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 CommandArguments

=over 4



=item Description

Object to hold the arguments to be submitted to the post process command


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
auth has a value which is a string


=end text

=back



=head2 clusterjob

=over 4



=item Description

Object to hold data required to run cluster job


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
auth has a value which is a string


=end text

=back



=head2 JobObject

=over 4



=item Description

Data structures for a job object

job_id id - ID of the job object
string type - type of the job
string auth - authentication token of job owner
string status - current status of job
mapping<string,string> jobdata;
string queuetime - time when job was queued
string starttime - time when job started running
string completetime - time when the job was completed
string owner - owner of the job
string queuecommand - command used to queue job


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a job_id
type has a value which is a string
auth has a value which is a string
status has a value which is a string
jobdata has a value which is a reference to a hash where the key is a string and the value is a string
queuetime has a value which is a string
starttime has a value which is a string
completetime has a value which is a string
owner has a value which is a string
queuecommand has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a job_id
type has a value which is a string
auth has a value which is a string
status has a value which is a string
jobdata has a value which is a reference to a hash where the key is a string and the value is a string
queuetime has a value which is a string
starttime has a value which is a string
completetime has a value which is a string
owner has a value which is a string
queuecommand has a value which is a string


=end text

=back



=head2 ETCNodes

=over 4



=item Description

********************************************************************************
    ETC object type definitions
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
resp has a value which is a string
y has a value which is an int
x has a value which is an int
width has a value which is an int
height has a value which is an int
shape has a value which is a string
label has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
resp has a value which is a string
y has a value which is an int
x has a value which is an int
width has a value which is an int
height has a value which is an int
shape has a value which is a string
label has a value which is a string


=end text

=back



=head2 ETCDiagramSpecs

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
nodes has a value which is a reference to a list where each element is an ETCNodes
media has a value which is a string
growth has a value which is a string
organism has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
nodes has a value which is a reference to a list where each element is an ETCNodes
media has a value which is a string
growth has a value which is a string
organism has a value which is a string


=end text

=back



=head2 TemplateReactions

=over 4



=item Description

********************************************************************************
	  AutoRecon type definitions
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
reaction has a value which is a reaction_id
direction has a value which is a string
equation has a value which is a string
compartment has a value which is a compartment_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
reaction has a value which is a reaction_id
direction has a value which is a string
equation has a value which is a string
compartment has a value which is a compartment_id


=end text

=back



=head2 ComplexReactions

=over 4



=item Description

Information on complexes in a template model

        complex_id complex - ID of the associated complex
        list<TemplateReactions> reactions - List of template models associated with complex


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
complex has a value which is a complex_id
name has a value which is a string
reactions has a value which is a reference to a list where each element is a TemplateReactions

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
complex has a value which is a complex_id
name has a value which is a string
reactions has a value which is a reference to a list where each element is a TemplateReactions


=end text

=back



=head2 RoleComplexReactions

=over 4



=item Description

Information on complexes in a template model

        complex_id complex - ID of the associated complex
        list<TemplateReactions> reactions - List of template models associated with complex


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
role has a value which is a role_id
name has a value which is a string
complexes has a value which is a reference to a list where each element is a ComplexReactions

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
role has a value which is a role_id
name has a value which is a string
complexes has a value which is a reference to a list where each element is a ComplexReactions


=end text

=back



=head2 ReactionDefinition

=over 4



=item Description

Reaction definition

        reaction_id id - ID of reaction
        string name - name of reaction
        string definition - stoichiometric equation of reaction in terms of compound names


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a reaction_id
name has a value which is a string
definition has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a reaction_id
name has a value which is a string
definition has a value which is a string


=end text

=back



=head2 ReactionSynonyms

=over 4



=item Description

Reaction synonyms

        reaction_id primary - ID of primary reaction
        list<ReactionDefinition> synonyms - list of synonym reactions to the primary reaction (including itself)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
primary has a value which is a reaction_id
synonyms has a value which is a reference to a list where each element is a ReactionDefinition

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
primary has a value which is a reaction_id
synonyms has a value which is a reference to a list where each element is a ReactionDefinition


=end text

=back



=head2 ReactionSynonymsObject

=over 4



=item Description

Reaction synonyms object

        int version - version number of object
        biochemistry_id biochemistry - ID of associated biochemistry database
        workspace_id biochemistry_workspace - workspace with associated biochemistry database
        list<ReactionSynonyms> synonym_list - list of all reaction synonyms from a biochemistry database
        list<ReactionDefinition> excluded_list - list of reactions excluded because all compounds are cofactors


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
version has a value which is an int
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
synonyms_list has a value which is a reference to a list where each element is a ReactionSynonyms
excluded_list has a value which is a reference to a list where each element is a ReactionDefinition

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
version has a value which is an int
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
synonyms_list has a value which is a reference to a list where each element is a ReactionSynonyms
excluded_list has a value which is a reference to a list where each element is a ReactionDefinition


=end text

=back



=head2 get_models_params

=over 4



=item Description

********************************************************************************
    Function definitions relating to data retrieval for Model Objects
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
models has a value which is a reference to a list where each element is a fbamodel_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
models has a value which is a reference to a list where each element is a fbamodel_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string


=end text

=back



=head2 get_fbas_params

=over 4



=item Description

Input parameters for the "get_fbas" function.

        list<fba_id> fbas - a list of the FBA study IDs for the FBA studies to be returned (a required argument)
        list<workspace_id> workspaces - a list of the workspaces contianing the FBA studies to be returned (a required argument)
string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
fbas has a value which is a reference to a list where each element is a fba_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
fbas has a value which is a reference to a list where each element is a fba_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string


=end text

=back



=head2 get_gapfills_params

=over 4



=item Description

Input parameters for the "get_gapfills" function.

        list<gapfill_id> gapfills - a list of the gapfill study IDs for the gapfill studies to be returned (a required argument)
        list<workspace_id> workspaces - a list of the workspaces contianing the gapfill studies to be returned (a required argument)
string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
gapfills has a value which is a reference to a list where each element is a gapfill_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
gapfills has a value which is a reference to a list where each element is a gapfill_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string


=end text

=back



=head2 get_gapgens_params

=over 4



=item Description

Input parameters for the "get_gapgens" function.

        list<gapgen_id> gapgens - a list of the gapgen study IDs for the gapgen studies to be returned (a required argument)
        list<workspace_id> workspaces - a list of the workspaces contianing the gapgen studies to be returned (a required argument)
string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
gapgens has a value which is a reference to a list where each element is a gapgen_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
gapgens has a value which is a reference to a list where each element is a gapgen_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string
id_type has a value which is a string


=end text

=back



=head2 get_reactions_params

=over 4



=item Description

Input parameters for the "get_reactions" function.

        list<reaction_id> reactions - a list of the reaction IDs for the reactions to be returned (a required argument)
        string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
reactions has a value which is a reference to a list where each element is a reaction_id
auth has a value which is a string
id_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
reactions has a value which is a reference to a list where each element is a reaction_id
auth has a value which is a string
id_type has a value which is a string


=end text

=back



=head2 get_compounds_params

=over 4



=item Description

Input parameters for the "get_compounds" function.        
list<compound_id> compounds - a list of the compound IDs for the compounds to be returned (a required argument)
string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
compounds has a value which is a reference to a list where each element is a compound_id
auth has a value which is a string
id_type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
compounds has a value which is a reference to a list where each element is a compound_id
auth has a value which is a string
id_type has a value which is a string


=end text

=back



=head2 get_alias_params

=over 4



=item Description

Input parameters for the get_alias function

                string object_type    - The type of object (e.g. Compound or Reaction)
                string input_id_type - The type (e.g. ModelSEED) of alias to be inputted
                string output_id_type - The type (e.g. KEGG) of alias to be outputted
                list<string> input_ids - A list of input IDs
                string auth; - The authentication token of the KBase account (optional)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
object_type has a value which is a string
input_id_type has a value which is a string
output_id_type has a value which is a string
input_ids has a value which is a reference to a list where each element is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
object_type has a value which is a string
input_id_type has a value which is a string
output_id_type has a value which is a string
input_ids has a value which is a reference to a list where each element is a string
auth has a value which is a string


=end text

=back



=head2 get_alias_outputs

=over 4



=item Description

Output for get_alias function

              string original_id - The original ID
              list<string> aliases - Aliases for the original ID in the new format


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
original_id has a value which is a string
aliases has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
original_id has a value which is a string
aliases has a value which is a reference to a list where each element is a string


=end text

=back



=head2 get_aliassets_params

=over 4



=item Description

Input parameters for the get_aliassets function

              string auth; - The authentication token of the KBase account (optional)
              string object_type; - The type of object (e.g. Compound or Reaction)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
object_type has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
object_type has a value which is a string
auth has a value which is a string


=end text

=back



=head2 get_media_params

=over 4



=item Description

Input parameters for the "get_media" function.

        list<media_id> medias - a list of the media IDs for the media to be returned (a required argument)
        string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
medias has a value which is a reference to a list where each element is a media_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
medias has a value which is a reference to a list where each element is a media_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string


=end text

=back



=head2 get_biochemistry_params

=over 4



=item Description

Input parameters for the "get_biochemistry" function.

        biochemistry_id biochemistry - ID of the biochemistry database to be returned (a required argument)
        workspace_id biochemistry_workspace - workspace containing the biochemistry database to be returned (a required argument)
        string id_type - the type of ID that should be used in the output data (a optional argument; default is 'ModelSEED')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
id_type has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
id_type has a value which is a string
auth has a value which is a string


=end text

=back



=head2 import_probanno_params

=over 4



=item Description

********************************************************************************
    Code relating to reconstruction of metabolic models
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
probanno has a value which is a probanno_id
workspace has a value which is a workspace_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
annotationProbabilities has a value which is a reference to a list where each element is an annotationProbability
ignore_errors has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
probanno has a value which is a probanno_id
workspace has a value which is a workspace_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
annotationProbabilities has a value which is a reference to a list where each element is an annotationProbability
ignore_errors has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 Genome_uid

=over 4



=item Description

Input parameters for the "genome_object_to_workspace" function.

        Genome_uid uid - ID to use when saving genome to workspace
        GenomeObject genomeobj - full genome typed object to be loaded into the workspace (a required argument)
        workspace_id workspace - ID of the workspace into which the genome typed object is to be loaded (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 genome_object_to_workspace_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
uid has a value which is a Genome_uid
genomeobj has a value which is a GenomeObject
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
uid has a value which is a Genome_uid
genomeobj has a value which is a GenomeObject
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 genome_to_workspace_params

=over 4



=item Description

Input parameters for the "genome_to_workspace" function.

        genome_id genome - ID of the CDM genome that is to be loaded into the workspace (a required argument)
        string sourceLogin - login to pull private genome from source database
        string sourcePassword - password to pull private genome from source database
        string source - Source database for genome (i.e. seed, rast, kbase)
        workspace_id workspace - ID of the workspace into which the genome typed object is to be loaded (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
workspace has a value which is a workspace_id
sourceLogin has a value which is a string
sourcePassword has a value which is a string
source has a value which is a string
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
workspace has a value which is a workspace_id
sourceLogin has a value which is a string
sourcePassword has a value which is a string
source has a value which is a string
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 domains_to_workspace_params

=over 4



=item Description

Input parameters for the "domains_to_workspace" function.

        genome_id genome - ID of the workspace genome to fetch domains for (a required argument)
        string output_id - ID in which the domains are to be saved (default is genome ID plus ".dom.0")
        workspace_id workspace - ID of the workspace into which the domains are to be loaded (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
output_id has a value which is a string
workspace has a value which is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
output_id has a value which is a string
workspace has a value which is a workspace_id
auth has a value which is a string


=end text

=back



=head2 compute_domains_params

=over 4



=item Description

Input parameters for the "compute_domains_params" function.
string genome;
string genome_workspace;
list<tuple<string,string>> proteins;
workspace_id workspace;


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
proteins has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: a string
1: a string

workspace has a value which is a workspace_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
proteins has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: a string
1: a string

workspace has a value which is a workspace_id


=end text

=back



=head2 translation

=over 4



=item Description

A link between a KBase gene ID and the ID for the same gene in another database

        string foreign_id - ID of the gene in another database
        feature_id feature - ID of the gene in KBase


=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: (foreign_id) a string
1: (feature) a feature_id

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: (foreign_id) a string
1: (feature) a feature_id


=end text

=back



=head2 add_feature_translation_params

=over 4



=item Description

Input parameters for the "add_feature_translation" function.

        genome_id genome - ID of the genome into which the new aliases are to be loaded (a required argument)
        workspace_id workspace - ID of the workspace containing the target genome (a required argument)
        list<translation> translations - list of translations between KBase gene IDs and gene IDs in another database (a required argument)
        string id_type - type of the IDs being loaded (e.g. KEGG, NCBI) (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
workspace has a value which is a workspace_id
translations has a value which is a reference to a list where each element is a translation
id_type has a value which is a string
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
workspace has a value which is a workspace_id
translations has a value which is a reference to a list where each element is a translation
id_type has a value which is a string
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 genome_to_fbamodel_params

=over 4



=item Description

Input parameters for the "genome_to_fbamodel" function.

        genome_id genome - ID of the genome for which a model is to be built (a required argument)
        workspace_id genome_workspace - ID of the workspace containing the target genome (an optional argument; default is the workspace argument)
        template_id templatemodel - 
        workspace_id templatemodel_workspace - 
        bool probannoOnly - a boolean indicating if only the probabilistic annotation should be used in building the model (an optional argument; default is '0')
        fbamodel_id model - ID that should be used for the newly constructed model (an optional argument; default is 'undef')
        bool coremodel - indicates that a core model should be constructed instead of a genome scale model (an optional argument; default is '0')
        workspace_id workspace - ID of the workspace where the newly developed model will be stored; also the default assumed workspace for input objects (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
templatemodel has a value which is a template_id
templatemodel_workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
coremodel has a value which is a bool
workspace has a value which is a workspace_id
auth has a value which is a string
fulldb has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
templatemodel has a value which is a template_id
templatemodel_workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
coremodel has a value which is a bool
workspace has a value which is a workspace_id
auth has a value which is a string
fulldb has a value which is a bool


=end text

=back



=head2 translate_fbamodel_params

=over 4



=item Description

Input parameters for the "translate_fbamodel" function.

        gencomp
        gencomp_workspace
        fbamodel_id model;
        fbamodel_id model_workspace;


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
protcomp has a value which is a string
protcomp_workspace has a value which is a string
model has a value which is a string
model_workspace has a value which is a string
workspace has a value which is a workspace_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
protcomp has a value which is a string
protcomp_workspace has a value which is a string
model has a value which is a string
model_workspace has a value which is a string
workspace has a value which is a workspace_id


=end text

=back



=head2 build_pangenome_params

=over 4



=item Description

Input parameters for the "translate_fbamodel" function.

        gencomp
        gencomp_workspace
        fbamodel_id model;
        fbamodel_id model_workspace;


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genomes has a value which is a reference to a list where each element is a string
genome_workspace has a value which is a reference to a list where each element is a string
workspace has a value which is a workspace_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genomes has a value which is a reference to a list where each element is a string
genome_workspace has a value which is a reference to a list where each element is a string
workspace has a value which is a workspace_id


=end text

=back



=head2 heat_map_matrix

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
is_refs has a value which is a bool
labels has a value which is a reference to a list where each element is a string
matrix has a value which is a reference to a list where each element is a reference to a list where each element is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
is_refs has a value which is a bool
labels has a value which is a reference to a list where each element is a string
matrix has a value which is a reference to a list where each element is a reference to a list where each element is a float


=end text

=back



=head2 genome_heatmap_from_pangenome_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
pangenome has a value which is a string
pangenome_workspace has a value which is a string
workspace has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
pangenome has a value which is a string
pangenome_workspace has a value which is a string
workspace has a value which is a string


=end text

=back



=head2 ortholog_data

=over 4



=item Description

gene ID,gene ref,protein sequence,function,score


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
gene_data has a value which is a reference to a list where each element is a reference to a list containing 5 items:
0: a string
1: a string
2: a string
3: a string
4: a float

protein_heatmap has a value which is a heat_map_matrix

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
gene_data has a value which is a reference to a list where each element is a reference to a list containing 5 items:
0: a string
1: a string
2: a string
3: a string
4: a float

protein_heatmap has a value which is a heat_map_matrix


=end text

=back



=head2 ortholog_family_from_pangenome_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
pangenome has a value which is a string
pangenome_workspace has a value which is a string
orthologid has a value which is a string
workspace has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
pangenome has a value which is a string
pangenome_workspace has a value which is a string
orthologid has a value which is a string
workspace has a value which is a string


=end text

=back



=head2 pangenome_to_proteome_comparison_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
pangenome has a value which is a string
pangenome_workspace has a value which is a string
outputid has a value which is a string
workspace has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
pangenome has a value which is a string
pangenome_workspace has a value which is a string
outputid has a value which is a string
workspace has a value which is a string


=end text

=back



=head2 import_fbamodel_params

=over 4



=item Description

Input parameters for the "import_fbamodel" function.

        genome_id genome - ID of the genome for which a model is to be built (a required argument)
        workspace_id genome_workspace - ID of the workspace containing the target genome (an optional argument; default is the workspace argument)
        string biomass - biomass equation for model (an essential argument)
        list<tuple<string id,string direction,string compartment,string gpr> reactions - list of reactions to appear in imported model (an essential argument)
        fbamodel_id model - ID that should be used for the newly imported model (an optional argument; default is 'undef')
        workspace_id workspace - ID of the workspace where the newly developed model will be stored; also the default assumed workspace for input objects (a required argument)
        bool ignore_errors - ignores missing genes or reactions and imports model anyway
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
biomass has a value which is a string
reactions has a value which is a reference to a list where each element is a reference to a list containing 4 items:
0: (id) a string
1: (direction) a string
2: (compartment) a string
3: (gpr) a string

model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
ignore_errors has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
biomass has a value which is a string
reactions has a value which is a reference to a list where each element is a reference to a list containing 4 items:
0: (id) a string
1: (direction) a string
2: (compartment) a string
3: (gpr) a string

model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
ignore_errors has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 export_fbamodel_params

=over 4



=item Description

Input parameters for the "export_fbamodel" function.

        fbamodel_id model - ID of the model to be exported (a required argument)
        workspace_id workspace - workspace containing the model to be exported (a required argument)
        fba_id fba - A FBA object related to the model. (an optional argument)
        string format - format to which the model should be exported (sbml, html, json, readable, cytoseed) (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
fbas has a value which is a reference to a list where each element is a fba_id
format has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
fbas has a value which is a reference to a list where each element is a fba_id
format has a value which is a string
auth has a value which is a string


=end text

=back



=head2 export_object_params

=over 4



=item Description

Input parameters for the "export_object" function.

        workspace_ref reference - reference of object to print in html (a required argument)
        string type - type of the object to be exported (a required argument)
        string format - format to which data should be exported (an optional argument; default is html)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
reference has a value which is a workspace_ref
type has a value which is a string
format has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
reference has a value which is a workspace_ref
type has a value which is a string
format has a value which is a string
auth has a value which is a string


=end text

=back



=head2 export_genome_params

=over 4



=item Description

Input parameters for the "export_genome" function.

        genome_id genome - ID of the genome to be exported (a required argument)
        workspace_id workspace - workspace containing the model to be exported (a required argument)
        string format - format to which the model should be exported (sbml, html, json, readable, cytoseed) (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a genome_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string


=end text

=back



=head2 adjust_model_reaction_params

=over 4



=item Description

Input parameters for the "adjust_model_reaction" function.

        fbamodel_id model - ID of model to be adjusted
        workspace_id workspace - workspace containing model to be adjusted
        list<reaction_id> reaction - List of IDs of reactions to be added, removed, or adjusted
        list<string> direction - directions to set for reactions being added or adjusted
        list<compartment_id> compartment - IDs of compartment containing reaction being added or adjusted
        list<int> compartmentIndex - indexes of compartment containing reaction being altered or adjusted
        list<string> gpr - array specifying gene-protein-reaction association(s)
        bool removeReaction - boolean indicating listed reaction(s) should be removed
        bool addReaction - boolean indicating reaction(s) should be added
        bool overwrite - boolean indicating whether or not to overwrite model object in the workspace
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)

        For all of the lists above, if only one element is specified it is assumed the user wants to apply the same
        to all the listed reactions.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
reaction has a value which is a reference to a list where each element is a reaction_id
direction has a value which is a reference to a list where each element is a string
compartment has a value which is a reference to a list where each element is a compartment_id
compartmentIndex has a value which is a reference to a list where each element is an int
gpr has a value which is a reference to a list where each element is a string
removeReaction has a value which is a bool
addReaction has a value which is a bool
overwrite has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
reaction has a value which is a reference to a list where each element is a reaction_id
direction has a value which is a reference to a list where each element is a string
compartment has a value which is a reference to a list where each element is a compartment_id
compartmentIndex has a value which is a reference to a list where each element is an int
gpr has a value which is a reference to a list where each element is a string
removeReaction has a value which is a bool
addReaction has a value which is a bool
overwrite has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 adjust_biomass_reaction_params

=over 4



=item Description

Input parameters for the "adjust_biomass_reaction" function.

        fbamodel_id model - ID of model to be adjusted
        workspace_id workspace - workspace containing model to be adjusted
        biomass_id biomass - ID of biomass reaction to adjust
        list<float> coefficients - coefficient of biomass compound
        list<compound_id> compounds - ID of biomass compound to adjust in biomass
        list<compartment_id> compartments - ID of compartment containing compound to adjust in biomass
        list<int> compartmentIndecies - index of compartment containing compound to adjust in biomass
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
biomass has a value which is a biomass_id
coefficients has a value which is a reference to a list where each element is a float
compounds has a value which is a reference to a list where each element is a compound_id
compartments has a value which is a reference to a list where each element is a compartment_id
compartmentIndecies has a value which is a reference to a list where each element is an int
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
biomass has a value which is a biomass_id
coefficients has a value which is a reference to a list where each element is a float
compounds has a value which is a reference to a list where each element is a compound_id
compartments has a value which is a reference to a list where each element is a compartment_id
compartmentIndecies has a value which is a reference to a list where each element is an int
auth has a value which is a string


=end text

=back



=head2 addmedia_params

=over 4



=item Description

********************************************************************************
    Code relating to flux balance analysis
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
media has a value which is a media_id
workspace has a value which is a workspace_id
name has a value which is a string
isDefined has a value which is a bool
isMinimal has a value which is a bool
type has a value which is a string
compounds has a value which is a reference to a list where each element is a string
concentrations has a value which is a reference to a list where each element is a float
maxflux has a value which is a reference to a list where each element is a float
minflux has a value which is a reference to a list where each element is a float
overwrite has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
media has a value which is a media_id
workspace has a value which is a workspace_id
name has a value which is a string
isDefined has a value which is a bool
isMinimal has a value which is a bool
type has a value which is a string
compounds has a value which is a reference to a list where each element is a string
concentrations has a value which is a reference to a list where each element is a float
maxflux has a value which is a reference to a list where each element is a float
minflux has a value which is a reference to a list where each element is a float
overwrite has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 export_media_params

=over 4



=item Description

Input parameters for the "export_media" function.

        media_id media - ID of the media to be exported (a required argument)
        workspace_id workspace - workspace containing the media to be exported (a required argument)
        string format - format to which the media should be exported (html, json, readable) (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
media has a value which is a media_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
media has a value which is a media_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string


=end text

=back



=head2 runfba_params

=over 4



=item Description

Input parameters for the "addmedia" function.

        fbamodel_id model - ID of the model that FBA should be run on (a required argument)
        workspace_id model_workspace - workspace where model for FBA should be run (an optional argument; default is the value of the workspace argument)
        FBAFormulation formulation - a hash specifying the parameters for the FBA study (an optional argument)
        bool fva - a flag indicating if flux variability should be run (an optional argument: default is '0')
        bool simulateko - a flag indicating if flux variability should be run (an optional argument: default is '0')
        bool minimizeflux - a flag indicating if flux variability should be run (an optional argument: default is '0')
        bool findminmedia - a flag indicating if flux variability should be run (an optional argument: default is '0')
        string notes - a string of notes to attach to the FBA study (an optional argument; defaul is '')
        fba_id fba - ID under which the FBA results should be saved (an optional argument; defaul is 'undef')
        workspace_id workspace - workspace where FBA results will be saved (a required argument)
        bool add_to_model - a flag indicating if the FBA study should be attached to the model to support viewing results (an optional argument: default is '0')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
fva has a value which is a bool
simulateko has a value which is a bool
minimizeflux has a value which is a bool
findminmedia has a value which is a bool
notes has a value which is a string
fba has a value which is a fba_id
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool
add_to_model has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
fva has a value which is a bool
simulateko has a value which is a bool
minimizeflux has a value which is a bool
findminmedia has a value which is a bool
notes has a value which is a string
fba has a value which is a fba_id
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool
add_to_model has a value which is a bool


=end text

=back



=head2 generate_model_stats_params

=over 4



=item Description

Input parameters for the "generate_model_stats" function.

        fbamodel_id model - ID of the models that FBA should be run on (a required argument)
        workspace_id model_workspace - workspaces where model for FBA should be run (an optional argument; default is the value of the workspace argument)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id


=end text

=back



=head2 subsystem_statistics

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
name has a value which is a string
class has a value which is a string
subclass has a value which is a string
genes has a value which is an int
reactions has a value which is an int
model_genes has a value which is an int
minimal_essential_genes has a value which is an int
complete_essential_genes has a value which is an int
minimal_essential_reactions has a value which is an int
complete_essential_reactions has a value which is an int
minimal_blocked_reactions has a value which is an int
complete_blocked_reactions has a value which is an int
minimal_variable_reactions has a value which is an int
complete_variable_reactions has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
name has a value which is a string
class has a value which is a string
subclass has a value which is a string
genes has a value which is an int
reactions has a value which is an int
model_genes has a value which is an int
minimal_essential_genes has a value which is an int
complete_essential_genes has a value which is an int
minimal_essential_reactions has a value which is an int
complete_essential_reactions has a value which is an int
minimal_blocked_reactions has a value which is an int
complete_blocked_reactions has a value which is an int
minimal_variable_reactions has a value which is an int
complete_variable_reactions has a value which is an int


=end text

=back



=head2 model_statistics

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
total_reactions has a value which is an int
total_genes has a value which is an int
total_compounds has a value which is an int
extracellular_compounds has a value which is an int
intracellular_compounds has a value which is an int
transport_reactions has a value which is an int
subsystem_reactions has a value which is an int
subsystem_genes has a value which is an int
spontaneous_reactions has a value which is an int
reactions_with_genes has a value which is an int
gapfilled_reactions has a value which is an int
model_genes has a value which is an int
minimal_essential_genes has a value which is an int
complete_essential_genes has a value which is an int
minimal_essential_reactions has a value which is an int
complete_essential_reactions has a value which is an int
minimal_blocked_reactions has a value which is an int
complete_blocked_reactions has a value which is an int
minimal_variable_reactions has a value which is an int
complete_variable_reactions has a value which is an int
growth_complete_media has a value which is a bool
growth_minimal_media has a value which is a bool
subsystems has a value which is a reference to a list where each element is a subsystem_statistics

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
total_reactions has a value which is an int
total_genes has a value which is an int
total_compounds has a value which is an int
extracellular_compounds has a value which is an int
intracellular_compounds has a value which is an int
transport_reactions has a value which is an int
subsystem_reactions has a value which is an int
subsystem_genes has a value which is an int
spontaneous_reactions has a value which is an int
reactions_with_genes has a value which is an int
gapfilled_reactions has a value which is an int
model_genes has a value which is an int
minimal_essential_genes has a value which is an int
complete_essential_genes has a value which is an int
minimal_essential_reactions has a value which is an int
complete_essential_reactions has a value which is an int
minimal_blocked_reactions has a value which is an int
complete_blocked_reactions has a value which is an int
minimal_variable_reactions has a value which is an int
complete_variable_reactions has a value which is an int
growth_complete_media has a value which is a bool
growth_minimal_media has a value which is a bool
subsystems has a value which is a reference to a list where each element is a subsystem_statistics


=end text

=back



=head2 minimize_reactions_params

=over 4



=item Description

Input parameters for the "minimize_reactions" function.

        fbamodel_id model - ID of the model that FBA should be run on (a required argument)
        workspace_id model_workspace - workspace where model for FBA should be run (an optional argument; default is the value of the workspace argument)
        workspace_id workspace - workspace where FBA results will be saved (a required argument)
        FBAFormulation formulation - a hash specifying the parameters for the FBA study (an optional argument)
        list<string> reactions - list of model reactions to be minimized (an optional argument)
        bool all_model_reactions - minimize all reactions in the model (default is 'false' unless 'reactions' list is empty)
        mapping<string,float> reaction_costs - hash of costs for each reaction to be minimized (default is '1' for every reaction)
        fba_id output_id - id to which FBA result should be saved


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
reactions has a value which is a reference to a list where each element is a string
all_model_reactions has a value which is a bool
reaction_costs has a value which is a reference to a hash where the key is a string and the value is a float
output_id has a value which is a fba_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
reactions has a value which is a reference to a list where each element is a string
all_model_reactions has a value which is a bool
reaction_costs has a value which is a reference to a hash where the key is a string and the value is a float
output_id has a value which is a fba_id


=end text

=back



=head2 export_fba_params

=over 4



=item Description

Input parameters for the "addmedia" function.

        fba_id fba - ID of the FBA study to be exported (a required argument)
        workspace_id workspace - workspace where FBA study is stored (a required argument)
        string format - format to which the FBA study should be exported (i.e. html, json, readable) (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
fba has a value which is a fba_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
fba has a value which is a fba_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string


=end text

=back



=head2 import_phenotypes_params

=over 4



=item Description

********************************************************************************
    Code relating to phenotype simulation and reconciliation
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
phenotypeSet has a value which is a phenotype_set_id
workspace has a value which is a workspace_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
phenotypes has a value which is a reference to a list where each element is a Phenotype
name has a value which is a string
source has a value which is a string
ignore_errors has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
phenotypeSet has a value which is a phenotype_set_id
workspace has a value which is a workspace_id
genome has a value which is a genome_id
genome_workspace has a value which is a workspace_id
phenotypes has a value which is a reference to a list where each element is a Phenotype
name has a value which is a string
source has a value which is a string
ignore_errors has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 simulate_phenotypes_params

=over 4



=item Description

Input parameters for the "simulate_phenotypes" function.

        fbamodel_id model - ID of the model to be used for the simulation (a required argument)
        workspace_id model_workspace - workspace containing the model for the simulation (an optional argument: default is value of workspace argument)
        phenotype_set_id phenotypeSet - ID of the phenotypes set to be simulated (a required argument)
        workspace_id phenotypeSet_workspace - workspace containing the phenotype set to be simulated (an optional argument: default is value of workspace argument)
        FBAFormulation formulation - parameters for the simulation flux balance analysis (an optional argument: default is 'undef')
        string notes - string of notes to associate with the phenotype simulation (an optional argument: default is '')
        phenotypeSimulationSet_id phenotypeSimulationSet - ID of the phenotype simulation set to be generated (an optional argument: default is 'undef')
        workspace_id workspace - workspace where the phenotype simulation set should be saved (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)
        bool all_transporters - Set to TRUE if you want to add transporters for ALL media in the phenotypeset before simulating
        bool positive_transporters - Set to TRUE if you want to add transporters for POSITIVE (non-zero growth) media only before simulating


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
notes has a value which is a string
phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
workspace has a value which is a workspace_id
overwrite has a value which is a bool
auth has a value which is a string
all_transporters has a value which is a bool
positive_transporters has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
notes has a value which is a string
phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
workspace has a value which is a workspace_id
overwrite has a value which is a bool
auth has a value which is a string
all_transporters has a value which is a bool
positive_transporters has a value which is a bool


=end text

=back



=head2 add_media_transporters_params

=over 4



=item Description

Input parameters for the add_media_transporters function.

            phenotype_set_id phenotypeSet - ID for a phenotype set (required)
            workspace_id phenotypeSet_workspace - ID for the workspace in which the phenotype set is found
                fbamodel_id model - Model to which to add the transport reactions (required)
                workspace_id model_workspace - workspace containing the input model
                fbamodel_id outmodel - Name of output model (with transporters added)
                workspace_id workspace - workspace where the modified model should be saved
                bool overwrite - Overwrite or not
                string auth - Auth string
                bool all_transporters - Add transporters for ALL media in the phenotypeset
                bool positive_transporters - Add transporters for only POSITIVE (non-zero growth) media in the phenotype set


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
outmodel has a value which is a fbamodel_id
workspace has a value which is a workspace_id
overwrite has a value which is a bool
auth has a value which is a string
all_transporters has a value which is a bool
positive_transporters has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
outmodel has a value which is a fbamodel_id
workspace has a value which is a workspace_id
overwrite has a value which is a bool
auth has a value which is a string
all_transporters has a value which is a bool
positive_transporters has a value which is a bool


=end text

=back



=head2 export_phenotypeSimulationSet_params

=over 4



=item Description

Input parameters for the "export_phenotypeSimulationSet" function.

        phenotypeSimulationSet_id phenotypeSimulationSet - ID of the phenotype simulation set to be exported (a required argument)
        workspace_id workspace - workspace where the phenotype simulation set is stored (a required argument)
        string format - format to which phenotype simulation set should be exported (html, json)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
phenotypeSimulationSet has a value which is a phenotypeSimulationSet_id
workspace has a value which is a workspace_id
format has a value which is a string
auth has a value which is a string


=end text

=back



=head2 integrate_reconciliation_solutions_params

=over 4



=item Description

Input parameters for the "integrate_reconciliation_solutions" function.

        fbamodel_id model - ID of model for which reconciliation solutions should be integrated (a required argument)
        workspace_id model_workspace - workspace containing model for which solutions should be integrated (an optional argument: default is value of workspace argument)
        list<gapfillsolution_id> gapfillSolutions - list of gapfill solutions to be integrated (a required argument)
        list<gapgensolution_id> gapgenSolutions - list of gapgen solutions to be integrated (a required argument)
        fbamodel_id out_model - ID to which modified model should be saved (an optional argument: default is value of workspace argument)
        workspace_id workspace - workspace where modified model should be saved (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
gapfillSolutions has a value which is a reference to a list where each element is a gapfillsolution_id
gapgenSolutions has a value which is a reference to a list where each element is a gapgensolution_id
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
gapfillSolutions has a value which is a reference to a list where each element is a gapfillsolution_id
gapgenSolutions has a value which is a reference to a list where each element is a gapgensolution_id
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 queue_runfba_params

=over 4



=item Description

********************************************************************************
    Code relating to queuing long running jobs
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
fva has a value which is a bool
simulateko has a value which is a bool
minimizeflux has a value which is a bool
findminmedia has a value which is a bool
notes has a value which is a string
fba has a value which is a fba_id
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool
add_to_model has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is an FBAFormulation
fva has a value which is a bool
simulateko has a value which is a bool
minimizeflux has a value which is a bool
findminmedia has a value which is a bool
notes has a value which is a string
fba has a value which is a fba_id
workspace has a value which is a workspace_id
auth has a value which is a string
overwrite has a value which is a bool
add_to_model has a value which is a bool


=end text

=back



=head2 gapfill_model_params

=over 4



=item Description

Input parameters for the "queue_gapfill_model" function.

        fbamodel_id model - ID of the model that gapfill should be run on (a required argument)
        workspace_id model_workspace - workspace where model for gapfill should be run (an optional argument; default is the value of the workspace argument)
        GapfillingFormulation formulation - a hash specifying the parameters for the gapfill study (an optional argument)
        phenotype_set_id phenotypeSet - ID of a phenotype set against which gapfilled model should be simulated (an optional argument: default is 'undef')
        workspace_id phenotypeSet_workspace - workspace containing phenotype set to be simulated (an optional argument; default is the value of the workspace argument)
        bool integrate_solution - a flag indicating if the first solution should be integrated in the model (an optional argument: default is '0')
        list<string> target_reactions - a list of reactions to activate with gapfilling
        fbamodel_id out_model - ID where the gapfilled model will be saved (an optional argument: default is 'undef')
        gapfill_id gapFill - ID to which gapfill solution will be saved (an optional argument: default is 'undef')
        workspace_id workspace - workspace where gapfill results will be saved (a required argument)
        int timePerSolution - maximum time to spend to obtain each solution
        int totalTimeLimit - maximum time to spend to obtain all solutions
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)
        bool completeGapfill - boolean indicating that all inactive reactions should be gapfilled


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is a GapfillingFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
integrate_solution has a value which is a bool
target_reactions has a value which is a reference to a list where each element is a string
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapFill has a value which is a gapfill_id
timePerSolution has a value which is an int
totalTimeLimit has a value which is an int
auth has a value which is a string
overwrite has a value which is a bool
completeGapfill has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is a GapfillingFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
integrate_solution has a value which is a bool
target_reactions has a value which is a reference to a list where each element is a string
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapFill has a value which is a gapfill_id
timePerSolution has a value which is an int
totalTimeLimit has a value which is an int
auth has a value which is a string
overwrite has a value which is a bool
completeGapfill has a value which is a bool


=end text

=back



=head2 gapgen_model_params

=over 4



=item Description

Input parameters for the "queue_gapgen_model" function.

        fbamodel_id model - ID of the model that gapgen should be run on (a required argument)
        workspace_id model_workspace - workspace where model for gapgen should be run (an optional argument; default is the value of the workspace argument)
        GapgenFormulation formulation - a hash specifying the parameters for the gapgen study (an optional argument)
        phenotype_set_id phenotypeSet - ID of a phenotype set against which gapgened model should be simulated (an optional argument: default is 'undef')
        workspace_id phenotypeSet_workspace - workspace containing phenotype set to be simulated (an optional argument; default is the value of the workspace argument)
        bool integrate_solution - a flag indicating if the first solution should be integrated in the model (an optional argument: default is '0')
        fbamodel_id out_model - ID where the gapgened model will be saved (an optional argument: default is 'undef')
        gapgen_id gapGen - ID to which gapgen solution will be saved (an optional argument: default is 'undef')
        workspace_id workspace - workspace where gapgen results will be saved (a required argument)
        int timePerSolution - maximum time to spend to obtain each solution
        int totalTimeLimit - maximum time to spend to obtain all solutions
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is a GapgenFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
integrate_solution has a value which is a bool
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapGen has a value which is a gapgen_id
auth has a value which is a string
timePerSolution has a value which is an int
totalTimeLimit has a value which is an int
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
formulation has a value which is a GapgenFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
integrate_solution has a value which is a bool
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapGen has a value which is a gapgen_id
auth has a value which is a string
timePerSolution has a value which is an int
totalTimeLimit has a value which is an int
overwrite has a value which is a bool


=end text

=back



=head2 wildtype_phenotype_reconciliation_params

=over 4



=item Description

Input parameters for the "queue_wildtype_phenotype_reconciliation" function.

        fbamodel_id model - ID of the model that reconciliation should be run on (a required argument)
        workspace_id model_workspace - workspace where model for reconciliation should be run (an optional argument; default is the value of the workspace argument)
        FBAFormulation formulation - a hash specifying the parameters for the reconciliation study (an optional argument)
        GapfillingFormulation gapfill_formulation - a hash specifying the parameters for the gapfill study (an optional argument)
        GapgenFormulation gapgen_formulation - a hash specifying the parameters for the gapgen study (an optional argument)
        phenotype_set_id phenotypeSet - ID of a phenotype set against which reconciled model should be simulated (an optional argument: default is 'undef')
        workspace_id phenotypeSet_workspace - workspace containing phenotype set to be simulated (an optional argument; default is the value of the workspace argument)
        fbamodel_id out_model - ID where the reconciled model will be saved (an optional argument: default is 'undef')
        list<gapgen_id> gapGens - IDs of gapgen solutions (an optional argument: default is 'undef')
        list<gapfill_id> gapFills - IDs of gapfill solutions (an optional argument: default is 'undef')
        bool queueSensitivityAnalysis - flag indicating if sensitivity analysis should be queued to run on solutions (an optional argument: default is '0')
        bool queueReconciliationCombination - flag indicating if reconcilication combination should be queued to run on solutions (an optional argument: default is '0')
        workspace_id workspace - workspace where reconciliation results will be saved (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
fba_formulation has a value which is an FBAFormulation
gapfill_formulation has a value which is a GapfillingFormulation
gapgen_formulation has a value which is a GapgenFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapFills has a value which is a reference to a list where each element is a gapfill_id
gapGens has a value which is a reference to a list where each element is a gapgen_id
queueSensitivityAnalysis has a value which is a bool
queueReconciliationCombination has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
fba_formulation has a value which is an FBAFormulation
gapfill_formulation has a value which is a GapfillingFormulation
gapgen_formulation has a value which is a GapgenFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapFills has a value which is a reference to a list where each element is a gapfill_id
gapGens has a value which is a reference to a list where each element is a gapgen_id
queueSensitivityAnalysis has a value which is a bool
queueReconciliationCombination has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 queue_reconciliation_sensitivity_analysis_params

=over 4



=item Description

Input parameters for the "queue_reconciliation_sensitivity_analysis" function.

        fbamodel_id model - ID of the model that sensitivity analysis should be run on (a required argument)
        workspace_id model_workspace - workspace where model for sensitivity analysis should be run (an optional argument; default is the value of the workspace argument)
        FBAFormulation formulation - a hash specifying the parameters for the sensitivity analysis study (an optional argument)
        GapfillingFormulation gapfill_formulation - a hash specifying the parameters for the gapfill study (an optional argument)
        GapgenFormulation gapgen_formulation - a hash specifying the parameters for the gapgen study (an optional argument)
        phenotype_set_id phenotypeSet - ID of a phenotype set against which sensitivity analysis model should be simulated (an optional argument: default is 'undef')
        workspace_id phenotypeSet_workspace - workspace containing phenotype set to be simulated (an optional argument; default is the value of the workspace argument)
        fbamodel_id out_model - ID where the sensitivity analysis model will be saved (an optional argument: default is 'undef')
        list<gapgen_id> gapGens - IDs of gapgen solutions (an optional argument: default is 'undef')
        list<gapfill_id> gapFills - IDs of gapfill solutions (an optional argument: default is 'undef')
        bool queueReconciliationCombination - flag indicating if sensitivity analysis combination should be queued to run on solutions (an optional argument: default is '0')
        workspace_id workspace - workspace where sensitivity analysis results will be saved (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
phenotypeSet has a value which is a phenotype_set_id
fba_formulation has a value which is an FBAFormulation
model_workspace has a value which is a workspace_id
phenotypeSet_workspace has a value which is a workspace_id
gapFills has a value which is a reference to a list where each element is a gapfill_id
gapGens has a value which is a reference to a list where each element is a gapgen_id
queueReconciliationCombination has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
phenotypeSet has a value which is a phenotype_set_id
fba_formulation has a value which is an FBAFormulation
model_workspace has a value which is a workspace_id
phenotypeSet_workspace has a value which is a workspace_id
gapFills has a value which is a reference to a list where each element is a gapfill_id
gapGens has a value which is a reference to a list where each element is a gapgen_id
queueReconciliationCombination has a value which is a bool
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 combine_wildtype_phenotype_reconciliation_params

=over 4



=item Description

Input parameters for the "queue_combine_wildtype_phenotype_reconciliation" function.

        fbamodel_id model - ID of the model that solution combination should be run on (a required argument)
        workspace_id model_workspace - workspace where model for solution combination should be run (an optional argument; default is the value of the workspace argument)
        FBAFormulation formulation - a hash specifying the parameters for the solution combination study (an optional argument)
        GapfillingFormulation gapfill_formulation - a hash specifying the parameters for the gapfill study (an optional argument)
        GapgenFormulation gapgen_formulation - a hash specifying the parameters for the gapgen study (an optional argument)
        phenotype_set_id phenotypeSet - ID of a phenotype set against which solution combination model should be simulated (an optional argument: default is 'undef')
        workspace_id phenotypeSet_workspace - workspace containing phenotype set to be simulated (an optional argument; default is the value of the workspace argument)
        fbamodel_id out_model - ID where the solution combination model will be saved (an optional argument: default is 'undef')
        list<gapgen_id> gapGens - IDs of gapgen solutions (an optional argument: default is 'undef')
        list<gapfill_id> gapFills - IDs of gapfill solutions (an optional argument: default is 'undef')
        workspace_id workspace - workspace where solution combination results will be saved (a required argument)
        int timePerSolution - maximum time spent per solution
        int totalTimeLimit - maximum time allowed to work on problem
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
fba_formulation has a value which is an FBAFormulation
gapfill_formulation has a value which is a GapfillingFormulation
gapgen_formulation has a value which is a GapgenFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapFills has a value which is a reference to a list where each element is a gapfill_id
gapGens has a value which is a reference to a list where each element is a gapgen_id
auth has a value which is a string
overwrite has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_workspace has a value which is a workspace_id
fba_formulation has a value which is an FBAFormulation
gapfill_formulation has a value which is a GapfillingFormulation
gapgen_formulation has a value which is a GapgenFormulation
phenotypeSet has a value which is a phenotype_set_id
phenotypeSet_workspace has a value which is a workspace_id
out_model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
gapFills has a value which is a reference to a list where each element is a gapfill_id
gapGens has a value which is a reference to a list where each element is a gapgen_id
auth has a value which is a string
overwrite has a value which is a bool


=end text

=back



=head2 run_job_params

=over 4



=item Description

Input parameters for the "run_job" function.

        job_id job - ID of the job object (a required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
job has a value which is a job_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
job has a value which is a job_id
auth has a value which is a string


=end text

=back



=head2 queue_job_params

=over 4



=item Description

Input parameters for the "queue_job" function.

        string method;
        mapping<string,string> parameters;


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
method has a value which is a string
parameters has a value which is a reference to a hash where the key is a string and the value is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
method has a value which is a string
parameters has a value which is a reference to a hash where the key is a string and the value is a string


=end text

=back



=head2 set_cofactors_params

=over 4



=item Description

Input parameters for the "set_cofactors" function.

        list<compound_id> cofactors - list of compounds that are universal cofactors (required)
        biochemistry_id biochemistry - ID of biochemistry database (optional, default is "default") 
        workspace_id biochemistry_workspace - ID of workspace containing biochemistry database (optional, default is current workspace)
        bool reset - true to reset (turn off) compounds as universal cofactors (optional, default is false)
        bool overwrite - true to overwrite existing object (optional, default is false)
        string auth - the authentication token of the KBase account (optional, default user is "public")


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
cofactors has a value which is a reference to a list where each element is a compound_id
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
reset has a value which is a bool
overwrite has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
cofactors has a value which is a reference to a list where each element is a compound_id
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
reset has a value which is a bool
overwrite has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 find_reaction_synonyms_params

=over 4



=item Description

Input parameters for the "find_reaction_synonyms" function.

        reaction_synonyms - ID of reaction synonyms object (required argument)
        workspace_id workspace - ID of workspace for storing objects (optional argument, default is current workspace)
        biochemistry_id biochemistry - ID of the biochemistry database (optional argument, default is default)
        workspace_id biochemistry_workspace - ID of workspace containing biochemistry database (optional argument, default is kbase)
        overwrite - True to overwrite existing object (optional argument, default is false)
        string auth - the authentication token of the KBase account (optional argument, default user is "public")


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
reaction_synonyms has a value which is a reaction_synonyms_id
workspace has a value which is a workspace_id
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
overwrite has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
reaction_synonyms has a value which is a reaction_synonyms_id
workspace has a value which is a workspace_id
biochemistry has a value which is a biochemistry_id
biochemistry_workspace has a value which is a workspace_id
overwrite has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 role_to_reactions_params

=over 4



=item Description

Input parameters for the "role_to_reactions" function.

        template_id templateModel - ID of the template model to be used to determine mapping (default is '')
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
auth has a value which is a string


=end text

=back



=head2 kb_sub_id

=over 4



=item Description

********************************************************************************
	Code relating to assessing model sensitivity to reaction knockouts
   	********************************************************************************


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 kb_id

=over 4



=item Description

@id kb


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 ws_id

=over 4



=item Description

@id ws


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 ws_sub_id

=over 4



=item Description

@id wssub


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 ReactionSensitivityAnalysisCorrectedReaction

=over 4



=item Description

ReactionSensitivityAnalysisCorrectedReaction object

kb_sub_id kbid - KBase ID for reaction knockout corrected reaction
ws_sub_id model_reaction_wsid - ID of model reaction
float normalized_required_reaction_count - Normalized count of reactions required for this reaction to function
list<ws_sub_id> required_reactions - list of reactions required for this reaction to function

@searchable ws_subset kbid model_reaction_kbid required_reactions
@optional


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kb_sub_id
model_reaction_wsid has a value which is a ws_sub_id
normalized_required_reaction_count has a value which is a float
required_reactions has a value which is a reference to a list where each element is a ws_sub_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kb_sub_id
model_reaction_wsid has a value which is a ws_sub_id
normalized_required_reaction_count has a value which is a float
required_reactions has a value which is a reference to a list where each element is a ws_sub_id


=end text

=back



=head2 ReactionSensitivityAnalysisReaction

=over 4



=item Description

Object for holding reaction knockout sensitivity reaction data

kb_sub_id kbid - KBase ID for reaction knockout sensitivity reaction
ws_sub_id model_reaction_wsid - ID of model reaction
bool delete - indicates if reaction is to be deleted
bool deleted - indicates if the reaction has been deleted
string direction - Direction of reaction that was tested (> is forward, < backward and = both)
float growth_fraction - Fraction of wild-type growth after knockout
float normalized_activated_reaction_count - Normalized number of activated reactions
list<ws_sub_id> biomass_compounds  - List of biomass compounds that depend on the reaction
list<ws_sub_id> new_inactive_rxns - List of new reactions dependant upon reaction KO
list<ws_sub_id> new_essentials - List of new essential genes with reaction knockout


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kb_sub_id
model_reaction_wsid has a value which is a ws_sub_id
growth_fraction has a value which is a float
delete has a value which is a bool
deleted has a value which is a bool
direction has a value which is a string
normalized_activated_reaction_count has a value which is a float
biomass_compounds has a value which is a reference to a list where each element is a ws_sub_id
new_inactive_rxns has a value which is a reference to a list where each element is a ws_sub_id
new_essentials has a value which is a reference to a list where each element is a ws_sub_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kb_sub_id
model_reaction_wsid has a value which is a ws_sub_id
growth_fraction has a value which is a float
delete has a value which is a bool
deleted has a value which is a bool
direction has a value which is a string
normalized_activated_reaction_count has a value which is a float
biomass_compounds has a value which is a reference to a list where each element is a ws_sub_id
new_inactive_rxns has a value which is a reference to a list where each element is a ws_sub_id
new_essentials has a value which is a reference to a list where each element is a ws_sub_id


=end text

=back



=head2 ReactionSensitivityAnalysis

=over 4



=item Description

Object for holding reaction knockout sensitivity results

        kb_id kbid - KBase ID of reaction sensitivity object
        ws_id model_wsid - Workspace reference to associated model
        string type - type of reaction KO sensitivity object
        bool deleted_noncontributing_reactions - boolean indicating if noncontributing reactions were deleted
        bool integrated_deletions_in_model - boolean indicating if deleted reactions were implemented in the model
        list<ReactionSensitivityAnalysisReaction> reactions - list of sensitivity data for tested reactions
        list<ReactionSensitivityAnalysisCorrectedReaction> corrected_reactions - list of reactions dependant upon tested reactions


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kb_id
model_wsid has a value which is a ws_id
type has a value which is a string
deleted_noncontributing_reactions has a value which is a bool
integrated_deletions_in_model has a value which is a bool
reactions has a value which is a reference to a list where each element is a ReactionSensitivityAnalysisReaction
corrected_reactions has a value which is a reference to a list where each element is a ReactionSensitivityAnalysisCorrectedReaction

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kb_id
model_wsid has a value which is a ws_id
type has a value which is a string
deleted_noncontributing_reactions has a value which is a bool
integrated_deletions_in_model has a value which is a bool
reactions has a value which is a reference to a list where each element is a ReactionSensitivityAnalysisReaction
corrected_reactions has a value which is a reference to a list where each element is a ReactionSensitivityAnalysisCorrectedReaction


=end text

=back



=head2 rxnprob_id

=over 4



=item Description

ID for a RxnProbs T.O. (defined in the probabilistic annotation spec)


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 reaction_sensitivity_analysis_params

=over 4



=item Description

Input parameters for the "reaction_sensitivity_analysis" function.

        fbamodel_id model - ID of model to be analyzed (a required argument)
        workspace_id model_ws - ID of workspace with model to be analyzed (an optional argument - default is value of workspace argument)
        string rxnsens_uid - Name of RxnSensitivity object in workspace (an optional argument - default is KBase ID)
        workspace_id workspace - ID of workspace where output and default inputs will be selected from (a required argument)
        list<reaction_id> reactions_to_delete - list of reactions to delete in sensitiviity analysis; note, order of the reactions matters (a required argument unless gapfill solution ID is provided)                
        gapfillsolution_id gapfill_solution_id - A Gapfill solution ID. If provided, all reactions in the provided solution will be tested for deletion.
        bool delete_noncontributing_reactions - a boolean indicating if unuseful reactions should be deleted when running the analysis (an optional argument - default is "0")
        rxnprob_id rxnprobs_id - ID for a RxnProbs object in a workspace. If provided less likely reactions will be tested for deletion first in the sensitivity analysis (optional).
        workspace_id rxnprobs_ws - Workspace in which the RxnProbs object is located (optional - default is the value of the workspace argument).
        string type - type of Reaction sensitivity analysis (an optional argument - default is "unknown")
        string auth  - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_ws has a value which is a workspace_id
rxnsens_uid has a value which is a string
workspace has a value which is a workspace_id
reactions_to_delete has a value which is a reference to a list where each element is a reaction_id
gapfill_solution_id has a value which is a gapfillsolution_id
delete_noncontributing_reactions has a value which is a bool
rxnprobs_id has a value which is a rxnprob_id
rxnprobs_ws has a value which is a workspace_id
type has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
model_ws has a value which is a workspace_id
rxnsens_uid has a value which is a string
workspace has a value which is a workspace_id
reactions_to_delete has a value which is a reference to a list where each element is a reaction_id
gapfill_solution_id has a value which is a gapfillsolution_id
delete_noncontributing_reactions has a value which is a bool
rxnprobs_id has a value which is a rxnprob_id
rxnprobs_ws has a value which is a workspace_id
type has a value which is a string
auth has a value which is a string


=end text

=back



=head2 filter_iterative_solutions_params

=over 4



=item Description

Input parameters for the "filter_iterative_solutions" function.
fbamodel_id model - Model ID for which to filter iterative gapfill solutions (a required argument)
fbamodel_id outmodel - ModelID to which to save the filtered results (by default the filtered model is given the same ID as the input model)
float cutoff - Cutoff for cost per reaction above which to remove iterative gapfill solution reactions (a required argument)
gapfillsolution_id gapfillsln - Gapfill_solution ID (UUID.solution.#) containing the iterative gapfill solutions to filter (a required argument)
string auth - The authorization token of the KBase account with workspace permissions.
workspace_id workspace - ID of workspace where output and default inputs will be selected from (a required argument)
workspace_id input_model_ws - ID of workspace containing the input model


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
outmodel has a value which is a fbamodel_id
cutoff has a value which is a float
gapfillsln has a value which is a gapfillsolution_id
workspace has a value which is a workspace_id
input_model_ws has a value which is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
outmodel has a value which is a fbamodel_id
cutoff has a value which is a float
gapfillsln has a value which is a gapfillsolution_id
workspace has a value which is a workspace_id
input_model_ws has a value which is a workspace_id
auth has a value which is a string


=end text

=back



=head2 delete_noncontributing_reactions_params

=over 4



=item Description

Input parameters for the "delete_noncontributing_reactions" function.
workspace_id workspae - Workspace for outputs and default inputs (a required argument)
workspace_id rxn_sensitivity_ws - Workspace for reaction sensitivity object used as input
string rxn_sensitivity - Reaction sensitivity ID
fbamodel_id new_model_uid - ID for output model with noncontributing reactions deleted
string new_rxn_sensitivity_uid - ID for rxnsensitivity object with bits set to indicate reactions were deleted
string auth - Authorization token for user (must have appropriate permissions to read and write objects)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
rxn_sensitivity_ws has a value which is a workspace_id
rxn_sensitivity has a value which is a string
workspace has a value which is a workspace_id
new_model_uid has a value which is a fbamodel_id
new_rxn_sensitivity_uid has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
rxn_sensitivity_ws has a value which is a workspace_id
rxn_sensitivity has a value which is a string
workspace has a value which is a workspace_id
new_model_uid has a value which is a fbamodel_id
new_rxn_sensitivity_uid has a value which is a string
auth has a value which is a string


=end text

=back



=head2 AnnotationParameters

=over 4



=item Description

********************************************************************************
	Code relating to workspace versions of genome analysis algorithms
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
call_genes has a value which is a bool
annotate_genes has a value which is a bool

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
call_genes has a value which is a bool
annotate_genes has a value which is a bool


=end text

=back



=head2 annotate_workspace_Genome_params

=over 4



=item Description

Input parameters for the "annotate_workspace_Genome" function.

string Genome_uid - user ID to be assigned to the Genome (required argument)
string Genome_ws - workspace with genome for annotation (optional; workspace argument will be used if no genome workspace is provided)
string new_uid - new ID to assign to annotated genome (optional; original genome will be overwritten if no new uid is provided)
workspace_id workspace - ID of workspace with Genome (required argument)
AnnotationParameters parameters - parameters for running annotation job
string auth - the authentication token of the KBase account changing workspace permissions


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
Genome_uid has a value which is a string
Genome_ws has a value which is a string
new_uid has a value which is a string
workspace has a value which is a workspace_id
annotation_parameters has a value which is an AnnotationParameters
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
Genome_uid has a value which is a string
Genome_ws has a value which is a string
new_uid has a value which is a string
workspace has a value which is a workspace_id
annotation_parameters has a value which is an AnnotationParameters
auth has a value which is a string


=end text

=back



=head2 gtf_to_genome_params

=over 4



=item Description

********************************************************************************
	Code relating to import and analysis of ProteinSets
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
contigset has a value which is a string
contigset_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
genome_uid has a value which is a string
source_id has a value which is a string
source has a value which is a string
scientific_name has a value which is a string
domain has a value which is a string
genetic_code has a value which is an int
taxonomy has a value which is a string
gtf_file has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
contigset has a value which is a string
contigset_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
genome_uid has a value which is a string
source_id has a value which is a string
source has a value which is a string
scientific_name has a value which is a string
domain has a value which is a string
genetic_code has a value which is an int
taxonomy has a value which is a string
gtf_file has a value which is a string


=end text

=back



=head2 fasta_to_ProteinSet_params

=over 4



=item Description

Input parameters for the "fasta_to_ProteinSet" function.

        string uid - user assigned ID for the protein set (optional)
        string fasta - string with sequence data from fasta file (required argument)
        workspace_id workspace - ID of workspace for storing objects (required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)
        string name - name of the protein data (optional)
        string sourceid - source ID of the protein data (optional)
        string source - source of the protein data (optional)
        string type - type of the protein set (optional)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
uid has a value which is a string
fasta has a value which is a string
workspace has a value which is a workspace_id
auth has a value which is a string
name has a value which is a string
sourceid has a value which is a string
source has a value which is a string
type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
uid has a value which is a string
fasta has a value which is a string
workspace has a value which is a workspace_id
auth has a value which is a string
name has a value which is a string
sourceid has a value which is a string
source has a value which is a string
type has a value which is a string


=end text

=back



=head2 ProteinSet_to_Genome_params

=over 4



=item Description

Input parameters for the "ProteinSet_to_Genome" function.

        string ProteinSet_uid - ID to be assigned to the ProteinSet (required argument)
        workspace_id ProteinSet_ws - ID of workspace with the ProteinSet (optional argument; default is value of workspace argument)
        string uid - user assigned ID for the Genome (optional)
        workspace_id workspace - ID of workspace for storing objects (required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)
        string scientific_name - scientific name to assign to genome
        string domain - domain of life for genome
        int genetic_code - genetic code to assign to genome


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
ProteinSet_uid has a value which is a string
ProteinSet_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
uid has a value which is a string
auth has a value which is a string
scientific_name has a value which is a string
domain has a value which is a string
annotation_parameters has a value which is an AnnotationParameters

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
ProteinSet_uid has a value which is a string
ProteinSet_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
uid has a value which is a string
auth has a value which is a string
scientific_name has a value which is a string
domain has a value which is a string
annotation_parameters has a value which is an AnnotationParameters


=end text

=back



=head2 fasta_to_ContigSet_params

=over 4



=item Description

********************************************************************************
	Code relating to import and analysis of Contigs
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
uid has a value which is a string
fasta has a value which is a string
workspace has a value which is a workspace_id
auth has a value which is a string
name has a value which is a string
sourceid has a value which is a string
source has a value which is a string
type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
uid has a value which is a string
fasta has a value which is a string
workspace has a value which is a workspace_id
auth has a value which is a string
name has a value which is a string
sourceid has a value which is a string
source has a value which is a string
type has a value which is a string


=end text

=back



=head2 ContigSet_to_Genome_params

=over 4



=item Description

Input parameters for the "ContigSet_to_Genome" function.

        string ContigSet_uid - ID to be assigned to the ContigSet (required argument)
        workspace_id ContigSet_ws - ID of workspace with the ContigSet (optional argument; default is value of workspace argument)
        string uid - user assigned ID for the Genome (optional)
        workspace_id workspace - ID of workspace for storing objects (required argument)
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)
        string scientific_name - scientific name to assign to genome
        string domain - domain of life for genome
        int genetic_code - genetic code to assign to genome
        AnnotationParameters annotation_parameters - parameters for annotation of the genome


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
ContigSet_uid has a value which is a string
ContigSet_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
uid has a value which is a string
auth has a value which is a string
scientific_name has a value which is a string
domain has a value which is a string
genetic_code has a value which is an int
annotation_parameters has a value which is an AnnotationParameters

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
ContigSet_uid has a value which is a string
ContigSet_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
uid has a value which is a string
auth has a value which is a string
scientific_name has a value which is a string
domain has a value which is a string
genetic_code has a value which is an int
annotation_parameters has a value which is an AnnotationParameters


=end text

=back



=head2 probanno_to_genome_params

=over 4



=item Description

********************************************************************************
	Code relating to analysis of probabilistic annotations
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
pa_id has a value which is a probanno_id
pa_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
g_id has a value which is a genome_id
threshold has a value which is a float
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
pa_id has a value which is a probanno_id
pa_ws has a value which is a workspace_id
workspace has a value which is a workspace_id
g_id has a value which is a genome_id
threshold has a value which is a float
auth has a value which is a string


=end text

=back



=head2 FunctionalRole

=over 4



=item Description

********************************************************************************
	Code relating to loading, retrieval, and curation of mappings
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a role_id
name has a value which is a string
feature has a value which is a string
aliases has a value which is a reference to a list where each element is a string
complexes has a value which is a reference to a list where each element is a complex_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a role_id
name has a value which is a string
feature has a value which is a string
aliases has a value which is a reference to a list where each element is a string
complexes has a value which is a reference to a list where each element is a complex_id


=end text

=back



=head2 ComplexRole

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 4 items:
0: (id) a role_id
1: (roleType) a string
2: (optional_role) a bool
3: (triggering) a bool

</pre>

=end html

=begin text

a reference to a list containing 4 items:
0: (id) a role_id
1: (roleType) a string
2: (optional_role) a bool
3: (triggering) a bool


=end text

=back



=head2 Complex

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a complex_id
name has a value which is a string
aliases has a value which is a reference to a list where each element is a string
roles has a value which is a reference to a list where each element is a ComplexRole

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a complex_id
name has a value which is a string
aliases has a value which is a reference to a list where each element is a string
roles has a value which is a reference to a list where each element is a ComplexRole


=end text

=back



=head2 subsystem_id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 Subsystem

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a subsystem_id
name has a value which is a string
phenoclass has a value which is a string
subclass has a value which is a string
type has a value which is a string
aliases has a value which is a reference to a list where each element is a string
roles has a value which is a reference to a list where each element is a role_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a subsystem_id
name has a value which is a string
phenoclass has a value which is a string
subclass has a value which is a string
type has a value which is a string
aliases has a value which is a reference to a list where each element is a string
roles has a value which is a reference to a list where each element is a role_id


=end text

=back



=head2 Mapping

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a mapping_id
name has a value which is a string
subsystems has a value which is a reference to a list where each element is a Subsystem
roles has a value which is a reference to a list where each element is a FunctionalRole
complexes has a value which is a reference to a list where each element is a Complex

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a mapping_id
name has a value which is a string
subsystems has a value which is a reference to a list where each element is a Subsystem
roles has a value which is a reference to a list where each element is a FunctionalRole
complexes has a value which is a reference to a list where each element is a Complex


=end text

=back



=head2 get_mapping_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
auth has a value which is a string


=end text

=back



=head2 subsysclass

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 2 items:
0: a string
1: a string

</pre>

=end html

=begin text

a reference to a list containing 2 items:
0: a string
1: a string


=end text

=back



=head2 subsysclasses

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the key is a string and the value is a subsysclass
</pre>

=end html

=begin text

a reference to a hash where the key is a string and the value is a subsysclass

=end text

=back



=head2 subsystem_of_roles_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
roles has a value which is a reference to a list where each element is a string
map has a value which is a string
map_workspace has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
roles has a value which is a reference to a list where each element is a string
map has a value which is a string
map_workspace has a value which is a string


=end text

=back



=head2 adjust_mapping_role_params

=over 4



=item Description

Input parameters for the "adjust_mapping_role" function.

        mapping_id map - ID of the mapping object to be edited
        workspace_id workspace - ID of workspace containing mapping to be edited
        string role - identifier for role to be edited
        bool new - boolean indicating that a new role is being added
        string name - new name for the role
        string feature - representative feature MD5
        list<string> aliasesToAdd - list of new aliases for the role
        list<string> aliasesToRemove - list of aliases to remove for role
        bool delete - boolean indicating that role should be deleted
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
role has a value which is a string
new has a value which is a bool
name has a value which is a string
feature has a value which is a string
aliasesToAdd has a value which is a reference to a list where each element is a string
aliasesToRemove has a value which is a reference to a list where each element is a string
delete has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
role has a value which is a string
new has a value which is a bool
name has a value which is a string
feature has a value which is a string
aliasesToAdd has a value which is a reference to a list where each element is a string
aliasesToRemove has a value which is a reference to a list where each element is a string
delete has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 adjust_mapping_complex_params

=over 4



=item Description

Input parameters for the "adjust_mapping_complex" function.

        mapping_id map - ID of the mapping object to be edited
        workspace_id workspace - ID of workspace containing mapping to be edited
        string complex - identifier for complex to be edited
        bool new - boolean indicating that a new complex is being added
        string name - new name for the role
        string feature - representative feature MD5
        list<string> rolesToAdd - roles to add to the complex
        list<string> rolesToRemove - roles to remove from the complex
        bool delete - boolean indicating that complex should be deleted
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
complex has a value which is a string
new has a value which is a bool
name has a value which is a string
rolesToAdd has a value which is a reference to a list where each element is a string
rolesToRemove has a value which is a reference to a list where each element is a string
delete has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
complex has a value which is a string
new has a value which is a bool
name has a value which is a string
rolesToAdd has a value which is a reference to a list where each element is a string
rolesToRemove has a value which is a reference to a list where each element is a string
delete has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 adjust_mapping_subsystem_params

=over 4



=item Description

Input parameters for the "adjust_mapping_subsystem" function.

        mapping_id map - ID of the mapping object to be edited
        workspace_id workspace - ID of workspace containing mapping to be edited
        string subsystem - identifier for subsystem to be edited
        bool new - boolean indicating that a new subsystem is being added
        string name - new name for the subsystem
        string type - new type for the subsystem
        string primclass - new class for the subsystem
        string subclass - new subclass for the subsystem
        list<string> rolesToAdd - roles to add to the subsystem
        list<string> rolesToRemove - roles to remove from the subsystem
        bool delete - boolean indicating that subsystem should be deleted
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
subsystem has a value which is a string
new has a value which is a bool
name has a value which is a string
type has a value which is a string
primclass has a value which is a string
subclass has a value which is a string
rolesToAdd has a value which is a reference to a list where each element is a string
rolesToRemove has a value which is a reference to a list where each element is a string
delete has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
workspace has a value which is a workspace_id
subsystem has a value which is a string
new has a value which is a bool
name has a value which is a string
type has a value which is a string
primclass has a value which is a string
subclass has a value which is a string
rolesToAdd has a value which is a reference to a list where each element is a string
rolesToRemove has a value which is a reference to a list where each element is a string
delete has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 temprxn_id

=over 4



=item Description

********************************************************************************
	Code relating to loading, retrieval, and curation of template models
   	********************************************************************************


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 TemplateReaction

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a temprxn_id
compartment has a value which is a compartment_id
reaction has a value which is a reaction_id
complexes has a value which is a reference to a list where each element is a complex_id
direction has a value which is a string
type has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a temprxn_id
compartment has a value which is a compartment_id
reaction has a value which is a reaction_id
complexes has a value which is a reference to a list where each element is a complex_id
direction has a value which is a string
type has a value which is a string


=end text

=back



=head2 TemplateBiomassCompounds

=over 4



=item Definition

=begin html

<pre>
a reference to a list containing 7 items:
0: (compound) a compound_id
1: (compartment) a compartment_id
2: (cpdclass) a string
3: (universal) a string
4: (coefficientType) a string
5: (coefficient) a string
6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
	0: (coeffficient) a string
	1: (compound) a compound_id


</pre>

=end html

=begin text

a reference to a list containing 7 items:
0: (compound) a compound_id
1: (compartment) a compartment_id
2: (cpdclass) a string
3: (universal) a string
4: (coefficientType) a string
5: (coefficient) a string
6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
	0: (coeffficient) a string
	1: (compound) a compound_id



=end text

=back



=head2 tempbiomass_id

=over 4



=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 TemplateBiomass

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a tempbiomass_id
name has a value which is a string
type has a value which is a string
other has a value which is a string
protein has a value which is a string
dna has a value which is a string
rna has a value which is a string
cofactor has a value which is a string
energy has a value which is a string
cellwall has a value which is a string
lipid has a value which is a string
compounds has a value which is a reference to a list where each element is a TemplateBiomassCompounds

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a tempbiomass_id
name has a value which is a string
type has a value which is a string
other has a value which is a string
protein has a value which is a string
dna has a value which is a string
rna has a value which is a string
cofactor has a value which is a string
energy has a value which is a string
cellwall has a value which is a string
lipid has a value which is a string
compounds has a value which is a reference to a list where each element is a TemplateBiomassCompounds


=end text

=back



=head2 TemplateModel

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
id has a value which is a template_id
name has a value which is a string
type has a value which is a string
domain has a value which is a string
map has a value which is a mapping_id
mappingws has a value which is a workspace_id
reactions has a value which is a reference to a list where each element is a TemplateReaction
biomasses has a value which is a reference to a list where each element is a TemplateBiomass

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
id has a value which is a template_id
name has a value which is a string
type has a value which is a string
domain has a value which is a string
map has a value which is a mapping_id
mappingws has a value which is a workspace_id
reactions has a value which is a reference to a list where each element is a TemplateReaction
biomasses has a value which is a reference to a list where each element is a TemplateBiomass


=end text

=back



=head2 get_template_model_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
auth has a value which is a string


=end text

=back



=head2 import_template_fbamodel_params

=over 4



=item Description

Input parameters for the "import_template_fbamodel" function.

        mapping_id map - ID of the mapping to associate the template model with (an optional argument; default is 'default')
        workspace_id mapping_workspace - ID of the workspace where the associated mapping is found (an optional argument; default is 'kbase')
        list<tuple<string id,string compartment,string direction,string type,list<string complex> complexes>> templateReactions - list of reactions to include in template model
        list<tuple<string name,string type,float dna,float rna,float protein,float lipid,float cellwall,float cofactor,float energy,float other,list<tuple<string id,string compartment,string cpdclass,string coefficientType,float coefficient,string conditions>> compounds>> templateBiomass - list of template biomass reactions for template model
        string name - name for template model
        string modelType - type of model constructed by template
        string domain - domain of template model
        template_id id - ID that should be used for the newly imported template model (an optional argument; default is 'undef')
        workspace_id workspace - ID of the workspace where the newly developed template model will be stored; also the default assumed workspace for input objects (a required argument)
        bool ignore_errors - ignores missing roles or reactions and imports template model anyway
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
mapping_workspace has a value which is a workspace_id
templateReactions has a value which is a reference to a list where each element is a reference to a list containing 5 items:
0: (id) a string
1: (compartment) a string
2: (direction) a string
3: (type) a string
4: (complexes) a reference to a list where each element is a string

templateBiomass has a value which is a reference to a list where each element is a reference to a list containing 11 items:
0: (name) a string
1: (type) a string
2: (dna) a float
3: (rna) a float
4: (protein) a float
5: (lipid) a float
6: (cellwall) a float
7: (cofactor) a float
8: (energy) a float
9: (other) a float
10: (compounds) a reference to a list where each element is a reference to a list containing 6 items:
	0: (id) a string
	1: (compartment) a string
	2: (cpdclass) a string
	3: (coefficientType) a string
	4: (coefficient) a float
	5: (conditions) a string


name has a value which is a string
modelType has a value which is a string
domain has a value which is a string
id has a value which is a template_id
workspace has a value which is a workspace_id
ignore_errors has a value which is a bool
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
map has a value which is a mapping_id
mapping_workspace has a value which is a workspace_id
templateReactions has a value which is a reference to a list where each element is a reference to a list containing 5 items:
0: (id) a string
1: (compartment) a string
2: (direction) a string
3: (type) a string
4: (complexes) a reference to a list where each element is a string

templateBiomass has a value which is a reference to a list where each element is a reference to a list containing 11 items:
0: (name) a string
1: (type) a string
2: (dna) a float
3: (rna) a float
4: (protein) a float
5: (lipid) a float
6: (cellwall) a float
7: (cofactor) a float
8: (energy) a float
9: (other) a float
10: (compounds) a reference to a list where each element is a reference to a list containing 6 items:
	0: (id) a string
	1: (compartment) a string
	2: (cpdclass) a string
	3: (coefficientType) a string
	4: (coefficient) a float
	5: (conditions) a string


name has a value which is a string
modelType has a value which is a string
domain has a value which is a string
id has a value which is a template_id
workspace has a value which is a workspace_id
ignore_errors has a value which is a bool
auth has a value which is a string


=end text

=back



=head2 adjust_template_reaction_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
reaction has a value which is a string
clearComplexes has a value which is a bool
new has a value which is a bool
delete has a value which is a bool
compartment has a value which is a compartment_id
complexesToAdd has a value which is a reference to a list where each element is a complex_id
complexesToRemove has a value which is a reference to a list where each element is a complex_id
direction has a value which is a string
type has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
reaction has a value which is a string
clearComplexes has a value which is a bool
new has a value which is a bool
delete has a value which is a bool
compartment has a value which is a compartment_id
complexesToAdd has a value which is a reference to a list where each element is a complex_id
complexesToRemove has a value which is a reference to a list where each element is a complex_id
direction has a value which is a string
type has a value which is a string
auth has a value which is a string


=end text

=back



=head2 adjust_template_biomass_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
biomass has a value which is a string
new has a value which is a bool
delete has a value which is a bool
clearBiomassCompounds has a value which is a bool
name has a value which is a string
type has a value which is a string
other has a value which is a string
protein has a value which is a string
dna has a value which is a string
rna has a value which is a string
cofactor has a value which is a string
energy has a value which is a string
cellwall has a value which is a string
lipid has a value which is a string
compoundsToRemove has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (compound) a compound_id
1: (compartment) a compartment_id

compoundsToAdd has a value which is a reference to a list where each element is a reference to a list containing 7 items:
0: (compound) a compound_id
1: (compartment) a compartment_id
2: (cpdclass) a string
3: (universal) a string
4: (coefficientType) a string
5: (coefficient) a string
6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
	0: (coeffficient) a string
	1: (compound) a compound_id


auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
templateModel has a value which is a template_id
workspace has a value which is a workspace_id
biomass has a value which is a string
new has a value which is a bool
delete has a value which is a bool
clearBiomassCompounds has a value which is a bool
name has a value which is a string
type has a value which is a string
other has a value which is a string
protein has a value which is a string
dna has a value which is a string
rna has a value which is a string
cofactor has a value which is a string
energy has a value which is a string
cellwall has a value which is a string
lipid has a value which is a string
compoundsToRemove has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (compound) a compound_id
1: (compartment) a compartment_id

compoundsToAdd has a value which is a reference to a list where each element is a reference to a list containing 7 items:
0: (compound) a compound_id
1: (compartment) a compartment_id
2: (cpdclass) a string
3: (universal) a string
4: (coefficientType) a string
5: (coefficient) a string
6: (linkedCompounds) a reference to a list where each element is a reference to a list containing 2 items:
	0: (coeffficient) a string
	1: (compound) a compound_id


auth has a value which is a string


=end text

=back



=head2 add_stimuli_params

=over 4



=item Description

********************************************************************************
    Code relating to reconstruction, import, and analysis of regulatory models
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
biochemid has a value which is a string
biochem_workspace has a value which is a string
stimuliid has a value which is a string
name has a value which is a string
abbreviation has a value which is a string
type has a value which is a string
description has a value which is a string
compounds has a value which is a reference to a list where each element is a string
workspace has a value which is a string
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
biochemid has a value which is a string
biochem_workspace has a value which is a string
stimuliid has a value which is a string
name has a value which is a string
abbreviation has a value which is a string
type has a value which is a string
description has a value which is a string
compounds has a value which is a reference to a list where each element is a string
workspace has a value which is a string
auth has a value which is a string


=end text

=back



=head2 Stimuli

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
name has a value which is a string
abbreviation has a value which is a string
description has a value which is a string
type has a value which is a string
compound_kbids has a value which is a reference to a list where each element is a kbase_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
name has a value which is a string
abbreviation has a value which is a string
description has a value which is a string
type has a value which is a string
compound_kbids has a value which is a reference to a list where each element is a kbase_id


=end text

=back



=head2 RegulatoryModelRegulonStimuli

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
stimuli_kbid has a value which is a kbase_id
is_inhibitor has a value which is a bool
strength has a value which is a float
min_concentration has a value which is a float
max_concentration has a value which is a float
regulator_kbids has a value which is a reference to a list where each element is a kbase_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
stimuli_kbid has a value which is a kbase_id
is_inhibitor has a value which is a bool
strength has a value which is a float
min_concentration has a value which is a float
max_concentration has a value which is a float
regulator_kbids has a value which is a reference to a list where each element is a kbase_id


=end text

=back



=head2 RegulatoryModelRegulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
name has a value which is a string
feature_kbids has a value which is a reference to a list where each element is a kbase_id
stimuli has a value which is a reference to a list where each element is a RegulatoryModelRegulonStimuli

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
name has a value which is a string
feature_kbids has a value which is a reference to a list where each element is a kbase_id
stimuli has a value which is a reference to a list where each element is a RegulatoryModelRegulonStimuli


=end text

=back



=head2 RegulatoryModel

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
name has a value which is a string
type has a value which is a string
genome_wsid has a value which is a ws_ref
regulons has a value which is a reference to a list where each element is a RegulatoryModelRegulon

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a kbase_id
name has a value which is a string
type has a value which is a string
genome_wsid has a value which is a ws_ref
regulons has a value which is a reference to a list where each element is a RegulatoryModelRegulon


=end text

=back



=head2 import_regulatory_model_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
regmodel_uid has a value which is a string
workspace has a value which is a workspace_id
genome has a value which is a string
genome_ws has a value which is a workspace_id
name has a value which is a string
type has a value which is a string
regulons has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (name) a string
1: (features) a reference to a list where each element is a string
2: (stimuli) a reference to a list where each element is a reference to a list containing 6 items:
	0: (stimuli) a string
	1: (in_inhibitor) a bool
	2: (strength) a float
	3: (min_conc) a float
	4: (max_conc) a float
	5: (regulators) a reference to a list where each element is a kbase_id


auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
regmodel_uid has a value which is a string
workspace has a value which is a workspace_id
genome has a value which is a string
genome_ws has a value which is a workspace_id
name has a value which is a string
type has a value which is a string
regulons has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (name) a string
1: (features) a reference to a list where each element is a string
2: (stimuli) a reference to a list where each element is a reference to a list containing 6 items:
	0: (stimuli) a string
	1: (in_inhibitor) a bool
	2: (strength) a float
	3: (min_conc) a float
	4: (max_conc) a float
	5: (regulators) a reference to a list where each element is a kbase_id


auth has a value which is a string


=end text

=back



=head2 compare_models_params

=over 4



=item Description

********************************************************************************
    Functions relating to comparison of models
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
models has a value which is a reference to a list where each element is a fbamodel_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
models has a value which is a reference to a list where each element is a fbamodel_id
workspaces has a value which is a reference to a list where each element is a workspace_id
auth has a value which is a string


=end text

=back



=head2 ModelComparisonModel

=over 4



=item Description

Data structure to hold model comparison data

        fbamodel_id model - id of the fba model
        workspace_id workspace - id of workspace with model
        string model_name - name of the fba model
        genome_id genome - id of the genome for the fba model
        string genome_name - name of the genome for the fba model
        int core_reactions - number of core reactions in the fba model
        int unique_reactions - number of unique reactions in the fba model


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
model_name has a value which is a string
genome has a value which is a genome_id
genome_name has a value which is a string
gapfilled_reactions has a value which is an int
core_reactions has a value which is an int
noncore_reactions has a value which is an int

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a fbamodel_id
workspace has a value which is a workspace_id
model_name has a value which is a string
genome has a value which is a genome_id
genome_name has a value which is a string
gapfilled_reactions has a value which is an int
core_reactions has a value which is an int
noncore_reactions has a value which is an int


=end text

=back



=head2 ModelCompareReaction

=over 4



=item Description

Data structure to hold model reaction comparison data

        reaction_id reaction - id of the reaction
        compartment_id compartment - id of the reaction compartment
        string equation - equation for the reaction
        bool core - boolean indicating if the reaction is core
        mapping<fbamodel_id,list<feature_id> > model_features - map of models and features for reaction
        string role - role associated with the reaction
        string subsytem - subsystem associated with role
        string primclass - class one of the subsystem
        string subclass - class two of the subsystem
        int number_models - number of models with reaction
        float fraction_models - fraction of models with reaction


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
reaction has a value which is a reaction_id
compartment has a value which is a string
equation has a value which is a string
core has a value which is a bool
model_features has a value which is a reference to a hash where the key is a fbamodel_id and the value is a reference to a list where each element is a feature_id
role has a value which is a string
subsystem has a value which is a string
primclass has a value which is a string
subclass has a value which is a string
number_models has a value which is an int
fraction_models has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
reaction has a value which is a reaction_id
compartment has a value which is a string
equation has a value which is a string
core has a value which is a bool
model_features has a value which is a reference to a hash where the key is a fbamodel_id and the value is a reference to a list where each element is a feature_id
role has a value which is a string
subsystem has a value which is a string
primclass has a value which is a string
subclass has a value which is a string
number_models has a value which is an int
fraction_models has a value which is a float


=end text

=back



=head2 ModelComparisonData

=over 4



=item Description

Output structure for the "compare_models" function.

        list<ModelComparisonModel> model_comparisons;
        list<ModelCompareReaction> reaction_comparisons;


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model_comparisons has a value which is a reference to a list where each element is a ModelComparisonModel
reaction_comparisons has a value which is a reference to a list where each element is a ModelCompareReaction
auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model_comparisons has a value which is a reference to a list where each element is a ModelComparisonModel
reaction_comparisons has a value which is a reference to a list where each element is a ModelCompareReaction
auth has a value which is a string


=end text

=back



=head2 compare_genomes_params

=over 4



=item Description

********************************************************************************
    Functions relating to comparison of genomes
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
pangenome_id has a value which is a string
pangenome_ws has a value which is a string
protcomp_id has a value which is a string
protcomp_ws has a value which is a string
output_id has a value which is a string
workspace has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
pangenome_id has a value which is a string
pangenome_ws has a value which is a string
protcomp_id has a value which is a string
protcomp_ws has a value which is a string
output_id has a value which is a string
workspace has a value which is a string


=end text

=back



=head2 MetagenomeAnnotationOTUFunction

=over 4



=item Description

********************************************************************************
    Functions relating to construction of community models
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
kbid has a value which is a string
reference_genes has a value which is a reference to a list where each element is a string
functional_role has a value which is a string
abundance has a value which is an int
confidence has a value which is a float

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
kbid has a value which is a string
reference_genes has a value which is a reference to a list where each element is a string
functional_role has a value which is a string
abundance has a value which is an int
confidence has a value which is a float


=end text

=back



=head2 MetagenomeAnnotationOTU

=over 4



=item Description

Structure for the "MetagenomeAnnotationOTU" object

        string name - name of metagenome OTU
        string kbid - KBase ID of OTU of metagenome object
        string source_id - ID used for OTU in metagenome source
        string source - source OTU ID
        list<MetagenomeAnnotationOTUFunction> functions - list of functions in OTU


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
ave_confidence has a value which is a float
ave_coverage has a value which is a float
kbid has a value which is a string
name has a value which is a string
source_id has a value which is a string
source has a value which is a string
functions has a value which is a reference to a list where each element is a MetagenomeAnnotationOTUFunction

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
ave_confidence has a value which is a float
ave_coverage has a value which is a float
kbid has a value which is a string
name has a value which is a string
source_id has a value which is a string
source has a value which is a string
functions has a value which is a reference to a list where each element is a MetagenomeAnnotationOTUFunction


=end text

=back



=head2 MetagenomeAnnotation

=over 4



=item Description

Structure for the "MetagenomeAnnotation" object

        string type - type of metagenome object
        string name - name of metagenome object
        string kbid - KBase ID of metagenome object
        string source_id - ID used in metagenome source
        string source - source of metagenome data
        string confidence_type - type of confidence score
        list<MetagenomeAnnotationOTU> otus - list of otus in metagenome


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
type has a value which is a string
name has a value which is a string
kbid has a value which is a string
source_id has a value which is a string
source has a value which is a string
confidence_type has a value which is a string
otus has a value which is a reference to a list where each element is a MetagenomeAnnotationOTU

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
type has a value which is a string
name has a value which is a string
kbid has a value which is a string
source_id has a value which is a string
source has a value which is a string
confidence_type has a value which is a string
otus has a value which is a reference to a list where each element is a MetagenomeAnnotationOTU


=end text

=back



=head2 import_metagenome_annotation_params

=over 4



=item Description

Input parameters for the "import_metagenome_annotation" function.

        string metaanno_uid - ID to save metagenome in workspace
        workspace_id workspace - ID of workspace for metagenome object
        string source_id - ID used in metagenome data source
        string source - metagenome data source
        string type - type of metagenome
        string confidence_type - type of confidence score
        string name - name of metagenome
        list<tuple<list<string> genes,string functional_role,string otu,int abundance,float confidence,string confidence_type>> annotations;
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
metaanno_uid has a value which is a string
workspace has a value which is a workspace_id
source_id has a value which is a string
source has a value which is a string
type has a value which is a string
confidence_type has a value which is a string
name has a value which is a string
annotations has a value which is a reference to a list where each element is a reference to a list containing 5 items:
0: (genes) a reference to a list where each element is a string
1: (functional_role) a string
2: (otu) a string
3: (abundance) an int
4: (confidence) a float

auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
metaanno_uid has a value which is a string
workspace has a value which is a workspace_id
source_id has a value which is a string
source has a value which is a string
type has a value which is a string
confidence_type has a value which is a string
name has a value which is a string
annotations has a value which is a reference to a list where each element is a reference to a list containing 5 items:
0: (genes) a reference to a list where each element is a string
1: (functional_role) a string
2: (otu) a string
3: (abundance) an int
4: (confidence) a float

auth has a value which is a string


=end text

=back



=head2 models_to_community_model_params

=over 4



=item Description

Input parameters for the "models_to_community_model" function.

        string model_uid - ID of community model
        workspace_id workspace - workspace where community model should be saved
        string name - name of community model
        list<tuple<string model_uid,string model_ws,float abundance>> models - models to be merged into community model
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model_uid has a value which is a string
workspace has a value which is a workspace_id
name has a value which is a string
models has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (model_uid) a string
1: (model_ws) a string
2: (abundance) a float

auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model_uid has a value which is a string
workspace has a value which is a workspace_id
name has a value which is a string
models has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (model_uid) a string
1: (model_ws) a string
2: (abundance) a float

auth has a value which is a string


=end text

=back



=head2 metagenome_to_fbamodels_params

=over 4



=item Description

Input parameters for the "metagenome_to_fbamodel" function.

        string model_uid - ID of community model
        workspace_id workspace - workspace where community model should be saved
        string name - name of community model
        list<tuple<string model_uid,workspace_id model_ws,float abundance>> models - models to be merged into community model
        string auth - the authentication token of the KBase account changing workspace permissions; must have 'admin' privelages to workspace (an optional argument; user is "public" if auth is not provided)


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model_uids has a value which is a reference to a hash where the key is a string and the value is a string
workspace has a value which is a workspace_id
metaanno_uid has a value which is a string
metaanno_ws has a value which is a workspace_id
min_abundance has a value which is a float
confidence_threshold has a value which is a float
max_otu_models has a value which is an int
min_reactions has a value which is an int
templates has a value which is a reference to a hash where the key is a string and the value is a reference to a list containing 2 items:
0: (template_ws) a workspace_id
1: (template_uid) a template_id

auth has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model_uids has a value which is a reference to a hash where the key is a string and the value is a string
workspace has a value which is a workspace_id
metaanno_uid has a value which is a string
metaanno_ws has a value which is a workspace_id
min_abundance has a value which is a float
confidence_threshold has a value which is a float
max_otu_models has a value which is an int
min_reactions has a value which is an int
templates has a value which is a reference to a hash where the key is a string and the value is a reference to a list containing 2 items:
0: (template_ws) a workspace_id
1: (template_uid) a template_id

auth has a value which is a string


=end text

=back



=head2 sample_id

=over 4



=item Description

ID of gene expression sample


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 series_id

=over 4



=item Description

ID of gene expression sample series


=item Definition

=begin html

<pre>
a string
</pre>

=end html

=begin text

a string

=end text

=back



=head2 measurement

=over 4



=item Description

Normilized gene expression value


=item Definition

=begin html

<pre>
a float
</pre>

=end html

=begin text

a float

=end text

=back



=head2 ExpressionDataSample

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
sample_id has a value which is a string
data_expression_levels_for_sample has a value which is a reference to a hash where the key is a feature_id and the value is a measurement

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
sample_id has a value which is a string
data_expression_levels_for_sample has a value which is a reference to a hash where the key is a feature_id and the value is a measurement


=end text

=back



=head2 import_expression_params

=over 4



=item Description

Input parameters for the "simulate_expression" function.

               mapping<sample_id, ExpressionDataSample> expression_data_sample_series - gene expression data (a required argument)
        series_id series -  ID of series (a required argument)
        string source_id - ID of the source (an optional argument: default is '')
        string source_date - Date of the source (an optional argument: default is '')
        string processing_comments - comment (an optional argument: default is '')
        string description - description (an optional argument: default is '')
        workspace_id workspace - workspace to contain the data (an optional argument: default is value of workspace argument)                
        string numerical_interpretation - Numerical interpretation


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
expression_data_sample_series has a value which is a reference to a hash where the key is a sample_id and the value is an ExpressionDataSample
series has a value which is a series_id
source_id has a value which is a string
source_date has a value which is a string
description has a value which is a string
processing_comments has a value which is a string
workspace has a value which is a workspace_id
genome_id has a value which is a genome_id
numerical_interpretation has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
expression_data_sample_series has a value which is a reference to a hash where the key is a sample_id and the value is an ExpressionDataSample
series has a value which is a series_id
source_id has a value which is a string
source_date has a value which is a string
description has a value which is a string
processing_comments has a value which is a string
workspace has a value which is a workspace_id
genome_id has a value which is a genome_id
numerical_interpretation has a value which is a string


=end text

=back



=head2 effector

=over 4



=item Description

Import RegPrecise regulome.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
name has a value which is a string
class has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
name has a value which is a string
class has a value which is a string


=end text

=back



=head2 locus

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
name has a value which is a string
locus has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
name has a value which is a string
locus has a value which is a string


=end text

=back



=head2 operon

=over 4



=item Definition

=begin html

<pre>
a reference to a list where each element is a locus
</pre>

=end html

=begin text

a reference to a list where each element is a locus

=end text

=back



=head2 regulon

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
operons has a value which is a reference to a list where each element is an operon
transcription_factor has a value which is a locus
effectors has a value which is a reference to a list where each element is an effector
sign has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
operons has a value which is a reference to a list where each element is an operon
transcription_factor has a value which is a locus
effectors has a value which is a reference to a list where each element is an effector
sign has a value which is a string


=end text

=back



=head2 import_regulome_params

=over 4



=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
regulons has a value which is a reference to a list where each element is a regulon
workspace has a value which is a workspace_id
genome_workspace has a value which is a workspace_id
genome_id has a value which is a genome_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
regulons has a value which is a reference to a list where each element is a regulon
workspace has a value which is a workspace_id
genome_workspace has a value which is a workspace_id
genome_id has a value which is a genome_id


=end text

=back



=head2 CreatePromConstraintParameters

=over 4



=item Description

Named parameters for 'create_promconstraint' method.  Currently all options are required.

    genome_id genome_id             - the workspace ID of the genome to link to the prom object
    series_id series_id     - the workspace ID of the expression data collection needed to
                                                   build the PROM constraints.
    regulome_id  regulome_id        - the workspace ID of the regulatory network data to use
    promconstraint_id promconstraint_id - the the workspace ID for the new PROM constraint


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome_id has a value which is a genome_id
series_id has a value which is a series_id
regulome_id has a value which is a regulome_id
promconstraint_id has a value which is a promconstraint_id

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome_id has a value which is a genome_id
series_id has a value which is a series_id
regulome_id has a value which is a regulome_id
promconstraint_id has a value which is a promconstraint_id


=end text

=back



=head2 add_biochemistry_compounds_params

=over 4



=item Description

Add specified compounds to specified biochemistry


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
compounds has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (abbreviation) a string
1: (name) a string
2: (aliases) a reference to a list where each element is a string
3: (formula) a string
4: (charge) a float
5: (isCofactor) a bool
6: (structureString) a string
7: (structureType) a string
8: (id) a string

workspace has a value which is a string
biochemistry has a value which is a string
biochemistry_ws has a value which is a string
output_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
compounds has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (abbreviation) a string
1: (name) a string
2: (aliases) a reference to a list where each element is a string
3: (formula) a string
4: (charge) a float
5: (isCofactor) a bool
6: (structureString) a string
7: (structureType) a string
8: (id) a string

workspace has a value which is a string
biochemistry has a value which is a string
biochemistry_ws has a value which is a string
output_id has a value which is a string


=end text

=back



=head2 update_object_references_params

=over 4



=item Description

Update object references


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
object has a value which is a string
object_workspace has a value which is a string
original_object has a value which is a string
original_workspace has a value which is a string
original_instance has a value which is a string
reference_field has a value which is a string
newobject has a value which is a string
newobject_workspace has a value which is a string
newobject_instance has a value which is a string
create_newobject has a value which is a bool
update_subrefs has a value which is a bool
output_id has a value which is a string
workspace has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
object has a value which is a string
object_workspace has a value which is a string
original_object has a value which is a string
original_workspace has a value which is a string
original_instance has a value which is a string
reference_field has a value which is a string
newobject has a value which is a string
newobject_workspace has a value which is a string
newobject_instance has a value which is a string
create_newobject has a value which is a bool
update_subrefs has a value which is a bool
output_id has a value which is a string
workspace has a value which is a string


=end text

=back



=head2 add_reactions_params

=over 4



=item Description

********************************************************************************
    Functions relating to editing of genomes and models
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a string
model_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
reactions has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (reaction_id) a string
1: (compartment) a string
2: (direction) a string
3: (gpr) a string
4: (pathway) a string
5: (name) a string
6: (reference) a string
7: (enzyme) a string
8: (equation) a string


</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a string
model_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
reactions has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (reaction_id) a string
1: (compartment) a string
2: (direction) a string
3: (gpr) a string
4: (pathway) a string
5: (name) a string
6: (reference) a string
7: (enzyme) a string
8: (equation) a string



=end text

=back



=head2 remove_reactions_params

=over 4



=item Description

Input parameters for the "remove_reactions" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a string
model_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
reactions has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a string
model_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
reactions has a value which is a reference to a list where each element is a string


=end text

=back



=head2 modify_reactions_params

=over 4



=item Description

Input parameters for the "modify_reactions" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
model has a value which is a string
model_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
reactions has a value which is a reference to a list where each element is a reference to a list containing 7 items:
0: (reaction_id) a string
1: (direction) a string
2: (gpr) a string
3: (pathway) a string
4: (name) a string
5: (reference) a string
6: (enzyme) a string


</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
model has a value which is a string
model_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
reactions has a value which is a reference to a list where each element is a reference to a list containing 7 items:
0: (reaction_id) a string
1: (direction) a string
2: (gpr) a string
3: (pathway) a string
4: (name) a string
5: (reference) a string
6: (enzyme) a string



=end text

=back



=head2 add_features_params

=over 4



=item Description

Input parameters for the "add_features" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (feature) a feature_id
1: (function) a string
2: (type) a string
3: (aliases) a reference to a list where each element is a string
4: (publications) a reference to a list where each element is a string
5: (annotations) a reference to a list where each element is a string
6: (protein_translation) a string
7: (dna_sequence) a string
8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
	0: a string
	1: an int
	2: a string
	3: an int



</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (feature) a feature_id
1: (function) a string
2: (type) a string
3: (aliases) a reference to a list where each element is a string
4: (publications) a reference to a list where each element is a string
5: (annotations) a reference to a list where each element is a string
6: (protein_translation) a string
7: (dna_sequence) a string
8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
	0: a string
	1: an int
	2: a string
	3: an int




=end text

=back



=head2 remove_features_params

=over 4



=item Description

Input parameters for the "remove_features" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
features has a value which is a reference to a list where each element is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
features has a value which is a reference to a list where each element is a string


=end text

=back



=head2 modify_features_params

=over 4



=item Description

Input parameters for the "modify_genes" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (feature) a feature_id
1: (function) a string
2: (type) a string
3: (aliases) a reference to a list where each element is a string
4: (publications) a reference to a list where each element is a string
5: (annotations) a reference to a list where each element is a string
6: (protein_translation) a string
7: (dna_sequence) a string
8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
	0: a string
	1: an int
	2: a string
	3: an int



</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
genome has a value which is a string
genome_workspace has a value which is a string
output_id has a value which is a string
workspace has a value which is a string
genes has a value which is a reference to a list where each element is a reference to a list containing 9 items:
0: (feature) a feature_id
1: (function) a string
2: (type) a string
3: (aliases) a reference to a list where each element is a string
4: (publications) a reference to a list where each element is a string
5: (annotations) a reference to a list where each element is a string
6: (protein_translation) a string
7: (dna_sequence) a string
8: (locations) a reference to a list where each element is a reference to a list containing 4 items:
	0: a string
	1: an int
	2: a string
	3: an int




=end text

=back



=head2 import_trainingset_params

=over 4



=item Description

********************************************************************************
    Functions relating to classification of genomes
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
workspace_training_set has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (workspace_id) a string
1: (genome_id) a string
2: (class) a string

external_training_set has a value which is a reference to a list where each element is a reference to a list containing 4 items:
0: (database) a string
1: (genome_id) a string
2: (class) a string
3: (attributes) a reference to a list where each element is a string

description has a value which is a string
class_data has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (class) a string
1: (description) a string

attribute_type has a value which is a string
preload_attributes has a value which is a bool
workspace has a value which is a string
output_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
workspace_training_set has a value which is a reference to a list where each element is a reference to a list containing 3 items:
0: (workspace_id) a string
1: (genome_id) a string
2: (class) a string

external_training_set has a value which is a reference to a list where each element is a reference to a list containing 4 items:
0: (database) a string
1: (genome_id) a string
2: (class) a string
3: (attributes) a reference to a list where each element is a string

description has a value which is a string
class_data has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (class) a string
1: (description) a string

attribute_type has a value which is a string
preload_attributes has a value which is a bool
workspace has a value which is a string
output_id has a value which is a string


=end text

=back



=head2 preload_trainingset_params

=over 4



=item Description

Input parameters for the "preload_trainingset" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
trainingset has a value which is a string
trainingset_ws has a value which is a string
attribute_type has a value which is a string
workspace has a value which is a string
output_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
trainingset has a value which is a string
trainingset_ws has a value which is a string
attribute_type has a value which is a string
workspace has a value which is a string
output_id has a value which is a string


=end text

=back



=head2 build_classifier_params

=over 4



=item Description

Input parameters for the "build_classifier" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
trainingset has a value which is a string
trainingset_ws has a value which is a string
attribute_type has a value which is a string
classifier_type has a value which is a string
workspace has a value which is a string
output_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
trainingset has a value which is a string
trainingset_ws has a value which is a string
attribute_type has a value which is a string
classifier_type has a value which is a string
workspace has a value which is a string
output_id has a value which is a string


=end text

=back



=head2 classify_genomes_params

=over 4



=item Description

Input parameters for the "classify_genomes" function.


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
workspace_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (workspace_id) a string
1: (genome_id) a string

external_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (database) a string
1: (genome_id) a string

workspace has a value which is a string
output_id has a value which is a string
classify_ws has a value which is a string
classifier has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
workspace_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (workspace_id) a string
1: (genome_id) a string

external_genomes has a value which is a reference to a list where each element is a reference to a list containing 2 items:
0: (database) a string
1: (genome_id) a string

workspace has a value which is a string
output_id has a value which is a string
classify_ws has a value which is a string
classifier has a value which is a string


=end text

=back



=head2 build_tissue_model_params

=over 4



=item Description

********************************************************************************
    Functions relating to modeling of expression data
   	********************************************************************************


=item Definition

=begin html

<pre>
a reference to a hash where the following keys are defined:
expsample_ws has a value which is a string
expsample has a value which is a string
model_ws has a value which is a string
model has a value which is a string
workspace has a value which is a string
output_id has a value which is a string

</pre>

=end html

=begin text

a reference to a hash where the following keys are defined:
expsample_ws has a value which is a string
expsample has a value which is a string
model_ws has a value which is a string
model has a value which is a string
workspace has a value which is a string
output_id has a value which is a string


=end text

=back



=cut

1;
